
<!DOCTYPE html>


<html lang="en" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyxu.opt.solver.pds &#8212; Pyxu Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-codeautolink.css?v=125d5c1c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css?v=1031a718" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script src="../../../../_static/documentation_options.js?v=29481255"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../_static/copybutton.js?v=30646c52"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../../../_static/design-tabs.js?v=36754332"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pyxu/opt/solver/pds';</script>
    <link rel="icon" href="../../../../_static/favicon.png"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
    
    
    
    <img src="../../../../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../../../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../intro/index.html">
                        Getting Started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../guide/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../examples/index.html">
                        Example Gallery
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../api/index.html">
                        API Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../fair/index.html">
                        Extending Pyxu
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item"><strong> v0.0.1 </strong></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/matthieumeo/pyxu" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pyxu/" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="mailto: matthieu.simeoni@gmail.com" title="Contact" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-telegram"></i></span>
            <label class="sr-only">Contact</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://imaging.epfl.ch/" title="EPFL Center for Imaging" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../../../_static/imaging.png" class="icon-link-image" alt="EPFL Center for Imaging"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../intro/index.html">
                        Getting Started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../guide/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../examples/index.html">
                        Example Gallery
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../api/index.html">
                        API Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../../fair/index.html">
                        Extending Pyxu
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><strong> v0.0.1 </strong></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/matthieumeo/pyxu" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pyxu/" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="mailto: matthieu.simeoni@gmail.com" title="Contact" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-telegram"></i></span>
            <label class="sr-only">Contact</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://imaging.epfl.ch/" title="EPFL Center for Imaging" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../../../_static/imaging.png" class="icon-link-image" alt="EPFL Center for Imaging"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">pyxu.opt.solver.pds</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for pyxu.opt.solver.pds</h1><div class="highlight"><pre>
<span></span><span class="linenos">   1</span><span class="kn">import</span> <span class="nn">math</span>
<span class="linenos">   2</span><span class="kn">import</span> <span class="nn">types</span>
<span class="linenos">   3</span><span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">typ</span>
<span class="linenos">   4</span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="linenos">   5</span>
<span class="linenos">   6</span><span class="kn">import</span> <span class="nn">pyxu.abc</span> <span class="k">as</span> <span class="nn">pxa</span>
<span class="linenos">   7</span><span class="kn">import</span> <span class="nn">pyxu.info.ptype</span> <span class="k">as</span> <span class="nn">pxt</span>
<span class="linenos">   8</span><span class="kn">import</span> <span class="nn">pyxu.operator.func</span> <span class="k">as</span> <span class="nn">pxf</span>
<span class="linenos">   9</span><span class="kn">import</span> <span class="nn">pyxu.operator.linop</span> <span class="k">as</span> <span class="nn">pxl</span>
<span class="linenos">  10</span><span class="kn">import</span> <span class="nn">pyxu.opt.stop</span> <span class="k">as</span> <span class="nn">pxs</span>
<span class="linenos">  11</span><span class="kn">import</span> <span class="nn">pyxu.runtime</span> <span class="k">as</span> <span class="nn">pxrt</span>
<span class="linenos">  12</span>
<span class="linenos">  13</span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
<span class="linenos">  14</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;CondatVu&quot;</span><span class="p">,</span> <span class="s2">&quot;CV&quot;</span><span class="p">),</span>
<span class="linenos">  15</span>    <span class="s2">&quot;PD3O&quot;</span><span class="p">,</span>
<span class="linenos">  16</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;ChambollePock&quot;</span><span class="p">,</span> <span class="s2">&quot;CP&quot;</span><span class="p">),</span>
<span class="linenos">  17</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;LorisVerhoeven&quot;</span><span class="p">,</span> <span class="s2">&quot;LV&quot;</span><span class="p">),</span>
<span class="linenos">  18</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;DavisYin&quot;</span><span class="p">,</span> <span class="s2">&quot;DY&quot;</span><span class="p">),</span>
<span class="linenos">  19</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;DouglasRachford&quot;</span><span class="p">,</span> <span class="s2">&quot;DR&quot;</span><span class="p">),</span>
<span class="linenos">  20</span>    <span class="s2">&quot;ADMM&quot;</span><span class="p">,</span>
<span class="linenos">  21</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;ForwardBackward&quot;</span><span class="p">,</span> <span class="s2">&quot;FB&quot;</span><span class="p">),</span>
<span class="linenos">  22</span>    <span class="o">*</span><span class="p">(</span><span class="s2">&quot;ProximalPoint&quot;</span><span class="p">,</span> <span class="s2">&quot;PP&quot;</span><span class="p">),</span>
<span class="linenos">  23</span><span class="p">]</span>
<span class="linenos">  24</span>
<span class="linenos">  25</span>
<span class="linenos">  26</span><span class="k">class</span> <span class="nc">_PrimalDualSplitting</span><span class="p">(</span><span class="n">pxa</span><span class="o">.</span><span class="n">Solver</span><span class="p">):</span>
<span class="linenos">  27</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">  28</span><span class="sd">    Base class for Primal-Dual Splitting (PDS) solvers.</span>
<span class="linenos">  29</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">  30</span>    <span class="n">TuningSpec</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1">#: valid tuning_parameter values</span>
<span class="linenos">  31</span>
<span class="linenos">  32</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">  33</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">  34</span>        <span class="n">f</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  35</span>        <span class="n">g</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  36</span>        <span class="n">h</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  37</span>        <span class="n">K</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffMap</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  38</span>        <span class="n">beta</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  39</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">  40</span>    <span class="p">):</span>
<span class="linenos">  41</span>        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<span class="linenos">  42</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos">  43</span>        <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos">  44</span>            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
<span class="linenos">  45</span>                <span class="p">[</span>
<span class="linenos">  46</span>                    <span class="s2">&quot;Cannot minimize always-0 functional.&quot;</span><span class="p">,</span>
<span class="linenos">  47</span>                    <span class="s2">&quot;At least one of Parameter[f, g, h] must be specified.&quot;</span><span class="p">,</span>
<span class="linenos">  48</span>                <span class="p">]</span>
<span class="linenos">  49</span>            <span class="p">)</span>
<span class="linenos">  50</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos">  51</span>
<span class="linenos">  52</span>        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">  53</span>            <span class="n">primal_dim</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dim</span>
<span class="linenos">  54</span>        <span class="k">elif</span> <span class="n">g</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">  55</span>            <span class="n">primal_dim</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dim</span>
<span class="linenos">  56</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">  57</span>            <span class="n">primal_dim</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dim</span>
<span class="linenos">  58</span>
<span class="linenos">  59</span>        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">  60</span>            <span class="n">dual_dim</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">dim</span>
<span class="linenos">  61</span>        <span class="k">elif</span> <span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># todo: isn&#39;t this elif-clause useless? For which solver is it triggered?</span>
<span class="linenos">  62</span>            <span class="n">dual_dim</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># todo: K.codim?</span>
<span class="linenos">  63</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">  64</span>            <span class="n">dual_dim</span> <span class="o">=</span> <span class="n">primal_dim</span>
<span class="linenos">  65</span>
<span class="linenos">  66</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">.</span><span class="n">NullFunc</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">primal_dim</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">f</span>
<span class="linenos">  67</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_g</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">.</span><span class="n">NullFunc</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">primal_dim</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">g</span>
<span class="linenos">  68</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_h</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">.</span><span class="n">NullFunc</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dual_dim</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">h</span>
<span class="linenos">  69</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_beta</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
<span class="linenos">  70</span>        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">  71</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">.</span><span class="n">IdentityOp</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">h</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">K</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">K</span>
<span class="linenos">  72</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">  73</span>            <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">  74</span>                <span class="n">K_dim</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dim</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">g</span><span class="o">.</span><span class="n">dim</span>
<span class="linenos">  75</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">=</span> <span class="n">pxl</span><span class="o">.</span><span class="n">NullOp</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">K_dim</span><span class="p">,</span> <span class="n">K_dim</span><span class="p">))</span>
<span class="linenos">  76</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">  77</span>                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Optional argument ``h`` mut be specified if ``K`` is not None.&quot;</span><span class="p">)</span>
<span class="linenos">  78</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_objective_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_h</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">)</span>
<span class="linenos">  79</span>
<span class="linenos">  80</span>    <span class="nd">@pxrt</span><span class="o">.</span><span class="n">enforce_precision</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="s2">&quot;z0&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="s2">&quot;rho&quot;</span><span class="p">),</span> <span class="n">allow_None</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">  81</span>    <span class="k">def</span> <span class="nf">m_init</span><span class="p">(</span>
<span class="linenos">  82</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">  83</span>        <span class="n">x0</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
<span class="linenos">  84</span>        <span class="n">z0</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  85</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  86</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  87</span>        <span class="n">rho</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">  88</span>        <span class="n">tuning_strategy</span><span class="p">:</span> <span class="n">TuningSpec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="linenos">  89</span>    <span class="p">):</span>
<span class="linenos">  90</span>        <span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span>  <span class="c1"># shorthand</span>
<span class="linenos">  91</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
<span class="linenos">  92</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_dual_variable</span><span class="p">(</span><span class="n">z0</span><span class="p">)</span>
<span class="linenos">  93</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_tuning_strategy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tuning_strategy</span><span class="p">)</span>
<span class="linenos">  94</span>        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_gamma</span><span class="p">(</span><span class="n">tuning_strategy</span><span class="p">)</span>
<span class="linenos">  95</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">],</span> <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_step_sizes</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
<span class="linenos">  96</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_momentum_term</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
<span class="linenos">  97</span>
<span class="linenos">  98</span>    <span class="k">def</span> <span class="nf">m_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">  99</span>        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
<span class="linenos"> 100</span>
<span class="linenos"> 101</span>    <span class="k">def</span> <span class="nf">default_stop_crit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxa</span><span class="o">.</span><span class="n">StoppingCriterion</span><span class="p">:</span>
<span class="linenos"> 102</span>        <span class="n">stop_crit_x</span> <span class="o">=</span> <span class="n">pxs</span><span class="o">.</span><span class="n">RelError</span><span class="p">(</span>
<span class="linenos"> 103</span>            <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="linenos"> 104</span>            <span class="n">var</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span>
<span class="linenos"> 105</span>            <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 106</span>            <span class="n">norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="linenos"> 107</span>            <span class="n">satisfy_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="linenos"> 108</span>        <span class="p">)</span>
<span class="linenos"> 109</span>        <span class="n">stop_crit_z</span> <span class="o">=</span> <span class="n">pxs</span><span class="o">.</span><span class="n">RelError</span><span class="p">(</span>
<span class="linenos"> 110</span>            <span class="n">eps</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="linenos"> 111</span>            <span class="n">var</span><span class="o">=</span><span class="s2">&quot;z&quot;</span><span class="p">,</span>
<span class="linenos"> 112</span>            <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 113</span>            <span class="n">norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="linenos"> 114</span>            <span class="n">satisfy_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="linenos"> 115</span>        <span class="p">)</span>
<span class="linenos"> 116</span>        <span class="k">return</span> <span class="n">stop_crit_x</span> <span class="o">&amp;</span> <span class="n">stop_crit_z</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">!=</span> <span class="s2">&quot;NullFunc&quot;</span> <span class="k">else</span> <span class="n">stop_crit_x</span>
<span class="linenos"> 117</span>
<span class="linenos"> 118</span>    <span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;primal&quot;</span><span class="p">,</span> <span class="s2">&quot;dual&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;primal&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="linenos"> 119</span>        <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span>
<span class="linenos"> 120</span>        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;primal&quot;</span><span class="p">:</span>
<span class="linenos"> 121</span>            <span class="k">assert</span> <span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;Primal variable x was not logged (declare it in log_var to log it).&quot;</span>
<span class="linenos"> 122</span>        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;dual&quot;</span><span class="p">:</span>
<span class="linenos"> 123</span>            <span class="k">assert</span> <span class="s2">&quot;z&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;Dual variable z was not logged (declare it in log_var to log it).&quot;</span>
<span class="linenos"> 124</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 125</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter which must be one of [&#39;primal&#39;, &#39;dual&#39;] got: </span><span class="si">{</span><span class="n">which</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="linenos"> 126</span>        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;primal&quot;</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span>
<span class="linenos"> 127</span>
<span class="linenos"> 128</span>    <span class="k">def</span> <span class="nf">objective_func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="linenos"> 129</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objective_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
<span class="linenos"> 130</span>
<span class="linenos"> 131</span>    <span class="nd">@pxrt</span><span class="o">.</span><span class="n">enforce_precision</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="s2">&quot;beta&quot;</span><span class="p">,</span> <span class="n">allow_None</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 132</span>    <span class="k">def</span> <span class="nf">_set_beta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">:</span>
<span class="linenos"> 133</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 134</span><span class="sd">        Sets the Lipschitz constant.</span>
<span class="linenos"> 135</span>
<span class="linenos"> 136</span><span class="sd">        Returns</span>
<span class="linenos"> 137</span><span class="sd">        -------</span>
<span class="linenos"> 138</span><span class="sd">        beta: Real</span>
<span class="linenos"> 139</span><span class="sd">            Lipschitz constant.</span>
<span class="linenos"> 140</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 141</span>        <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 142</span>            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dl</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">diff_lipschitz</span><span class="p">):</span>
<span class="linenos"> 143</span>                <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>
<span class="linenos"> 144</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 145</span>                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;beta: automatic inference not supported for operators with unbounded Lipschitz gradients.&quot;</span>
<span class="linenos"> 146</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 147</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 148</span>            <span class="k">return</span> <span class="n">beta</span>
<span class="linenos"> 149</span>
<span class="linenos"> 150</span>    <span class="k">def</span> <span class="nf">_set_dual_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="linenos"> 151</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 152</span><span class="sd">        Initialize the dual variable if it is :py:obj:`None` by mapping the primal variable through the operator K.</span>
<span class="linenos"> 153</span>
<span class="linenos"> 154</span><span class="sd">        Returns</span>
<span class="linenos"> 155</span><span class="sd">        -------</span>
<span class="linenos"> 156</span><span class="sd">        NDArray</span>
<span class="linenos"> 157</span><span class="sd">            Initialized dual variable.</span>
<span class="linenos"> 158</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 159</span>        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 160</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
<span class="linenos"> 161</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 162</span>            <span class="k">return</span> <span class="n">z</span>
<span class="linenos"> 163</span>
<span class="linenos"> 164</span>    <span class="k">def</span> <span class="nf">_set_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tuning_strategy</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">:</span>
<span class="linenos"> 165</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 166</span><span class="sd">        Sets the gamma parameter according to the tuning strategy.</span>
<span class="linenos"> 167</span>
<span class="linenos"> 168</span><span class="sd">        Returns</span>
<span class="linenos"> 169</span><span class="sd">        -------</span>
<span class="linenos"> 170</span><span class="sd">        gamma: Real</span>
<span class="linenos"> 171</span><span class="sd">            Gamma parameter.</span>
<span class="linenos"> 172</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 173</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">)</span> <span class="k">if</span> <span class="n">tuning_strategy</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">/</span> <span class="mf">1.9</span><span class="p">)</span>
<span class="linenos"> 174</span>
<span class="linenos"> 175</span>    <span class="k">def</span> <span class="nf">_set_step_sizes</span><span class="p">(</span>
<span class="linenos"> 176</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 177</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 178</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 179</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span>
<span class="linenos"> 180</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos"> 181</span>        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
<span class="linenos"> 182</span>
<span class="linenos"> 183</span>    <span class="k">def</span> <span class="nf">_set_momentum_term</span><span class="p">(</span>
<span class="linenos"> 184</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 185</span>        <span class="n">rho</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 186</span>        <span class="n">delta</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span>
<span class="linenos"> 187</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">:</span>
<span class="linenos"> 188</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 189</span><span class="sd">        Sets the momentum term according to Theorem 8.2 in [PSA]_.</span>
<span class="linenos"> 190</span>
<span class="linenos"> 191</span><span class="sd">        Returns</span>
<span class="linenos"> 192</span><span class="sd">        -------</span>
<span class="linenos"> 193</span><span class="sd">        pho: Real</span>
<span class="linenos"> 194</span><span class="sd">            Momentum term.</span>
<span class="linenos"> 195</span>
<span class="linenos"> 196</span><span class="sd">        Notes</span>
<span class="linenos"> 197</span><span class="sd">        -----</span>
<span class="linenos"> 198</span><span class="sd">        The :math:`O(1/\sqrt(k))` objective functional convergence rate of (Theorem 1 of [dPSA]_) is for `\rho=1`.</span>
<span class="linenos"> 199</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 200</span>        <span class="k">if</span> <span class="n">rho</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 201</span>            <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tuning_strategy</span> <span class="o">!=</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">delta</span> <span class="o">-</span> <span class="mf">0.1</span>
<span class="linenos"> 202</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 203</span>            <span class="k">assert</span> <span class="n">rho</span> <span class="o">&lt;=</span> <span class="n">delta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Parameter rho must be smaller than delta: </span><span class="si">{</span><span class="n">rho</span><span class="si">}</span><span class="s2"> &gt; </span><span class="si">{</span><span class="n">delta</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos"> 204</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="linenos"> 205</span>
<span class="linenos"> 206</span>
<span class="linenos"> 207</span><span class="n">_PDS</span> <span class="o">=</span> <span class="n">_PrimalDualSplitting</span>  <span class="c1">#: shorthand</span>
<span class="linenos"> 208</span>
<span class="linenos"> 209</span>
<div class="viewcode-block" id="CondatVu">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.CondatVu">[docs]</a>
<span class="linenos"> 210</span><span class="k">class</span> <span class="nc">CondatVu</span><span class="p">(</span><span class="n">_PrimalDualSplitting</span><span class="p">):</span>
<span class="linenos"> 211</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 212</span><span class="sd">    Condat-Vu (CV) primal-dual splitting algorithm.</span>
<span class="linenos"> 213</span>
<span class="linenos"> 214</span><span class="sd">    This solver is also accessible via the alias :py:class:`~pyxu.opt.solver.pds.CV`.</span>
<span class="linenos"> 215</span>
<span class="linenos"> 216</span><span class="sd">    The *Condat-Vu (CV)* primal-dual method is described in [CVS]_.</span>
<span class="linenos"> 217</span><span class="sd">    (This particular implementation is based on the pseudo-code Algorithm 7.1 provided in [FuncSphere]_ Chapter 7, Section1.)</span>
<span class="linenos"> 218</span>
<span class="linenos"> 219</span><span class="sd">    It can be used to solve problems of the form:</span>
<span class="linenos"> 220</span>
<span class="linenos"> 221</span><span class="sd">    .. math::</span>
<span class="linenos"> 222</span>
<span class="linenos"> 223</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \;\mathcal{F}(\mathbf{x})\;\;+\;\;\mathcal{G}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathcal{K} \mathbf{x})},</span>
<span class="linenos"> 224</span>
<span class="linenos"> 225</span><span class="sd">    where:</span>
<span class="linenos"> 226</span>
<span class="linenos"> 227</span><span class="sd">    * :math:`\mathcal{F}:\mathbb{R}^N\rightarrow \mathbb{R}` is *convex* and *differentiable*, with :math:`\beta`-*Lipschitz continuous* gradient,</span>
<span class="linenos"> 228</span><span class="sd">      for some :math:`\beta\in[0,+\infty[`.</span>
<span class="linenos"> 229</span>
<span class="linenos"> 230</span><span class="sd">    * :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` and :math:`\mathcal{H}:\mathbb{R}^M\rightarrow \mathbb{R}\cup\{+\infty\}`</span>
<span class="linenos"> 231</span><span class="sd">      are *proper*, *lower semicontinuous* and *convex functions* with *simple proximal operators*.</span>
<span class="linenos"> 232</span>
<span class="linenos"> 233</span><span class="sd">    * :math:`\mathcal{K}:\mathbb{R}^N\rightarrow \mathbb{R}^M` is a *differentiable map* (e.g. a *linear operator* :math:`\mathbf{K}`), with **operator norm**:</span>
<span class="linenos"> 234</span>
<span class="linenos"> 235</span><span class="sd">      .. math::</span>
<span class="linenos"> 236</span>
<span class="linenos"> 237</span><span class="sd">         \Vert{\mathcal{K}}\Vert_2=\sup_{\mathbf{x}\in\mathbb{R}^N,\Vert\mathbf{x}\Vert_2=1} \Vert\mathcal{K}(\mathbf{x})\Vert_2.</span>
<span class="linenos"> 238</span>
<span class="linenos"> 239</span><span class="sd">    Remarks</span>
<span class="linenos"> 240</span><span class="sd">    -------</span>
<span class="linenos"> 241</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos"> 242</span>
<span class="linenos"> 243</span><span class="sd">    * The algorithm is still valid if one or more of the terms :math:`\mathcal{F}`, :math:`\mathcal{G}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos"> 244</span>
<span class="linenos"> 245</span><span class="sd">    * The algorithm has convergence guarantees when :math:`\mathcal{H}` is composed with a *linear operator* :math:`\mathbf{K}`.</span>
<span class="linenos"> 246</span><span class="sd">      When :math:`\mathcal{F}=0`, convergence can be proven for *non-linear differentiable maps* :math:`\mathcal{K}` (see [NLCP]_).</span>
<span class="linenos"> 247</span><span class="sd">      Note that :py:class:`~pyxu.opt.solver.pds.CondatVu` does not yet support automatic selection of hyperparameters for the case of *non-linear differentiable maps* :math:`\mathcal{K}`.</span>
<span class="linenos"> 248</span>
<span class="linenos"> 249</span><span class="sd">    * Assume that either of the following holds:</span>
<span class="linenos"> 250</span>
<span class="linenos"> 251</span><span class="sd">      * :math:`\beta&gt;0` and:</span>
<span class="linenos"> 252</span>
<span class="linenos"> 253</span><span class="sd">        - :math:`\gamma \geq \frac{\beta}{2}`,</span>
<span class="linenos"> 254</span><span class="sd">        - :math:`\frac{1}{\tau}-\sigma\Vert\mathbf{K}\Vert_{2}^2\geq \gamma`,</span>
<span class="linenos"> 255</span><span class="sd">        - :math:`\rho \in ]0,\delta[`, where :math:`\delta:=2-\frac{\beta}{2}\gamma^{-1}\in[1,2[` (:math:`\delta=2` is possible when :math:`\mathcal{F}` is *quadratic*</span>
<span class="linenos"> 256</span><span class="sd">          and :math:`\gamma \geq \beta`, see [PSA]_).</span>
<span class="linenos"> 257</span>
<span class="linenos"> 258</span><span class="sd">      * :math:`\beta=0` and:</span>
<span class="linenos"> 259</span>
<span class="linenos"> 260</span><span class="sd">        - :math:`\tau\sigma\Vert\mathbf{K}\Vert_{2}^2\leq 1`,</span>
<span class="linenos"> 261</span><span class="sd">        - :math:`\rho \in ]0,2[`.</span>
<span class="linenos"> 262</span>
<span class="linenos"> 263</span><span class="sd">      Then there exists a pair :math:`(\mathbf{x}^\star,\mathbf{z}^\star)\in\mathbb{R}^N\times \mathbb{R}^M` solution s.t. the primal and dual sequences</span>
<span class="linenos"> 264</span><span class="sd">      of  estimates :math:`(\mathbf{x}_n)_{n\in\mathbb{N}}` and :math:`(\mathbf{z}_n)_{n\in\mathbb{N}}` *converge* towards :math:`\mathbf{x}^\star` and</span>
<span class="linenos"> 265</span><span class="sd">      :math:`\mathbf{z}^\star` respectively, i.e.</span>
<span class="linenos"> 266</span>
<span class="linenos"> 267</span><span class="sd">      .. math::</span>
<span class="linenos"> 268</span>
<span class="linenos"> 269</span><span class="sd">         \lim_{n\rightarrow +\infty}\Vert\mathbf{x}^\star-\mathbf{x}_n\Vert_2=0, \quad \text{and}</span>
<span class="linenos"> 270</span><span class="sd">         \quad</span>
<span class="linenos"> 271</span><span class="sd">         \lim_{n\rightarrow +\infty}\Vert\mathbf{z}^\star-\mathbf{z}_n\Vert_2=0.</span>
<span class="linenos"> 272</span>
<span class="linenos"> 273</span><span class="sd">    Parameters (``__init__()``)</span>
<span class="linenos"> 274</span><span class="sd">    ---------------------------</span>
<span class="linenos"> 275</span><span class="sd">    * **f** (:py:class:`~pyxu.abc.operator.DiffFunc`, :py:obj:`None`)</span>
<span class="linenos"> 276</span><span class="sd">      --</span>
<span class="linenos"> 277</span><span class="sd">      Differentiable function :math:`\mathcal{F}`.</span>
<span class="linenos"> 278</span><span class="sd">    * **g** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos"> 279</span><span class="sd">      --</span>
<span class="linenos"> 280</span><span class="sd">      Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos"> 281</span><span class="sd">    * **h** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos"> 282</span><span class="sd">      --</span>
<span class="linenos"> 283</span><span class="sd">      Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos"> 284</span><span class="sd">    * **K** (:py:class:`~pyxu.abc.operator.DiffMap`, :py:class:`~pyxu.abc.operator.LinOp`, :py:obj:`None`)</span>
<span class="linenos"> 285</span><span class="sd">      --</span>
<span class="linenos"> 286</span><span class="sd">      Differentiable map or linear operator :math:`\mathcal{K}`.</span>
<span class="linenos"> 287</span><span class="sd">    * **beta** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 288</span><span class="sd">      --</span>
<span class="linenos"> 289</span><span class="sd">      Lipschitz constant :math:`\beta` of :math:`\nabla\mathcal{F}`.</span>
<span class="linenos"> 290</span><span class="sd">      If not provided, it will be automatically estimated.</span>
<span class="linenos"> 291</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos"> 292</span><span class="sd">      --</span>
<span class="linenos"> 293</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos"> 294</span>
<span class="linenos"> 295</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos"> 296</span><span class="sd">    ----------------------</span>
<span class="linenos"> 297</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos"> 298</span><span class="sd">      --</span>
<span class="linenos"> 299</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos"> 300</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos"> 301</span><span class="sd">      --</span>
<span class="linenos"> 302</span><span class="sd">      (..., M) initial point(s) for the dual variable.</span>
<span class="linenos"> 303</span><span class="sd">      If ``None`` (default), then use ``K(x0)`` as the initial point for the dual variable.</span>
<span class="linenos"> 304</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 305</span><span class="sd">      --</span>
<span class="linenos"> 306</span><span class="sd">      Primal step size.</span>
<span class="linenos"> 307</span><span class="sd">    * **sigma** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 308</span><span class="sd">      --</span>
<span class="linenos"> 309</span><span class="sd">      Dual step size.</span>
<span class="linenos"> 310</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 311</span><span class="sd">      --</span>
<span class="linenos"> 312</span><span class="sd">      Momentum parameter.</span>
<span class="linenos"> 313</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos"> 314</span><span class="sd">      --</span>
<span class="linenos"> 315</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos"> 316</span><span class="sd">      See section below for more details.</span>
<span class="linenos"> 317</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos"> 318</span><span class="sd">      --</span>
<span class="linenos"> 319</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos"> 320</span>
<span class="linenos"> 321</span><span class="sd">    .. rubric:: Default hyperparameter values</span>
<span class="linenos"> 322</span>
<span class="linenos"> 323</span><span class="sd">    This class supports three strategies to automatically set the hyperparameters (see [PSA]_ for more details and numerical experiments</span>
<span class="linenos"> 324</span><span class="sd">    comparing the performance of the three strategies):</span>
<span class="linenos"> 325</span>
<span class="linenos"> 326</span><span class="sd">    - ``tuning_strategy == 1``: :math:`\gamma = \beta` (safe step sizes) and :math:`\rho=1` (no relaxation).</span>
<span class="linenos"> 327</span>
<span class="linenos"> 328</span><span class="sd">      This is the most standard way of setting the parameters in the literature.</span>
<span class="linenos"> 329</span><span class="sd">    - ``tuning_strategy == 2``: :math:`\gamma = \beta/1.9` (large step sizes) and :math:`\rho=1` (no relaxation).</span>
<span class="linenos"> 330</span>
<span class="linenos"> 331</span><span class="sd">      This strategy favours large step sizes forbidding the use of overrelaxation.</span>
<span class="linenos"> 332</span><span class="sd">      When :math:`\beta=0`, coincides with the first strategy.</span>
<span class="linenos"> 333</span><span class="sd">    - ``tuning_strategy == 3``: :math:`\gamma = \beta` (safe step sizes) and :math:`\rho=\delta - 0.1 &gt; 1` (overrelaxation).</span>
<span class="linenos"> 334</span>
<span class="linenos"> 335</span><span class="sd">      This strategy chooses smaller step sizes, but performs overrelaxation.</span>
<span class="linenos"> 336</span>
<span class="linenos"> 337</span><span class="sd">    Once :math:`\gamma` chosen, the convergence speed  of the algorithm is improved by choosing :math:`\sigma` and :math:`\tau` as</span>
<span class="linenos"> 338</span><span class="sd">    large as possible and relatively well-balanced -- so that both the primal and dual variables converge at the same pace.</span>
<span class="linenos"> 339</span><span class="sd">    Whenever possible, we therefore choose perfectly balanced parameters :math:`\sigma=\tau` saturating the convergence inequalities for a given value of :math:`\gamma`.</span>
<span class="linenos"> 340</span>
<span class="linenos"> 341</span><span class="sd">    * For :math:`\beta&gt;0` and :math:`\mathcal{H}\neq 0` this yields:</span>
<span class="linenos"> 342</span>
<span class="linenos"> 343</span><span class="sd">      .. math::</span>
<span class="linenos"> 344</span>
<span class="linenos"> 345</span><span class="sd">         \frac{1}{\tau}-\tau\Vert\mathbf{K}\Vert_{2}^2= \gamma \quad\Longleftrightarrow\quad -\tau^2\Vert\mathbf{K}\Vert_{2}^2-\gamma\tau+1=0,</span>
<span class="linenos"> 346</span>
<span class="linenos"> 347</span><span class="sd">      which admits one positive root</span>
<span class="linenos"> 348</span>
<span class="linenos"> 349</span><span class="sd">      .. math::</span>
<span class="linenos"> 350</span>
<span class="linenos"> 351</span><span class="sd">         \tau=\sigma=\frac{1}{\Vert\mathbf{K}\Vert_{2}^2}\left(-\frac{\gamma}{2}+\sqrt{\frac{\gamma^2}{4}+\Vert\mathbf{K}\Vert_{2}^2}\right).</span>
<span class="linenos"> 352</span>
<span class="linenos"> 353</span><span class="sd">    * For :math:`\beta&gt;0` and :math:`\mathcal{H}=0` this yields: :math:`\tau=1/\gamma.`</span>
<span class="linenos"> 354</span>
<span class="linenos"> 355</span><span class="sd">    * For :math:`\beta=0` this yields: :math:`\tau=\sigma=\Vert\mathbf{K}\Vert_{2}^{-1}`.</span>
<span class="linenos"> 356</span>
<span class="linenos"> 357</span><span class="sd">    When :math:`\tau` is provided (:math:`\tau = \tau_{1}`), but not :math:`\sigma`, the latter is chosen as:</span>
<span class="linenos"> 358</span>
<span class="linenos"> 359</span><span class="sd">    .. math::</span>
<span class="linenos"> 360</span>
<span class="linenos"> 361</span><span class="sd">       \frac{1}{\tau_{1}}-\sigma\Vert\mathbf{K}\Vert_{2}^2= \gamma \quad\Longleftrightarrow\quad \sigma=\left(\frac{1}{\tau_{1}}-\gamma\right)\frac{1}{\Vert\mathbf{K}\Vert_{2}^2}.</span>
<span class="linenos"> 362</span>
<span class="linenos"> 363</span><span class="sd">    When :math:`\sigma` is provided (:math:`\sigma = \sigma_{1}`), but not :math:`\tau`, the latter is chosen as:</span>
<span class="linenos"> 364</span>
<span class="linenos"> 365</span><span class="sd">    .. math::</span>
<span class="linenos"> 366</span>
<span class="linenos"> 367</span><span class="sd">       \frac{1}{\tau}-\sigma_{1}\Vert\mathbf{K}\Vert_{2}^2= \gamma \quad\Longleftrightarrow\quad \tau=\frac{1}{\left(\gamma+\sigma_{1}\Vert\mathbf{K}\Vert_{2}^2\right)}.</span>
<span class="linenos"> 368</span>
<span class="linenos"> 369</span><span class="sd">    Warning</span>
<span class="linenos"> 370</span><span class="sd">    -------</span>
<span class="linenos"> 371</span><span class="sd">    When values are provided for both :math:`\tau` and :math:`\sigma`, it is assumed that the latter satisfy the</span>
<span class="linenos"> 372</span><span class="sd">    convergence inequalities, but no check is explicitly performed.</span>
<span class="linenos"> 373</span><span class="sd">    Automatic selection of hyperparameters for the case of non-linear differentiable maps :math:`\mathcal{K}` is not supported yet.</span>
<span class="linenos"> 374</span>
<span class="linenos"> 375</span><span class="sd">    Example</span>
<span class="linenos"> 376</span><span class="sd">    -------</span>
<span class="linenos"> 377</span><span class="sd">    Consider the following optimisation problem:</span>
<span class="linenos"> 378</span>
<span class="linenos"> 379</span><span class="sd">    .. math::</span>
<span class="linenos"> 380</span>
<span class="linenos"> 381</span><span class="sd">       \min_{\mathbf{x}\in\mathbb{R}_+^N}\frac{1}{2}\left\|\mathbf{y}-\mathbf{G}\mathbf{x}\right\|_2^2\quad+\quad\lambda_1 \|\mathbf{D}\mathbf{x}\|_1\quad+\quad\lambda_2 \|\mathbf{x}\|_1,</span>
<span class="linenos"> 382</span>
<span class="linenos"> 383</span><span class="sd">    with :math:`\mathbf{D}\in\mathbb{R}^{N\times N}` the discrete derivative operator and :math:`\mathbf{G}\in\mathbb{R}^{L\times N}, \, \mathbf{y}\in\mathbb{R}^L, \lambda_1,\lambda_2&gt;0.`</span>
<span class="linenos"> 384</span><span class="sd">    This problem can be solved via PDS with :math:`\mathcal{F}(\mathbf{x})= \frac{1}{2}\left\|\mathbf{y}-\mathbf{G}\mathbf{x}\right\|_2^2`, :math:`\mathcal{G}(\mathbf{x})=\lambda_2\|\mathbf{x}\|_1,`</span>
<span class="linenos"> 385</span><span class="sd">    :math:`\mathcal{H}(\mathbf{x})=\lambda \|\mathbf{x}\|_1` and :math:`\mathbf{K}=\mathbf{D}`.</span>
<span class="linenos"> 386</span>
<span class="linenos"> 387</span><span class="sd">    .. plot::</span>
<span class="linenos"> 388</span>
<span class="linenos"> 389</span><span class="sd">       import matplotlib.pyplot as plt</span>
<span class="linenos"> 390</span><span class="sd">       import numpy as np</span>
<span class="linenos"> 391</span><span class="sd">       import pyxu.operator as pxo</span>
<span class="linenos"> 392</span><span class="sd">       from pyxu.experimental._dev import DownSampling, FirstDerivative</span>
<span class="linenos"> 393</span><span class="sd">       from pyxu.opt.solver import CV</span>
<span class="linenos"> 394</span>
<span class="linenos"> 395</span><span class="sd">       x = np.repeat(np.asarray([0, 2, 1, 3, 0, 2, 0]), 10)</span>
<span class="linenos"> 396</span><span class="sd">       N = x.size</span>
<span class="linenos"> 397</span>
<span class="linenos"> 398</span><span class="sd">       D = FirstDerivative(size=N, kind=&quot;forward&quot;)</span>
<span class="linenos"> 399</span><span class="sd">       D.lipschitz = D.estimate_lipschitz()</span>
<span class="linenos"> 400</span>
<span class="linenos"> 401</span><span class="sd">       downsample = DownSampling(size=N, downsampling_factor=3)</span>
<span class="linenos"> 402</span><span class="sd">       y = downsample(x)</span>
<span class="linenos"> 403</span><span class="sd">       loss = (1 / 2) * pxo.SquaredL2Norm(y.size).argshift(-y)</span>
<span class="linenos"> 404</span><span class="sd">       F = loss * downsample</span>
<span class="linenos"> 405</span><span class="sd">       F.diff_lipschitz = F.estimate_diff_lipschitz()</span>
<span class="linenos"> 406</span>
<span class="linenos"> 407</span><span class="sd">       cv = CV(f=F, g=0.01 * pxo.L1Norm(N), h=0.1 * pxo.L1Norm(N), K=D)</span>
<span class="linenos"> 408</span><span class="sd">       x0, z0 = np.zeros((2, N))</span>
<span class="linenos"> 409</span><span class="sd">       cv.fit(x0=x0, z0=z0)</span>
<span class="linenos"> 410</span><span class="sd">       x_recons = cv.solution()[0]</span>
<span class="linenos"> 411</span>
<span class="linenos"> 412</span><span class="sd">       plt.figure()</span>
<span class="linenos"> 413</span><span class="sd">       plt.stem(x, linefmt=&quot;C0-&quot;, markerfmt=&quot;C0o&quot;)</span>
<span class="linenos"> 414</span><span class="sd">       mask_ids = np.where(downsample.downsampling_mask)[0]</span>
<span class="linenos"> 415</span><span class="sd">       markerline, stemlines, baseline = plt.stem(mask_ids, y, linefmt=&quot;C3-&quot;, markerfmt=&quot;C3o&quot;)</span>
<span class="linenos"> 416</span><span class="sd">       markerline.set_markerfacecolor(&quot;none&quot;)</span>
<span class="linenos"> 417</span><span class="sd">       plt.stem(x_recons, linefmt=&quot;C1--&quot;, markerfmt=&quot;C1s&quot;)</span>
<span class="linenos"> 418</span><span class="sd">       plt.legend([&quot;Ground truth&quot;, &quot;Observation&quot;, &quot;CV Estimate&quot;])</span>
<span class="linenos"> 419</span><span class="sd">       plt.show()</span>
<span class="linenos"> 420</span>
<span class="linenos"> 421</span><span class="sd">    See Also</span>
<span class="linenos"> 422</span><span class="sd">    --------</span>
<span class="linenos"> 423</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.CV`,</span>
<span class="linenos"> 424</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos"> 425</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos"> 426</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos"> 427</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 428</span>
<span class="linenos"> 429</span>    <span class="k">def</span> <span class="nf">m_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 430</span>        <span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span>
<span class="linenos"> 431</span>        <span class="n">x_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">prox</span><span class="p">(</span>
<span class="linenos"> 432</span>            <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]),</span>
<span class="linenos"> 433</span>            <span class="n">tau</span><span class="o">=</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span>
<span class="linenos"> 434</span>        <span class="p">)</span>
<span class="linenos"> 435</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 436</span>            <span class="n">u</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_temp</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
<span class="linenos"> 437</span>            <span class="n">z_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">fenchel_prox</span><span class="p">(</span>
<span class="linenos"> 438</span>                <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="n">u</span><span class="p">),</span>
<span class="linenos"> 439</span>                <span class="n">sigma</span><span class="o">=</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">],</span>
<span class="linenos"> 440</span>            <span class="p">)</span>
<span class="linenos"> 441</span>            <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">z_temp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span>
<span class="linenos"> 442</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_temp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
<span class="linenos"> 443</span>
<span class="linenos"> 444</span>    <span class="k">def</span> <span class="nf">_set_step_sizes</span><span class="p">(</span>
<span class="linenos"> 445</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 446</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 447</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 448</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 449</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos"> 450</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 451</span><span class="sd">        Set the primal/dual step sizes.</span>
<span class="linenos"> 452</span>
<span class="linenos"> 453</span><span class="sd">        Returns</span>
<span class="linenos"> 454</span><span class="sd">        -------</span>
<span class="linenos"> 455</span><span class="sd">        Sensible primal/dual step sizes and value of the parameter :math:`delta`.</span>
<span class="linenos"> 456</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 457</span>        <span class="c1"># todo: this method in general is quite dirty.</span>
<span class="linenos"> 458</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">pxa</span><span class="o">.</span><span class="n">LinOp</span><span class="p">):</span>
<span class="linenos"> 459</span>            <span class="c1"># todo: wrong! Must raise only if tau/sigma = None</span>
<span class="linenos"> 460</span>            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
<span class="linenos"> 461</span>                <span class="sa">f</span><span class="s2">&quot;Automatic selection of parameters is only supported in the case in which K is a linear operator. &quot;</span>
<span class="linenos"> 462</span>                <span class="sa">f</span><span class="s2">&quot;Got operator of type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos"> 463</span>            <span class="p">)</span>
<span class="linenos"> 464</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 465</span>        <span class="n">tau</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">tau</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tau</span>
<span class="linenos"> 466</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">sigma</span>
<span class="linenos"> 467</span>
<span class="linenos"> 468</span>        <span class="k">if</span> <span class="p">(</span><span class="n">tau</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 469</span>            <span class="k">assert</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Parameter tau must be positive, got </span><span class="si">{</span><span class="n">tau</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos"> 470</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 471</span>                <span class="k">assert</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Parameter tau must be smaller than 1/gamma: </span><span class="si">{</span><span class="n">tau</span><span class="si">}</span><span class="s2"> &gt; </span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">gamma</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos"> 472</span>                <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 473</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 474</span>                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 475</span>                    <span class="n">sigma</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">-</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="linenos"> 476</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 477</span>                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 478</span>                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 479</span>        <span class="k">elif</span> <span class="p">(</span><span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 480</span>            <span class="k">assert</span> <span class="n">sigma</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="linenos"> 481</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 482</span>                <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>
<span class="linenos"> 483</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 484</span>                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 485</span>                    <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">+</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="linenos"> 486</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 487</span>                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 488</span>                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 489</span>        <span class="k">elif</span> <span class="p">(</span><span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 490</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos"> 491</span>                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 492</span>                    <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>
<span class="linenos"> 493</span>                    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 494</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 495</span>                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 496</span>                        <span class="n">tau</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
<span class="linenos"> 497</span>                            <span class="p">(</span><span class="o">-</span><span class="n">gamma</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">gamma</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="linenos"> 498</span>                        <span class="p">)</span>
<span class="linenos"> 499</span>                    <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 500</span>                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 501</span>                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 502</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 503</span>                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 504</span>                    <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos"> 505</span>                    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 506</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 507</span>                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 508</span>                        <span class="n">tau</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span>
<span class="linenos"> 509</span>                    <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 510</span>                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 511</span>                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 512</span>        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span>
<span class="linenos"> 513</span>            <span class="mi">2</span>
<span class="linenos"> 514</span>            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">pxa</span><span class="o">.</span><span class="n">QuadraticFunc</span><span class="p">)</span> <span class="ow">and</span> <span class="n">gamma</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span><span class="p">))</span>
<span class="linenos"> 515</span>            <span class="k">else</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span>
<span class="linenos"> 516</span>        <span class="p">)</span>
<span class="linenos"> 517</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span></div>

<span class="linenos"> 518</span>
<span class="linenos"> 519</span>
<span class="linenos"> 520</span><span class="n">CV</span> <span class="o">=</span> <span class="n">CondatVu</span>  <span class="c1">#: Alias of :py:class:`~pyxu.opt.solver.pds.CondatVu`.</span>
<span class="linenos"> 521</span>
<span class="linenos"> 522</span>
<div class="viewcode-block" id="PD3O">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.PD3O">[docs]</a>
<span class="linenos"> 523</span><span class="k">class</span> <span class="nc">PD3O</span><span class="p">(</span><span class="n">_PrimalDualSplitting</span><span class="p">):</span>
<span class="linenos"> 524</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 525</span><span class="sd">    Primal-Dual Three-Operator Splitting (PD3O) algorithm.</span>
<span class="linenos"> 526</span>
<span class="linenos"> 527</span><span class="sd">    The *Primal-Dual three Operator splitting (PD3O)* method is described in [PD3O]_.</span>
<span class="linenos"> 528</span>
<span class="linenos"> 529</span><span class="sd">    It can be used to solve problems of the form:</span>
<span class="linenos"> 530</span>
<span class="linenos"> 531</span><span class="sd">    .. math::</span>
<span class="linenos"> 532</span>
<span class="linenos"> 533</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \;\Psi(\mathbf{x}):=\mathcal{F}(\mathbf{x})\;\;+\;\;\mathcal{G}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathcal{K} \mathbf{x}),}</span>
<span class="linenos"> 534</span>
<span class="linenos"> 535</span><span class="sd">    where:</span>
<span class="linenos"> 536</span>
<span class="linenos"> 537</span><span class="sd">    * :math:`\mathcal{F}:\mathbb{R}^N\rightarrow \mathbb{R}` is *convex* and *differentiable*, with :math:`\beta`-*Lipschitz continuous* gradient,</span>
<span class="linenos"> 538</span><span class="sd">      for some :math:`\beta\in[0,+\infty[`.</span>
<span class="linenos"> 539</span>
<span class="linenos"> 540</span><span class="sd">    * :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` and :math:`\mathcal{H}:\mathbb{R}^M\rightarrow \mathbb{R}\cup\{+\infty\}` are *proper*, *lower semicontinuous* and *convex functions* with *simple proximal operators*.</span>
<span class="linenos"> 541</span>
<span class="linenos"> 542</span><span class="sd">    * :math:`\mathcal{K}:\mathbb{R}^N\rightarrow \mathbb{R}^M` is a *differentiable map* (e.g. a *linear operator* :math:`\mathbf{K}`), with **operator norm**:</span>
<span class="linenos"> 543</span>
<span class="linenos"> 544</span><span class="sd">      .. math::</span>
<span class="linenos"> 545</span>
<span class="linenos"> 546</span><span class="sd">         \Vert{\mathcal{K}}\Vert_2=\sup_{\mathbf{x}\in\mathbb{R}^N,\Vert\mathbf{x}\Vert_2=1} \Vert\mathcal{K}(\mathbf{x})\Vert_2.</span>
<span class="linenos"> 547</span>
<span class="linenos"> 548</span><span class="sd">    Remarks</span>
<span class="linenos"> 549</span><span class="sd">    -------</span>
<span class="linenos"> 550</span><span class="sd">    * The problem is *feasible* -- i.e. there exists at least one solution.</span>
<span class="linenos"> 551</span>
<span class="linenos"> 552</span><span class="sd">    * The algorithm is still valid if one or more of the terms :math:`\mathcal{F}`, :math:`\mathcal{G}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos"> 553</span>
<span class="linenos"> 554</span><span class="sd">    * The algorithm has convergence guarantees for the case in which :math:`\mathcal{H}` is composed with a *linear operator* :math:`\mathbf{K}`.</span>
<span class="linenos"> 555</span><span class="sd">      When :math:`\mathcal{F}=0`, convergence can be proven for *non-linear differentiable maps* :math:`\mathcal{K}`. (See [NLCP]_.)</span>
<span class="linenos"> 556</span><span class="sd">      Note that this class does not yet support automatic selection of hyperparameters for the case of *non-linear differentiable maps* :math:`\mathcal{K}`.</span>
<span class="linenos"> 557</span>
<span class="linenos"> 558</span><span class="sd">    * Assume that the following holds:</span>
<span class="linenos"> 559</span>
<span class="linenos"> 560</span><span class="sd">      * :math:`\gamma\geq\frac{\beta}{2}`,</span>
<span class="linenos"> 561</span><span class="sd">      * :math:`\tau \in ]0, \frac{1}{\gamma}[`,</span>
<span class="linenos"> 562</span><span class="sd">      * :math:`\tau\sigma\Vert\mathbf{K}\Vert_{2}^2 \leq 1`,</span>
<span class="linenos"> 563</span><span class="sd">      * :math:`\delta = 2-\beta\tau/2 \in [1, 2[` and :math:`\rho \in (0, \delta]`.</span>
<span class="linenos"> 564</span>
<span class="linenos"> 565</span><span class="sd">      Then there exists a pair :math:`(\mathbf{x}^\star,\mathbf{z}^\star)\in\mathbb{R}^N\times \mathbb{R}^M` solution</span>
<span class="linenos"> 566</span><span class="sd">      s.t. the primal and dual sequences of  estimates :math:`(\mathbf{x}_n)_{n\in\mathbb{N}}` and :math:`(\mathbf{z}_n)_{n\in\mathbb{N}}`</span>
<span class="linenos"> 567</span><span class="sd">      *converge* towards :math:`\mathbf{x}^\star` and :math:`\mathbf{z}^\star` respectively (Theorem 8.2 of [PSA]_), i.e.</span>
<span class="linenos"> 568</span>
<span class="linenos"> 569</span><span class="sd">      .. math::</span>
<span class="linenos"> 570</span>
<span class="linenos"> 571</span><span class="sd">         \lim_{n\rightarrow +\infty}\Vert\mathbf{x}^\star-\mathbf{x}_n\Vert_2=0, \quad \text{and} \quad  \lim_{n\rightarrow +\infty}\Vert\mathbf{z}^\star-\mathbf{z}_n\Vert_2=0.</span>
<span class="linenos"> 572</span>
<span class="linenos"> 573</span><span class="sd">      Futhermore, when :math:`\rho=1`, the objective functional sequence :math:`\left(\Psi(\mathbf{x}_n)\right)_{n\in\mathbb{N}}` can be shown to converge towards</span>
<span class="linenos"> 574</span><span class="sd">      its minimum :math:`\Psi^\ast` with rate :math:`o(1/\sqrt{n})` (Theorem 1 of [dPSA]_):</span>
<span class="linenos"> 575</span>
<span class="linenos"> 576</span><span class="sd">      .. math::</span>
<span class="linenos"> 577</span>
<span class="linenos"> 578</span><span class="sd">         \Psi(\mathbf{x}_n) - \Psi^\ast = o(1/\sqrt{n}).</span>
<span class="linenos"> 579</span>
<span class="linenos"> 580</span><span class="sd">    Parameters (``__init__()``)</span>
<span class="linenos"> 581</span><span class="sd">    ---------------------------</span>
<span class="linenos"> 582</span><span class="sd">    * **f** (:py:class:`~pyxu.abc.operator.DiffFunc`, :py:obj:`None`)</span>
<span class="linenos"> 583</span><span class="sd">      --</span>
<span class="linenos"> 584</span><span class="sd">      Differentiable function :math:`\mathcal{F}`.</span>
<span class="linenos"> 585</span><span class="sd">    * **g** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos"> 586</span><span class="sd">      --</span>
<span class="linenos"> 587</span><span class="sd">      Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos"> 588</span><span class="sd">    * **h** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos"> 589</span><span class="sd">      --</span>
<span class="linenos"> 590</span><span class="sd">      Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos"> 591</span><span class="sd">    * **K** (:py:class:`~pyxu.abc.operator.DiffMap`, :py:class:`~pyxu.abc.operator.LinOp`, :py:obj:`None`)</span>
<span class="linenos"> 592</span><span class="sd">      --</span>
<span class="linenos"> 593</span><span class="sd">      Differentiable map or linear operator :math:`\mathcal{K}`.</span>
<span class="linenos"> 594</span><span class="sd">    * **beta** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 595</span><span class="sd">      --</span>
<span class="linenos"> 596</span><span class="sd">      Lipschitz constant :math:`\beta` of :math:`\nabla\mathcal{F}`.</span>
<span class="linenos"> 597</span><span class="sd">      If not provided, it will be automatically estimated.</span>
<span class="linenos"> 598</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos"> 599</span><span class="sd">      --</span>
<span class="linenos"> 600</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos"> 601</span>
<span class="linenos"> 602</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos"> 603</span><span class="sd">    ----------------------</span>
<span class="linenos"> 604</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos"> 605</span><span class="sd">      --</span>
<span class="linenos"> 606</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos"> 607</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos"> 608</span><span class="sd">      --</span>
<span class="linenos"> 609</span><span class="sd">      (..., M) initial point(s) for the dual variable.</span>
<span class="linenos"> 610</span><span class="sd">      If ``None`` (default), then use ``K(x0)`` as the initial point for the dual variable.</span>
<span class="linenos"> 611</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 612</span><span class="sd">      --</span>
<span class="linenos"> 613</span><span class="sd">      Primal step size.</span>
<span class="linenos"> 614</span><span class="sd">    * **sigma** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 615</span><span class="sd">      --</span>
<span class="linenos"> 616</span><span class="sd">      Dual step size.</span>
<span class="linenos"> 617</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 618</span><span class="sd">      --</span>
<span class="linenos"> 619</span><span class="sd">      Momentum parameter.</span>
<span class="linenos"> 620</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos"> 621</span><span class="sd">      --</span>
<span class="linenos"> 622</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos"> 623</span><span class="sd">      See section below for more details.</span>
<span class="linenos"> 624</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos"> 625</span><span class="sd">      --</span>
<span class="linenos"> 626</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos"> 627</span>
<span class="linenos"> 628</span><span class="sd">    .. rubric:: Default hyperparameter values</span>
<span class="linenos"> 629</span>
<span class="linenos"> 630</span><span class="sd">    This class supports three strategies to automatically set the hyperparameters (see [PSA]_ for more details and numerical experiments</span>
<span class="linenos"> 631</span><span class="sd">    comparing the performance of the three strategies):</span>
<span class="linenos"> 632</span>
<span class="linenos"> 633</span><span class="sd">    - ``tuning_strategy == 1``: :math:`\gamma = \beta` (safe step sizes) and :math:`\rho=1` (no relaxation).</span>
<span class="linenos"> 634</span>
<span class="linenos"> 635</span><span class="sd">      This is the most standard way of setting the parameters in the literature.</span>
<span class="linenos"> 636</span><span class="sd">    - ``tuning_strategy == 2``: :math:`\gamma = \beta/1.9` (large step sizes) and :math:`\rho=1` (no relaxation).</span>
<span class="linenos"> 637</span>
<span class="linenos"> 638</span><span class="sd">      This strategy favours large step sizes forbidding the use of overrelaxation.</span>
<span class="linenos"> 639</span><span class="sd">      When :math:`\beta=0`, coincides with the first strategy.</span>
<span class="linenos"> 640</span><span class="sd">    - ``tuning_strategy == 3``: :math:`\gamma = \beta` (safe step sizes) and :math:`\rho=\delta - 0.1 &gt; 1` (overrelaxation).</span>
<span class="linenos"> 641</span>
<span class="linenos"> 642</span><span class="sd">      This strategy chooses smaller step sizes, but performs overrelaxation.</span>
<span class="linenos"> 643</span>
<span class="linenos"> 644</span><span class="sd">    Once :math:`\gamma` chosen, the convergence speed  of the algorithm is improved by choosing :math:`\sigma` and :math:`\tau` as</span>
<span class="linenos"> 645</span><span class="sd">    large as possible and relatively well-balanced -- so that both the primal and dual variables converge at the same pace.</span>
<span class="linenos"> 646</span><span class="sd">    Whenever possible, we therefore choose perfectly balanced parameters :math:`\sigma=\tau` saturating the convergence inequalities for a given value of :math:`\gamma`.</span>
<span class="linenos"> 647</span>
<span class="linenos"> 648</span><span class="sd">    In practice, the following linear programming optimization problem is solved:</span>
<span class="linenos"> 649</span>
<span class="linenos"> 650</span><span class="sd">    .. math::</span>
<span class="linenos"> 651</span>
<span class="linenos"> 652</span><span class="sd">       (\tau, \, \sigma) = \operatorname{arg} \max_{(\tau^{*}, \,  \sigma^{*})} \quad &amp; \operatorname{log}(\tau^{*}) + \operatorname{log}(\sigma^{*})\\</span>
<span class="linenos"> 653</span><span class="sd">       \text{s.t.} \quad &amp; \operatorname{log}(\tau^{*}) + \operatorname{log}(\sigma^{*}) \leq 2\operatorname{log}(\Vert\mathbf{K}\Vert_{2})\\</span>
<span class="linenos"> 654</span><span class="sd">       &amp; \operatorname{log}(\tau^{*}) \leq -\operatorname{log}(\gamma)\\</span>
<span class="linenos"> 655</span><span class="sd">       &amp; \operatorname{log}(\tau^{*}) = \operatorname{log}(\sigma^{*}).</span>
<span class="linenos"> 656</span>
<span class="linenos"> 657</span><span class="sd">    When :math:`\tau \leq 1/\gamma` is given (i.e., :math:`\tau=\tau_{1}`), but not :math:`\sigma`, the latter is chosen as:</span>
<span class="linenos"> 658</span>
<span class="linenos"> 659</span><span class="sd">    .. math::</span>
<span class="linenos"> 660</span>
<span class="linenos"> 661</span><span class="sd">       \tau_{1}\sigma\Vert\mathbf{K}\Vert_{2}^2= 1 \quad\Longleftrightarrow\quad \sigma=\frac{1}{\tau_{1}\Vert\mathbf{K}\Vert_{2}^{2}}.</span>
<span class="linenos"> 662</span>
<span class="linenos"> 663</span><span class="sd">    When :math:`\sigma` is given (i.e., :math:`\sigma=\sigma_{1}`), but not :math:`\tau`, the latter is chosen as:</span>
<span class="linenos"> 664</span>
<span class="linenos"> 665</span><span class="sd">    .. math::</span>
<span class="linenos"> 666</span>
<span class="linenos"> 667</span><span class="sd">       \tau = \min \left\{\frac{1}{\gamma}, \frac{1}{\sigma_{1}\Vert\mathbf{K}\Vert_{2}^{2}}\right\}.</span>
<span class="linenos"> 668</span>
<span class="linenos"> 669</span><span class="sd">    Warning</span>
<span class="linenos"> 670</span><span class="sd">    -------</span>
<span class="linenos"> 671</span><span class="sd">    When values are provided for both :math:`\tau` and :math:`\sigma`, it is assumed that the latter satisfy the</span>
<span class="linenos"> 672</span><span class="sd">    convergence inequalities, but no check is explicitly performed.</span>
<span class="linenos"> 673</span><span class="sd">    Automatic selection of hyperparameters for the case of non-linear differentiable maps :math:`\mathcal{K}` is not supported yet.</span>
<span class="linenos"> 674</span>
<span class="linenos"> 675</span><span class="sd">    Example</span>
<span class="linenos"> 676</span><span class="sd">    -------</span>
<span class="linenos"> 677</span><span class="sd">    Consider the following optimisation problem:</span>
<span class="linenos"> 678</span>
<span class="linenos"> 679</span><span class="sd">    .. math::</span>
<span class="linenos"> 680</span>
<span class="linenos"> 681</span><span class="sd">       \min_{\mathbf{x}\in\mathbb{R}_+^N}\frac{1}{2}\left\|\mathbf{y}-\mathbf{G}\mathbf{x}\right\|_2^2\quad+\quad\lambda_1 \|\mathbf{D}\mathbf{x}\|_1\quad+\quad\lambda_2 \|\mathbf{x}\|_1,</span>
<span class="linenos"> 682</span>
<span class="linenos"> 683</span><span class="sd">    with :math:`\mathbf{D}\in\mathbb{R}^{N\times N}` the discrete derivative operator and :math:`\mathbf{G}\in\mathbb{R}^{L\times N}, \, \mathbf{y}\in\mathbb{R}^L, \lambda_1,\lambda_2&gt;0.`</span>
<span class="linenos"> 684</span><span class="sd">    This problem can be solved via PD3O with :math:`\mathcal{F}(\mathbf{x})= \frac{1}{2}\left\|\mathbf{y}-\mathbf{G}\mathbf{x}\right\|_2^2`, :math:`\mathcal{G}(\mathbf{x})=\lambda_2\|\mathbf{x}\|_1,`</span>
<span class="linenos"> 685</span><span class="sd">    :math:`\mathcal{H}(\mathbf{x})=\lambda \|\mathbf{x}\|_1` and :math:`\mathbf{K}=\mathbf{D}`.</span>
<span class="linenos"> 686</span>
<span class="linenos"> 687</span><span class="sd">    .. plot::</span>
<span class="linenos"> 688</span>
<span class="linenos"> 689</span><span class="sd">       import matplotlib.pyplot as plt</span>
<span class="linenos"> 690</span><span class="sd">       import numpy as np</span>
<span class="linenos"> 691</span><span class="sd">       import pyxu.operator as pxo</span>
<span class="linenos"> 692</span><span class="sd">       from pyxu.experimental._dev import DownSampling, FirstDerivative</span>
<span class="linenos"> 693</span><span class="sd">       from pyxu.opt.solver import PD3O</span>
<span class="linenos"> 694</span>
<span class="linenos"> 695</span><span class="sd">       x = np.repeat(np.asarray([0, 2, 1, 3, 0, 2, 0]), 10)</span>
<span class="linenos"> 696</span><span class="sd">       N = x.size</span>
<span class="linenos"> 697</span>
<span class="linenos"> 698</span><span class="sd">       D = FirstDerivative(size=N, kind=&quot;forward&quot;)</span>
<span class="linenos"> 699</span><span class="sd">       D.lipschitz = D.estimate_lipschitz()</span>
<span class="linenos"> 700</span>
<span class="linenos"> 701</span><span class="sd">       downsample = DownSampling(size=N, downsampling_factor=3)</span>
<span class="linenos"> 702</span><span class="sd">       y = downsample(x)</span>
<span class="linenos"> 703</span><span class="sd">       loss = (1 / 2) * pxo.SquaredL2Norm(y.size).argshift(-y)</span>
<span class="linenos"> 704</span><span class="sd">       F = loss * downsample</span>
<span class="linenos"> 705</span><span class="sd">       F.diff_lipschitz = F.estimate_diff_lipschitz()</span>
<span class="linenos"> 706</span>
<span class="linenos"> 707</span><span class="sd">       pd3o = PD3O(f=F, g=0.01 * pxo.L1Norm(N), h=0.1 * pxo.L1Norm(N), K=D)</span>
<span class="linenos"> 708</span><span class="sd">       x0, z0 = np.zeros((2, N))</span>
<span class="linenos"> 709</span><span class="sd">       pd3o.fit(x0=x0, z0=z0)</span>
<span class="linenos"> 710</span><span class="sd">       x_recons = pd3o.solution()[0]</span>
<span class="linenos"> 711</span>
<span class="linenos"> 712</span><span class="sd">       plt.figure()</span>
<span class="linenos"> 713</span><span class="sd">       plt.stem(x, linefmt=&quot;C0-&quot;, markerfmt=&quot;C0o&quot;)</span>
<span class="linenos"> 714</span><span class="sd">       mask_ids = np.where(downsample.downsampling_mask)[0]</span>
<span class="linenos"> 715</span><span class="sd">       markerline, stemlines, baseline = plt.stem(mask_ids, y, linefmt=&quot;C3-&quot;, markerfmt=&quot;C3o&quot;)</span>
<span class="linenos"> 716</span><span class="sd">       markerline.set_markerfacecolor(&quot;none&quot;)</span>
<span class="linenos"> 717</span><span class="sd">       plt.stem(x_recons, linefmt=&quot;C1--&quot;, markerfmt=&quot;C1s&quot;)</span>
<span class="linenos"> 718</span><span class="sd">       plt.legend([&quot;Ground truth&quot;, &quot;Observation&quot;, &quot;PD3O Estimate&quot;])</span>
<span class="linenos"> 719</span><span class="sd">       plt.show()</span>
<span class="linenos"> 720</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 721</span>
<span class="linenos"> 722</span>    <span class="nd">@pxrt</span><span class="o">.</span><span class="n">enforce_precision</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="s2">&quot;z0&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="s2">&quot;rho&quot;</span><span class="p">),</span> <span class="n">allow_None</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 723</span>    <span class="k">def</span> <span class="nf">m_init</span><span class="p">(</span>
<span class="linenos"> 724</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 725</span>        <span class="n">x0</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
<span class="linenos"> 726</span>        <span class="n">z0</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 727</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 728</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 729</span>        <span class="n">rho</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 730</span>        <span class="n">tuning_strategy</span><span class="p">:</span> <span class="n">_PDS</span><span class="o">.</span><span class="n">TuningSpec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="linenos"> 731</span>    <span class="p">):</span>
<span class="linenos"> 732</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">m_init</span><span class="p">(</span>
<span class="linenos"> 733</span>            <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
<span class="linenos"> 734</span>            <span class="n">z0</span><span class="o">=</span><span class="n">z0</span><span class="p">,</span>
<span class="linenos"> 735</span>            <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
<span class="linenos"> 736</span>            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
<span class="linenos"> 737</span>            <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span>
<span class="linenos"> 738</span>            <span class="n">tuning_strategy</span><span class="o">=</span><span class="n">tuning_strategy</span><span class="p">,</span>
<span class="linenos"> 739</span>        <span class="p">)</span>
<span class="linenos"> 740</span>
<span class="linenos"> 741</span>        <span class="c1"># if x0 == u0 the first step wouldn&#39;t change x and the solver would stop at the first iteration</span>
<span class="linenos"> 742</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 743</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">*</span> <span class="mf">1.01</span>
<span class="linenos"> 744</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 745</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="linenos"> 746</span>
<span class="linenos"> 747</span>    <span class="k">def</span> <span class="nf">m_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 748</span>        <span class="c1"># Slightly more efficient rewriting of iterations (216) of [PSA] with M=1. Faster than (185) since only one call to the adjoint and the gradient per iteration.</span>
<span class="linenos"> 749</span>        <span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span>
<span class="linenos"> 750</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">prox</span><span class="p">(</span>
<span class="linenos"> 751</span>            <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]),</span>
<span class="linenos"> 752</span>            <span class="n">tau</span><span class="o">=</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span>
<span class="linenos"> 753</span>        <span class="p">)</span>
<span class="linenos"> 754</span>        <span class="n">u_temp</span> <span class="o">=</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
<span class="linenos"> 755</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 756</span>            <span class="n">z_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">fenchel_prox</span><span class="p">(</span>
<span class="linenos"> 757</span>                <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_temp</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]),</span>
<span class="linenos"> 758</span>                <span class="n">sigma</span><span class="o">=</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">],</span>
<span class="linenos"> 759</span>            <span class="p">)</span>
<span class="linenos"> 760</span>            <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">z_temp</span>
<span class="linenos"> 761</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">u_temp</span>
<span class="linenos"> 762</span>
<span class="linenos"> 763</span>    <span class="k">def</span> <span class="nf">_set_step_sizes</span><span class="p">(</span>
<span class="linenos"> 764</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 765</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 766</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos"> 767</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span>
<span class="linenos"> 768</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos"> 769</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 770</span><span class="sd">        Set the primal/dual step sizes.</span>
<span class="linenos"> 771</span>
<span class="linenos"> 772</span><span class="sd">        Returns</span>
<span class="linenos"> 773</span><span class="sd">        -------</span>
<span class="linenos"> 774</span><span class="sd">        Tuple[Real, Real, Real]</span>
<span class="linenos"> 775</span><span class="sd">            Sensible primal/dual step sizes and value of :math:`\delta`.</span>
<span class="linenos"> 776</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 777</span>
<span class="linenos"> 778</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">pxa</span><span class="o">.</span><span class="n">LinOp</span><span class="p">):</span>
<span class="linenos"> 779</span>            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
<span class="linenos"> 780</span>                <span class="sa">f</span><span class="s2">&quot;Automatic selection of parameters is only supported in the case in which K is a linear operator. &quot;</span>
<span class="linenos"> 781</span>                <span class="sa">f</span><span class="s2">&quot;Got operator of type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos"> 782</span>            <span class="p">)</span>
<span class="linenos"> 783</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 784</span>        <span class="n">tau</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">tau</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tau</span>
<span class="linenos"> 785</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">sigma</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">sigma</span>
<span class="linenos"> 786</span>
<span class="linenos"> 787</span>        <span class="k">if</span> <span class="p">(</span><span class="n">tau</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 788</span>            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">,</span> <span class="s2">&quot;tau must be positive and smaller than 1/gamma.&quot;</span>
<span class="linenos"> 789</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 790</span>                <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 791</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 792</span>                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 793</span>                    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">tau</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="linenos"> 794</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 795</span>                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 796</span>                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 797</span>        <span class="k">elif</span> <span class="p">(</span><span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 798</span>            <span class="k">assert</span> <span class="n">sigma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sigma must be positive, got </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos"> 799</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 800</span>                <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>
<span class="linenos"> 801</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 802</span>                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 803</span>                    <span class="n">tau</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span>
<span class="linenos"> 804</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 805</span>                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 806</span>                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 807</span>        <span class="k">elif</span> <span class="p">(</span><span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos"> 808</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="linenos"> 809</span>                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 810</span>                    <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>
<span class="linenos"> 811</span>                    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 812</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 813</span>                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 814</span>                        <span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_step_sizes</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
<span class="linenos"> 815</span>                    <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 816</span>                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 817</span>                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 818</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 819</span>                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos"> 820</span>                    <span class="n">tau</span> <span class="o">=</span> <span class="mi">1</span>
<span class="linenos"> 821</span>                    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
<span class="linenos"> 822</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 823</span>                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">):</span>
<span class="linenos"> 824</span>                        <span class="n">tau</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span>
<span class="linenos"> 825</span>                    <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 826</span>                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Please compute the Lipschitz constant of the linear operator K by calling its method &#39;estimate_lipschitz()&#39;&quot;</span>
<span class="linenos"> 827</span>                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos"> 828</span>        <span class="n">delta</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">*</span> <span class="n">tau</span> <span class="o">/</span> <span class="mi">2</span>
<span class="linenos"> 829</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="linenos"> 830</span>
<span class="linenos"> 831</span>    <span class="nd">@pxrt</span><span class="o">.</span><span class="n">enforce_precision</span><span class="p">()</span>
<span class="linenos"> 832</span>    <span class="k">def</span> <span class="nf">_optimize_step_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">:</span>
<span class="linenos"> 833</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 834</span><span class="sd">        Optimize the primal/dual step sizes.</span>
<span class="linenos"> 835</span>
<span class="linenos"> 836</span><span class="sd">        Parameters</span>
<span class="linenos"> 837</span><span class="sd">        ----------</span>
<span class="linenos"> 838</span><span class="sd">        gamma: Real</span>
<span class="linenos"> 839</span><span class="sd">            Gamma parameter.</span>
<span class="linenos"> 840</span>
<span class="linenos"> 841</span><span class="sd">        Returns</span>
<span class="linenos"> 842</span><span class="sd">        -------</span>
<span class="linenos"> 843</span><span class="sd">        Tuple[Real, Real]</span>
<span class="linenos"> 844</span><span class="sd">            Sensible primal/dual step sizes.</span>
<span class="linenos"> 845</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 846</span>        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="linenos"> 847</span>        <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linprog</span>
<span class="linenos"> 848</span>
<span class="linenos"> 849</span>        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="linenos"> 850</span>        <span class="n">A_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="linenos"> 851</span>        <span class="n">b_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.99</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">lipschitz</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)])</span>
<span class="linenos"> 852</span>        <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="linenos"> 853</span>        <span class="n">b_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="linenos"> 854</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span>
<span class="linenos"> 855</span>            <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
<span class="linenos"> 856</span>            <span class="n">A_ub</span><span class="o">=</span><span class="n">A_ub</span><span class="p">,</span>
<span class="linenos"> 857</span>            <span class="n">b_ub</span><span class="o">=</span><span class="n">b_ub</span><span class="p">,</span>
<span class="linenos"> 858</span>            <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span>
<span class="linenos"> 859</span>            <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
<span class="linenos"> 860</span>            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
<span class="linenos"> 861</span>        <span class="p">)</span>
<span class="linenos"> 862</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
<span class="linenos"> 863</span>            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Automatic parameter selection has not converged.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
<span class="linenos"> 864</span>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span></div>

<span class="linenos"> 865</span>
<span class="linenos"> 866</span>
<div class="viewcode-block" id="ChambollePock">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.ChambollePock">[docs]</a>
<span class="linenos"> 867</span><span class="k">def</span> <span class="nf">ChambollePock</span><span class="p">(</span>
<span class="linenos"> 868</span>    <span class="n">g</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 869</span>    <span class="n">h</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 870</span>    <span class="n">K</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffMap</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 871</span>    <span class="n">base</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">_PrimalDualSplitting</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondatVu</span><span class="p">,</span>
<span class="linenos"> 872</span>    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos"> 873</span><span class="p">):</span>
<span class="linenos"> 874</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 875</span><span class="sd">    Chambolle-Pock primal-dual splitting method.</span>
<span class="linenos"> 876</span>
<span class="linenos"> 877</span><span class="sd">    Parameters</span>
<span class="linenos"> 878</span><span class="sd">    ----------</span>
<span class="linenos"> 879</span><span class="sd">    g: :py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`</span>
<span class="linenos"> 880</span><span class="sd">        Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos"> 881</span><span class="sd">    h: :py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`</span>
<span class="linenos"> 882</span><span class="sd">        Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos"> 883</span><span class="sd">    K: :py:class:`~pyxu.abc.operator.DiffMap`, :py:class:`~pyxu.abc.operator.LinOp`, :py:obj:`None`</span>
<span class="linenos"> 884</span><span class="sd">        Differentiable map or linear operator :math:`\mathcal{K}`.</span>
<span class="linenos"> 885</span><span class="sd">    base: :py:class:`~pyxu.opt.solver.pds.CondatVu`, :py:class:`~pyxu.opt.solver.pds.PD3O`</span>
<span class="linenos"> 886</span><span class="sd">        Specifies the base primal-dual algorithm.</span>
<span class="linenos"> 887</span><span class="sd">        (Default = :py:class:`~pyxu.opt.solver.pds.CondatVu`)</span>
<span class="linenos"> 888</span><span class="sd">    \*\*kwargs: :py:class:`~collections.abc.Mapping`</span>
<span class="linenos"> 889</span><span class="sd">        Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos"> 890</span>
<span class="linenos"> 891</span>
<span class="linenos"> 892</span><span class="sd">    The *Chambolle-Pock (CP) primal-dual splitting* method can be used to solve problems of the form:</span>
<span class="linenos"> 893</span>
<span class="linenos"> 894</span><span class="sd">    .. math::</span>
<span class="linenos"> 895</span>
<span class="linenos"> 896</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \mathcal{G}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathbf{K} \mathbf{x}),}</span>
<span class="linenos"> 897</span>
<span class="linenos"> 898</span><span class="sd">    where:</span>
<span class="linenos"> 899</span>
<span class="linenos"> 900</span><span class="sd">    * :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` and :math:`\mathcal{H}:\mathbb{R}^M\rightarrow \mathbb{R}\cup\{+\infty\}` are *proper*, *lower semicontinuous* and *convex functions* with *simple proximal operators*.</span>
<span class="linenos"> 901</span><span class="sd">    * :math:`\mathcal{K}:\mathbb{R}^N\rightarrow \mathbb{R}^M` is a *differentiable map* (e.g. a *linear operator* :math:`\mathbf{K}`), with **operator norm**:</span>
<span class="linenos"> 902</span>
<span class="linenos"> 903</span><span class="sd">      .. math::</span>
<span class="linenos"> 904</span>
<span class="linenos"> 905</span><span class="sd">         \Vert{\mathcal{K}}\Vert_2=\sup_{\mathbf{x}\in\mathbb{R}^N,\Vert\mathbf{x}\Vert_2=1} \Vert\mathcal{K}(\mathbf{x})\Vert_2.</span>
<span class="linenos"> 906</span>
<span class="linenos"> 907</span><span class="sd">    Remarks</span>
<span class="linenos"> 908</span><span class="sd">    -------</span>
<span class="linenos"> 909</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos"> 910</span>
<span class="linenos"> 911</span><span class="sd">    * The algorithm is still valid if one of the terms :math:`\mathcal{G}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos"> 912</span>
<span class="linenos"> 913</span><span class="sd">    * Automatic selection of parameters is not supported for *non-linear differentiable maps* :math:`\mathcal{K}`.</span>
<span class="linenos"> 914</span>
<span class="linenos"> 915</span><span class="sd">    * The *Chambolle-Pock (CP) primal-dual splitting* method can be obtained by choosing :math:`\mathcal{F}=0` in :py:class:`~pyxu.opt.solver.pds.CondatVu` or :py:class:`~pyxu.opt.solver.pds.PD3O`.</span>
<span class="linenos"> 916</span><span class="sd">      Chambolle and Pock originally introduced the algorithm without relaxation (:math:`\rho=1`) [CPA]_.</span>
<span class="linenos"> 917</span><span class="sd">      Relaxed versions have been proposed afterwards [PSA]_.</span>
<span class="linenos"> 918</span><span class="sd">      Chambolle-Pock&#39;s algorithm is also known as the *Primal-Dual Hybrid Gradient (PDHG)* algorithm.</span>
<span class="linenos"> 919</span><span class="sd">      It can be seen as a preconditionned ADMM method [CPA]_.</span>
<span class="linenos"> 920</span>
<span class="linenos"> 921</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos"> 922</span><span class="sd">    ----------------------</span>
<span class="linenos"> 923</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos"> 924</span><span class="sd">      --</span>
<span class="linenos"> 925</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos"> 926</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos"> 927</span><span class="sd">      --</span>
<span class="linenos"> 928</span><span class="sd">      (..., M) initial point(s) for the dual variable.</span>
<span class="linenos"> 929</span><span class="sd">      If ``None`` (default), then use ``K(x0)`` as the initial point for the dual variable.</span>
<span class="linenos"> 930</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 931</span><span class="sd">      --</span>
<span class="linenos"> 932</span><span class="sd">      Primal step size.</span>
<span class="linenos"> 933</span><span class="sd">    * **sigma** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 934</span><span class="sd">      --</span>
<span class="linenos"> 935</span><span class="sd">      Dual step size.</span>
<span class="linenos"> 936</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos"> 937</span><span class="sd">      --</span>
<span class="linenos"> 938</span><span class="sd">      Momentum parameter.</span>
<span class="linenos"> 939</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos"> 940</span><span class="sd">      --</span>
<span class="linenos"> 941</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos"> 942</span><span class="sd">      See `base` for more details.</span>
<span class="linenos"> 943</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos"> 944</span><span class="sd">      --</span>
<span class="linenos"> 945</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos"> 946</span>
<span class="linenos"> 947</span><span class="sd">    See Also</span>
<span class="linenos"> 948</span><span class="sd">    --------</span>
<span class="linenos"> 949</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.CP`,</span>
<span class="linenos"> 950</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.CondatVu`,</span>
<span class="linenos"> 951</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos"> 952</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos"> 953</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 954</span>    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<span class="linenos"> 955</span>    <span class="n">obj</span> <span class="o">=</span> <span class="n">base</span><span class="p">(</span>
<span class="linenos"> 956</span>        <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 957</span>        <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
<span class="linenos"> 958</span>        <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
<span class="linenos"> 959</span>        <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
<span class="linenos"> 960</span>        <span class="n">beta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="linenos"> 961</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos"> 962</span>    <span class="p">)</span>
<span class="linenos"> 963</span>    <span class="n">obj</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="s2">&quot;ChambollePock&quot;</span>
<span class="linenos"> 964</span>    <span class="k">return</span> <span class="n">obj</span></div>

<span class="linenos"> 965</span>
<span class="linenos"> 966</span>
<span class="linenos"> 967</span><span class="n">CP</span> <span class="o">=</span> <span class="n">ChambollePock</span>  <span class="c1">#: Alias of :py:func:`~pyxu.opt.solver.pds.ChambollePock`.</span>
<span class="linenos"> 968</span>
<span class="linenos"> 969</span>
<div class="viewcode-block" id="LorisVerhoeven">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.LorisVerhoeven">[docs]</a>
<span class="linenos"> 970</span><span class="k">class</span> <span class="nc">LorisVerhoeven</span><span class="p">(</span><span class="n">PD3O</span><span class="p">):</span>
<span class="linenos"> 971</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 972</span><span class="sd">    Loris-Verhoeven splitting algorithm.</span>
<span class="linenos"> 973</span>
<span class="linenos"> 974</span><span class="sd">    This solver is also accessible via the alias :py:class:`~pyxu.opt.solver.pds.LV`.</span>
<span class="linenos"> 975</span>
<span class="linenos"> 976</span><span class="sd">    The *Loris-Verhoeven (LV) primal-dual splitting* can be used to solve problems of the form:</span>
<span class="linenos"> 977</span>
<span class="linenos"> 978</span><span class="sd">    .. math::</span>
<span class="linenos"> 979</span>
<span class="linenos"> 980</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \mathcal{F}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathbf{K} \mathbf{x}),}</span>
<span class="linenos"> 981</span>
<span class="linenos"> 982</span><span class="sd">    where:</span>
<span class="linenos"> 983</span>
<span class="linenos"> 984</span><span class="sd">    * :math:`\mathcal{F}:\mathbb{R}^N\rightarrow \mathbb{R}` is *convex* and *differentiable*, with :math:`\beta`-*Lipschitz continuous* gradient,</span>
<span class="linenos"> 985</span><span class="sd">      for some :math:`\beta\in[0,+\infty[`.</span>
<span class="linenos"> 986</span>
<span class="linenos"> 987</span><span class="sd">    * :math:`\mathcal{H}:\mathbb{R}^M\rightarrow \mathbb{R}\cup\{+\infty\}` is a *proper*, *lower semicontinuous* and *convex function* with *simple proximal operator*.</span>
<span class="linenos"> 988</span>
<span class="linenos"> 989</span><span class="sd">    * :math:`\mathcal{K}:\mathbb{R}^N\rightarrow \mathbb{R}^M` is a *differentiable map* (e.g. a *linear operator* :math:`\mathbf{K}`), with **operator norm**:</span>
<span class="linenos"> 990</span>
<span class="linenos"> 991</span><span class="sd">      .. math::</span>
<span class="linenos"> 992</span>
<span class="linenos"> 993</span><span class="sd">         \Vert{\mathcal{K}}\Vert_2=\sup_{\mathbf{x}\in\mathbb{R}^N,\Vert\mathbf{x}\Vert_2=1} \Vert\mathcal{K}(\mathbf{x})\Vert_2.</span>
<span class="linenos"> 994</span>
<span class="linenos"> 995</span><span class="sd">    Remarks</span>
<span class="linenos"> 996</span><span class="sd">    -------</span>
<span class="linenos"> 997</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos"> 998</span>
<span class="linenos"> 999</span><span class="sd">    * The algorithm is still valid if one of the terms :math:`\mathcal{F}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos">1000</span>
<span class="linenos">1001</span><span class="sd">    * Automatic selection of parameters is not supported for *non-linear differentiable maps* :math:`\mathcal{K}`.</span>
<span class="linenos">1002</span>
<span class="linenos">1003</span><span class="sd">    * The *Loris-Verhoeven (CP) primal-dual splitting* method can be obtained by choosing :math:`\mathcal{G}=0` in :py:class:`~pyxu.opt.solver.pds.PD3O`.</span>
<span class="linenos">1004</span>
<span class="linenos">1005</span><span class="sd">    * In the specific case where :math:`\mathcal{F}` is *quadratic*, then one can set :math:`\rho \in ]0,\delta[` with</span>
<span class="linenos">1006</span><span class="sd">      :math:`\delta=2`. (See Theorem 4.3 in [PSA]_.)</span>
<span class="linenos">1007</span>
<span class="linenos">1008</span><span class="sd">    Parameters (``__init__()``)</span>
<span class="linenos">1009</span><span class="sd">    ---------------------------</span>
<span class="linenos">1010</span><span class="sd">    * **f** (:py:class:`~pyxu.abc.operator.DiffFunc`, :py:obj:`None`)</span>
<span class="linenos">1011</span><span class="sd">      --</span>
<span class="linenos">1012</span><span class="sd">      Differentiable function :math:`\mathcal{F}`.</span>
<span class="linenos">1013</span><span class="sd">    * **h** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos">1014</span><span class="sd">      --</span>
<span class="linenos">1015</span><span class="sd">      Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos">1016</span><span class="sd">    * **K** (:py:class:`~pyxu.abc.operator.DiffMap`, :py:class:`~pyxu.abc.operator.LinOp`, :py:obj:`None`)</span>
<span class="linenos">1017</span><span class="sd">      --</span>
<span class="linenos">1018</span><span class="sd">      Differentiable map or linear operator :math:`\mathcal{K}`.</span>
<span class="linenos">1019</span><span class="sd">    * **beta** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1020</span><span class="sd">      --</span>
<span class="linenos">1021</span><span class="sd">      Lipschitz constant :math:`\beta` of :math:`\nabla\mathcal{F}`.</span>
<span class="linenos">1022</span><span class="sd">      If not provided, it will be automatically estimated.</span>
<span class="linenos">1023</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1024</span><span class="sd">      --</span>
<span class="linenos">1025</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos">1026</span>
<span class="linenos">1027</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos">1028</span><span class="sd">    ----------------------</span>
<span class="linenos">1029</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos">1030</span><span class="sd">      --</span>
<span class="linenos">1031</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos">1032</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos">1033</span><span class="sd">      --</span>
<span class="linenos">1034</span><span class="sd">      (..., M) initial point(s) for the dual variable.</span>
<span class="linenos">1035</span><span class="sd">      If ``None`` (default), then use ``K(x0)`` as the initial point for the dual variable.</span>
<span class="linenos">1036</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1037</span><span class="sd">      --</span>
<span class="linenos">1038</span><span class="sd">      Primal step size.</span>
<span class="linenos">1039</span><span class="sd">    * **sigma** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1040</span><span class="sd">      --</span>
<span class="linenos">1041</span><span class="sd">      Dual step size.</span>
<span class="linenos">1042</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1043</span><span class="sd">      --</span>
<span class="linenos">1044</span><span class="sd">      Momentum parameter.</span>
<span class="linenos">1045</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos">1046</span><span class="sd">      --</span>
<span class="linenos">1047</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos">1048</span><span class="sd">      See :py:class:`~pyxu.opt.solver.pds.PD3O` for more details.</span>
<span class="linenos">1049</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1050</span><span class="sd">      --</span>
<span class="linenos">1051</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos">1052</span>
<span class="linenos">1053</span><span class="sd">    See Also</span>
<span class="linenos">1054</span><span class="sd">    --------</span>
<span class="linenos">1055</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos">1056</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.DavisYin`,</span>
<span class="linenos">1057</span><span class="sd">    :py:class:`~pyxu.opt.solver.pgd.PGD`,</span>
<span class="linenos">1058</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos">1059</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos">1060</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1061</span>
<span class="linenos">1062</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1063</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1064</span>        <span class="n">f</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1065</span>        <span class="n">h</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1066</span>        <span class="n">K</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffMap</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1067</span>        <span class="n">beta</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1068</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1069</span>    <span class="p">):</span>
<span class="linenos">1070</span>        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<span class="linenos">1071</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1072</span>            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
<span class="linenos">1073</span>            <span class="n">g</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1074</span>            <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
<span class="linenos">1075</span>            <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
<span class="linenos">1076</span>            <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
<span class="linenos">1077</span>            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1078</span>        <span class="p">)</span>
<span class="linenos">1079</span>
<span class="linenos">1080</span>    <span class="k">def</span> <span class="nf">_set_step_sizes</span><span class="p">(</span>
<span class="linenos">1081</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1082</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1083</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1084</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1085</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos">1086</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1087</span><span class="sd">        Set the primal/dual step sizes.</span>
<span class="linenos">1088</span>
<span class="linenos">1089</span><span class="sd">        Returns</span>
<span class="linenos">1090</span><span class="sd">        -------</span>
<span class="linenos">1091</span><span class="sd">        Tuple[Real, Real, Real]</span>
<span class="linenos">1092</span><span class="sd">            Sensible primal/dual step sizes and value of the parameter :math:`delta`.</span>
<span class="linenos">1093</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">1094</span>        <span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_set_step_sizes</span><span class="p">(</span><span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
<span class="linenos">1095</span>        <span class="n">delta</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">pxa</span><span class="o">.</span><span class="n">QuadraticFunc</span><span class="p">))</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">)</span>
<span class="linenos">1096</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span></div>

<span class="linenos">1097</span>
<span class="linenos">1098</span>
<span class="linenos">1099</span><span class="n">LV</span> <span class="o">=</span> <span class="n">LorisVerhoeven</span>  <span class="c1">#: Alias of :py:class:`~pyxu.opt.solver.pds.LorisVerhoeven`.</span>
<span class="linenos">1100</span>
<span class="linenos">1101</span>
<div class="viewcode-block" id="DavisYin">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.DavisYin">[docs]</a>
<span class="linenos">1102</span><span class="k">class</span> <span class="nc">DavisYin</span><span class="p">(</span><span class="n">PD3O</span><span class="p">):</span>
<span class="linenos">1103</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1104</span><span class="sd">    Davis-Yin primal-dual splitting method.</span>
<span class="linenos">1105</span>
<span class="linenos">1106</span><span class="sd">    This solver is also accessible via the alias :py:class:`~pyxu.opt.solver.pds.DY`.</span>
<span class="linenos">1107</span>
<span class="linenos">1108</span><span class="sd">    The *Davis-Yin (DY) primal-dual splitting* method can be used to solve problems of the form:</span>
<span class="linenos">1109</span>
<span class="linenos">1110</span><span class="sd">    .. math::</span>
<span class="linenos">1111</span>
<span class="linenos">1112</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \;\mathcal{F}(\mathbf{x})\;\;+\;\;\mathcal{G}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathbf{x}),}</span>
<span class="linenos">1113</span>
<span class="linenos">1114</span><span class="sd">    where:</span>
<span class="linenos">1115</span>
<span class="linenos">1116</span><span class="sd">    * :math:`\mathcal{F}:\mathbb{R}^N\rightarrow \mathbb{R}` is *convex* and *differentiable*, with :math:`\beta`-*Lipschitz continuous* gradient,</span>
<span class="linenos">1117</span><span class="sd">      for some :math:`\beta\in[0,+\infty[`.</span>
<span class="linenos">1118</span>
<span class="linenos">1119</span><span class="sd">    * :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` and :math:`\mathcal{H}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` are *proper*, *lower semicontinuous* and *convex functions* with *simple proximal operators*.</span>
<span class="linenos">1120</span>
<span class="linenos">1121</span><span class="sd">    Remarks</span>
<span class="linenos">1122</span><span class="sd">    -------</span>
<span class="linenos">1123</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos">1124</span>
<span class="linenos">1125</span><span class="sd">    * The algorithm is still valid if one of the terms :math:`\mathcal{G}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos">1126</span>
<span class="linenos">1127</span><span class="sd">    * The *Davis-Yin primal-dual splitting* method can be obtained by choosing :math:`\mathcal{K}=\mathbf{I}`</span>
<span class="linenos">1128</span><span class="sd">      (identity) and :math:`\tau=1/\sigma` in :py:class:`~pyxu.opt.solver.pds.PD3O`, provided a suitable change of variable [PSA]_.</span>
<span class="linenos">1129</span>
<span class="linenos">1130</span><span class="sd">    Parameters (``__init__()``)</span>
<span class="linenos">1131</span><span class="sd">    ---------------------------</span>
<span class="linenos">1132</span><span class="sd">    * **f** (:py:class:`~pyxu.abc.operator.DiffFunc`)</span>
<span class="linenos">1133</span><span class="sd">      --</span>
<span class="linenos">1134</span><span class="sd">      Differentiable function :math:`\mathcal{F}`.</span>
<span class="linenos">1135</span><span class="sd">    * **g** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos">1136</span><span class="sd">      --</span>
<span class="linenos">1137</span><span class="sd">      Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos">1138</span><span class="sd">    * **h** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos">1139</span><span class="sd">      --</span>
<span class="linenos">1140</span><span class="sd">      Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos">1141</span><span class="sd">    * **beta** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1142</span><span class="sd">      --</span>
<span class="linenos">1143</span><span class="sd">      Lipschitz constant :math:`\beta` of :math:`\nabla\mathcal{F}`.</span>
<span class="linenos">1144</span><span class="sd">      If not provided, it will be automatically estimated.</span>
<span class="linenos">1145</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1146</span><span class="sd">      --</span>
<span class="linenos">1147</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos">1148</span>
<span class="linenos">1149</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos">1150</span><span class="sd">    ----------------------</span>
<span class="linenos">1151</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos">1152</span><span class="sd">      --</span>
<span class="linenos">1153</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos">1154</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos">1155</span><span class="sd">      --</span>
<span class="linenos">1156</span><span class="sd">      (..., N) initial point(s) for the dual variable.</span>
<span class="linenos">1157</span><span class="sd">      If ``None`` (default), then use ``x0`` as the initial point for the dual variable.</span>
<span class="linenos">1158</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1159</span><span class="sd">      --</span>
<span class="linenos">1160</span><span class="sd">      Primal step size.</span>
<span class="linenos">1161</span><span class="sd">    * **sigma** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1162</span><span class="sd">      --</span>
<span class="linenos">1163</span><span class="sd">      Dual step size.</span>
<span class="linenos">1164</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1165</span><span class="sd">      --</span>
<span class="linenos">1166</span><span class="sd">      Momentum parameter.</span>
<span class="linenos">1167</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos">1168</span><span class="sd">      --</span>
<span class="linenos">1169</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos">1170</span><span class="sd">      See :py:class:`~pyxu.opt.solver.pds.PD3O` for more details.</span>
<span class="linenos">1171</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1172</span><span class="sd">      --</span>
<span class="linenos">1173</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos">1174</span>
<span class="linenos">1175</span><span class="sd">    See Also</span>
<span class="linenos">1176</span><span class="sd">    --------</span>
<span class="linenos">1177</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos">1178</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.LorisVerhoeven`,</span>
<span class="linenos">1179</span><span class="sd">    :py:class:`~pyxu.opt.solver.pgd.PGD`,</span>
<span class="linenos">1180</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos">1181</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos">1182</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1183</span>
<span class="linenos">1184</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1185</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1186</span>        <span class="n">f</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffFunc</span><span class="p">],</span>
<span class="linenos">1187</span>        <span class="n">g</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1188</span>        <span class="n">h</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1189</span>        <span class="n">beta</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1190</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1191</span>    <span class="p">):</span>
<span class="linenos">1192</span>        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<span class="linenos">1193</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1194</span>            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
<span class="linenos">1195</span>            <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
<span class="linenos">1196</span>            <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
<span class="linenos">1197</span>            <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1198</span>            <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
<span class="linenos">1199</span>            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1200</span>        <span class="p">)</span>
<span class="linenos">1201</span>
<span class="linenos">1202</span>    <span class="k">def</span> <span class="nf">_set_step_sizes</span><span class="p">(</span>
<span class="linenos">1203</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1204</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1205</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1206</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span>
<span class="linenos">1207</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos">1208</span><span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1209</span><span class="sd">        Set the primal/dual step sizes.</span>
<span class="linenos">1210</span>
<span class="linenos">1211</span><span class="sd">        Returns</span>
<span class="linenos">1212</span><span class="sd">        -------</span>
<span class="linenos">1213</span><span class="sd">        Tuple[Real, Real, Real]</span>
<span class="linenos">1214</span><span class="sd">            Sensible primal/dual step sizes and value of :math:`\delta`.</span>
<span class="linenos">1215</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">1216</span>        <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1217</span>            <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">,</span> <span class="s2">&quot;tau must be positive and smaller than 1/gamma.&quot;</span>
<span class="linenos">1218</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1219</span>            <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">gamma</span>
<span class="linenos">1220</span>
<span class="linenos">1221</span>        <span class="n">delta</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beta</span> <span class="o">*</span> <span class="n">tau</span> <span class="o">/</span> <span class="mi">2</span>
<span class="linenos">1222</span>
<span class="linenos">1223</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span></div>

<span class="linenos">1224</span>
<span class="linenos">1225</span>
<span class="linenos">1226</span><span class="n">DY</span> <span class="o">=</span> <span class="n">DavisYin</span>  <span class="c1">#: Alias of :py:class:`~pyxu.opt.solver.pds.DavisYin`.</span>
<span class="linenos">1227</span>
<span class="linenos">1228</span>
<div class="viewcode-block" id="DouglasRachford">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.DouglasRachford">[docs]</a>
<span class="linenos">1229</span><span class="k">def</span> <span class="nf">DouglasRachford</span><span class="p">(</span>
<span class="linenos">1230</span>    <span class="n">g</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1231</span>    <span class="n">h</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1232</span>    <span class="n">base</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">_PrimalDualSplitting</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondatVu</span><span class="p">,</span>
<span class="linenos">1233</span>    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1234</span><span class="p">):</span>
<span class="linenos">1235</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1236</span><span class="sd">    Douglas-Rachford splitting algorithm.</span>
<span class="linenos">1237</span>
<span class="linenos">1238</span><span class="sd">    Parameters</span>
<span class="linenos">1239</span><span class="sd">    ----------</span>
<span class="linenos">1240</span><span class="sd">    g: :py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`</span>
<span class="linenos">1241</span><span class="sd">        Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos">1242</span><span class="sd">    h: :py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`</span>
<span class="linenos">1243</span><span class="sd">        Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos">1244</span><span class="sd">    base: :py:class:`~pyxu.opt.solver.pds.CondatVu`, :py:class:`~pyxu.opt.solver.pds.PD3O`</span>
<span class="linenos">1245</span><span class="sd">        Specifies the base primal-dual algorithm.</span>
<span class="linenos">1246</span><span class="sd">        (Default = :py:class:`~pyxu.opt.solver.pds.CondatVu`)</span>
<span class="linenos">1247</span><span class="sd">    \*\*kwargs: :py:class:`~collections.abc.Mapping`</span>
<span class="linenos">1248</span><span class="sd">        Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos">1249</span>
<span class="linenos">1250</span>
<span class="linenos">1251</span><span class="sd">    The *Douglas-Rachford (DR) primal-dual splitting* method can be used to solve problems of the form:</span>
<span class="linenos">1252</span>
<span class="linenos">1253</span><span class="sd">    .. math::</span>
<span class="linenos">1254</span>
<span class="linenos">1255</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \mathcal{G}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathbf{x}),}</span>
<span class="linenos">1256</span>
<span class="linenos">1257</span><span class="sd">    where :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` and :math:`\mathcal{H}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` are *proper*, *lower semicontinuous* and *convex functions* with *simple proximal operators*.</span>
<span class="linenos">1258</span>
<span class="linenos">1259</span><span class="sd">    Remarks</span>
<span class="linenos">1260</span><span class="sd">    -------</span>
<span class="linenos">1261</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos">1262</span>
<span class="linenos">1263</span><span class="sd">    * The algorithm is still valid if one of the terms :math:`\mathcal{G}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos">1264</span>
<span class="linenos">1265</span><span class="sd">    * The *Douglas-Rachford (DR) primal-dual splitting* method can be obtained by choosing :math:`\mathcal{F}=0`, :math:`\mathbf{K}=\mathbf{Id}` and :math:`\tau=1/\sigma` in :py:class:`~pyxu.opt.solver.pds.CondatVu` or :py:class:`~pyxu.opt.solver.pds.PD3O`.</span>
<span class="linenos">1266</span><span class="sd">      Douglas and Rachford originally introduced the algorithm without relaxation (:math:`\rho=1`), but relaxed versions have been proposed afterwards [PSA]_.</span>
<span class="linenos">1267</span><span class="sd">      When :math:`\rho=1`, Douglas-Rachford&#39;s algorithm is *functionally equivalent* to ADMM (up to a change of variable, see [PSA]_ for a derivation).</span>
<span class="linenos">1268</span>
<span class="linenos">1269</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos">1270</span><span class="sd">    ----------------------</span>
<span class="linenos">1271</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos">1272</span><span class="sd">      --</span>
<span class="linenos">1273</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos">1274</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos">1275</span><span class="sd">      --</span>
<span class="linenos">1276</span><span class="sd">      (..., N) initial point(s) for the dual variable.</span>
<span class="linenos">1277</span><span class="sd">      If ``None`` (default), then use ``x0`` as the initial point for the dual variable.</span>
<span class="linenos">1278</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1279</span><span class="sd">      --</span>
<span class="linenos">1280</span><span class="sd">      Primal step size. Defaults to 1.</span>
<span class="linenos">1281</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1282</span><span class="sd">      --</span>
<span class="linenos">1283</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos">1284</span>
<span class="linenos">1285</span><span class="sd">    See Also</span>
<span class="linenos">1286</span><span class="sd">    --------</span>
<span class="linenos">1287</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.CondatVu`,</span>
<span class="linenos">1288</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos">1289</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos">1290</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ForwardBackward`</span>
<span class="linenos">1291</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1292</span>    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<span class="linenos">1293</span>    <span class="n">obj</span> <span class="o">=</span> <span class="n">base</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos">1294</span>    <span class="n">obj</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="s2">&quot;DouglasRachford&quot;</span>
<span class="linenos">1295</span>
<span class="linenos">1296</span>    <span class="k">def</span> <span class="nf">_set_step_sizes_custom</span><span class="p">(</span>
<span class="linenos">1297</span>        <span class="n">obj</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="n">_PrimalDualSplitting</span><span class="p">],</span>
<span class="linenos">1298</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1299</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1300</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span>
<span class="linenos">1301</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos">1302</span>        <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tau</span>
<span class="linenos">1303</span>        <span class="n">delta</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="linenos">1304</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="linenos">1305</span>
<span class="linenos">1306</span>    <span class="n">obj</span><span class="o">.</span><span class="n">_set_step_sizes</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_set_step_sizes_custom</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
<span class="linenos">1307</span>    <span class="k">return</span> <span class="n">obj</span></div>

<span class="linenos">1308</span>
<span class="linenos">1309</span>
<span class="linenos">1310</span><span class="n">DR</span> <span class="o">=</span> <span class="n">DouglasRachford</span>  <span class="c1">#: Alias of :py:func:`~pyxu.opt.solver.pds.DouglasRachford`.</span>
<span class="linenos">1311</span>
<span class="linenos">1312</span>
<div class="viewcode-block" id="ADMM">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.ADMM">[docs]</a>
<span class="linenos">1313</span><span class="k">class</span> <span class="nc">ADMM</span><span class="p">(</span><span class="n">_PDS</span><span class="p">):</span>
<span class="linenos">1314</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1315</span><span class="sd">    Alternating Direction Method of Multipliers.</span>
<span class="linenos">1316</span>
<span class="linenos">1317</span><span class="sd">    The *Alternating Direction Method of Multipliers (ADMM)* can be used to solve problems of the form:</span>
<span class="linenos">1318</span>
<span class="linenos">1319</span><span class="sd">    .. math::</span>
<span class="linenos">1320</span>
<span class="linenos">1321</span><span class="sd">       \min_{\mathbf{x}\in\mathbb{R}^N} \quad \mathcal{F}(\mathbf{x})\;\;+\;\;\mathcal{H}(\mathbf{K}\mathbf{x}),</span>
<span class="linenos">1322</span>
<span class="linenos">1323</span><span class="sd">    where (see below for additional details on the assumptions):</span>
<span class="linenos">1324</span>
<span class="linenos">1325</span><span class="sd">    * :math:`\mathcal{F}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` is a *proper*, *lower semicontinuous* and</span>
<span class="linenos">1326</span><span class="sd">      *convex functional* potentially with *simple proximal operator* or *Lipschitz-differentiable*,</span>
<span class="linenos">1327</span><span class="sd">    * :math:`\mathcal{H}:\mathbb{R}^M\rightarrow \mathbb{R}\cup\{+\infty\}` is a *proper*, *lower semicontinuous* and</span>
<span class="linenos">1328</span><span class="sd">      *convex functional* with *simple proximal operator*,</span>
<span class="linenos">1329</span><span class="sd">    * :math:`\mathbf{K}:\mathbb{R}^N\rightarrow \mathbb{R}^M` is a *linear operator* with **operator norm**</span>
<span class="linenos">1330</span><span class="sd">      :math:`\Vert{\mathbf{K}}\Vert_2`.</span>
<span class="linenos">1331</span>
<span class="linenos">1332</span><span class="sd">    Remarks</span>
<span class="linenos">1333</span><span class="sd">    -------</span>
<span class="linenos">1334</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos">1335</span>
<span class="linenos">1336</span><span class="sd">    * The algorithm is still valid if either :math:`\mathcal{F}` or :math:`\mathcal{H}` is zero.</span>
<span class="linenos">1337</span>
<span class="linenos">1338</span><span class="sd">    * When :math:`\mathbf{K} = \mathbf{I}_{N}`, ADMM is equivalent to the :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos">1339</span><span class="sd">      method (up to a change of variable, see [PSA]_ for a derivation).</span>
<span class="linenos">1340</span>
<span class="linenos">1341</span><span class="sd">    * This is an implementation of the algorithm described in Section 5.4 of [PSA]_, which handles the non-smooth</span>
<span class="linenos">1342</span><span class="sd">      composite term :math:`\mathcal{H}(\mathbf{K}\mathbf{x})` by means of a change of variable and an infimal</span>
<span class="linenos">1343</span><span class="sd">      postcomposition trick.</span>
<span class="linenos">1344</span><span class="sd">      The update equation of this algorithm involves the following :math:`\mathbf{x}`-minimization step:</span>
<span class="linenos">1345</span>
<span class="linenos">1346</span><span class="sd">      .. math::</span>
<span class="linenos">1347</span><span class="sd">         :label: eq:x_minimization</span>
<span class="linenos">1348</span>
<span class="linenos">1349</span><span class="sd">         \mathcal{V} = \operatorname*{arg\,min}_{\mathbf{x} \in \mathbb{R}^N} \quad \mathcal{F}(\mathbf{x}) + \frac1{2 \tau}</span>
<span class="linenos">1350</span><span class="sd">         \Vert \mathbf{K} \mathbf{x} - \mathbf{a} \Vert_2^2,</span>
<span class="linenos">1351</span>
<span class="linenos">1352</span><span class="sd">      where :math:`\tau` is the primal step size and :math:`\mathbf{a} \in \mathbb{R}^M` is an iteration-dependant vector.</span>
<span class="linenos">1353</span>
<span class="linenos">1354</span><span class="sd">      The following cases are covered in this implementation:</span>
<span class="linenos">1355</span>
<span class="linenos">1356</span><span class="sd">      - :math:`\mathbf{K}` is ``None`` (i.e. the identity operator) and :math:`\mathcal{F}` is a :py:class:`~pyxu.abc.operator.ProxFunc`.</span>
<span class="linenos">1357</span><span class="sd">        Then, :math:numref:`eq:x_minimization` has a single solution provided by</span>
<span class="linenos">1358</span><span class="sd">        :math:`\operatorname*{prox}_{\tau \mathcal{F}}(\mathbf{a})`.</span>
<span class="linenos">1359</span><span class="sd">        This yields the *classical ADMM algorithm* described in Section 5.3 of [PSA]_ (i.e. without the postcomposition trick).</span>
<span class="linenos">1360</span>
<span class="linenos">1361</span><span class="sd">      - :math:`\mathcal{F}` is a :py:class:`~pyxu.abc.operator.QuadraticFunc`, i.e.</span>
<span class="linenos">1362</span><span class="sd">        :math:`\mathcal{F}(\mathbf{x})=\frac{1}{2} \langle\mathbf{x}, \mathbf{Q}\mathbf{x}\rangle + \mathbf{c}^T\mathbf{x} + t`.</span>
<span class="linenos">1363</span><span class="sd">        Then the unique solution to :math:numref:`eq:x_minimization` is obtained by solving a linear system of the form:</span>
<span class="linenos">1364</span>
<span class="linenos">1365</span><span class="sd">        .. math::</span>
<span class="linenos">1366</span><span class="sd">           :label: eq:linear_system</span>
<span class="linenos">1367</span>
<span class="linenos">1368</span><span class="sd">           \Big( \mathbf{Q} + \frac1\tau \mathbf{K}^* \mathbf{K} \Big) \mathbf{x} =</span>
<span class="linenos">1369</span><span class="sd">           \frac1\tau \mathbf{K}^\ast\mathbf{a}-\mathbf{c}, \qquad \mathbf{x} \in \mathbb{R}^N.</span>
<span class="linenos">1370</span>
<span class="linenos">1371</span><span class="sd">        This linear system is solved via a sub-iterative :py:class:`~pyxu.opt.solver.cg.CG` algorithm involving the repeated</span>
<span class="linenos">1372</span><span class="sd">        application of :math:`\mathbf{Q}` and :math:`\mathbf{K}^{*}\mathbf{K}`.</span>
<span class="linenos">1373</span><span class="sd">        This sub-iterative scheme may be computationally intensive if these operators do not admit fast matrix-free implementations.</span>
<span class="linenos">1374</span>
<span class="linenos">1375</span><span class="sd">      - :math:`\mathcal{F}` is a :py:class:`~pyxu.abc.operator.DiffFunc`.</span>
<span class="linenos">1376</span><span class="sd">        Then, :math:numref:`eq:x_minimization` is solved via a sub-iterative :py:class:`~pyxu.opt.solver.nlcg.NLCG` algorithm</span>
<span class="linenos">1377</span><span class="sd">        involving repeated evaluation of :math:`\nabla\mathcal{F}` and :math:`\mathbf{K}^{*}\mathbf{K}`.</span>
<span class="linenos">1378</span><span class="sd">        This sub-iterative scheme may be costly if these operators cannot be evaluated with fast algorithms.</span>
<span class="linenos">1379</span><span class="sd">        In this scenario, the use of multiple initial points in :py:meth:`~pyxu.abc.solver.Solver.fit` is not supported.</span>
<span class="linenos">1380</span>
<span class="linenos">1381</span><span class="sd">      The user may also provide a *custom* callable solver :math:`s: \mathbb{R}^M \times \mathbb{R} \to \mathbb{R}^N`,</span>
<span class="linenos">1382</span><span class="sd">      taking as input :math:`(\mathbf{a}, \tau)` and solving :math:numref:`eq:x_minimization`,</span>
<span class="linenos">1383</span><span class="sd">      i.e. :math:`s(\mathbf{a}, \tau) \in \mathcal{V}`. (See example below.)</span>
<span class="linenos">1384</span><span class="sd">      If :py:class:`~pyxu.opt.solver.pds.ADMM` is initialized with such a solver, then the latter is used to solve</span>
<span class="linenos">1385</span><span class="sd">      :math:numref:`eq:x_minimization` regardless of whether one of the above-mentioned cases is met.</span>
<span class="linenos">1386</span>
<span class="linenos">1387</span><span class="sd">    * Unlike traditional implementations of ADMM, :py:class:`~pyxu.opt.solver.pds.ADMM` supports relaxation, i.e. :math:`\rho\neq 1`.</span>
<span class="linenos">1388</span>
<span class="linenos">1389</span><span class="sd">    Parameters (``__init__()``)</span>
<span class="linenos">1390</span><span class="sd">    ---------------------------</span>
<span class="linenos">1391</span><span class="sd">    * **f** (:py:class:`~pyxu.abc.operator.DiffFunc`, :py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos">1392</span><span class="sd">      --</span>
<span class="linenos">1393</span><span class="sd">      Differentiable or proximable function :math:`\mathcal{F}`.</span>
<span class="linenos">1394</span><span class="sd">    * **h** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos">1395</span><span class="sd">      --</span>
<span class="linenos">1396</span><span class="sd">      Proximable function :math:`\mathcal{H}`.</span>
<span class="linenos">1397</span><span class="sd">    * **K** (:py:class:`~pyxu.abc.operator.LinOp`, :py:obj:`None`)</span>
<span class="linenos">1398</span><span class="sd">      --</span>
<span class="linenos">1399</span><span class="sd">      Linear operator :math:`\mathbf{K}`.</span>
<span class="linenos">1400</span><span class="sd">    * **solver** (:py:class:`~collections.abc.Callable`, :py:obj:`None`)</span>
<span class="linenos">1401</span><span class="sd">      --</span>
<span class="linenos">1402</span><span class="sd">      Custom callable to solve the :math:`\mathbf{x}`-minimization step :math:numref:`eq:x_minimization`.</span>
<span class="linenos">1403</span>
<span class="linenos">1404</span><span class="sd">      If provided, `solver` must have the `NumPy signature &lt;https://numpy.org/neps/nep-0020-gufunc-signature-enhancement.html&gt;`_</span>
<span class="linenos">1405</span><span class="sd">      ``(n), (1) -&gt; (n)``.</span>
<span class="linenos">1406</span><span class="sd">    * **solver_kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1407</span><span class="sd">      --</span>
<span class="linenos">1408</span><span class="sd">      Keyword parameters passed to the ``__init__()`` method of sub-iterative</span>
<span class="linenos">1409</span><span class="sd">      :py:class:`~pyxu.opt.solver.cg.CG` or :py:class:`~pyxu.opt.solver.nlcg.NLCG` solvers.</span>
<span class="linenos">1410</span>
<span class="linenos">1411</span><span class="sd">      `solver_kwargs` is ignored if `solver` provided.</span>
<span class="linenos">1412</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1413</span><span class="sd">      --</span>
<span class="linenos">1414</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos">1415</span>
<span class="linenos">1416</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos">1417</span><span class="sd">    ----------------------</span>
<span class="linenos">1418</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos">1419</span><span class="sd">      --</span>
<span class="linenos">1420</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos">1421</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos">1422</span><span class="sd">      --</span>
<span class="linenos">1423</span><span class="sd">      (..., M) initial point(s) for the dual variable.</span>
<span class="linenos">1424</span><span class="sd">      If ``None`` (default), then use ``K(x0)`` as the initial point for the dual variable.</span>
<span class="linenos">1425</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1426</span><span class="sd">      --</span>
<span class="linenos">1427</span><span class="sd">      Primal step size.</span>
<span class="linenos">1428</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1429</span><span class="sd">      --</span>
<span class="linenos">1430</span><span class="sd">      Momentum parameter for relaxation.</span>
<span class="linenos">1431</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos">1432</span><span class="sd">      --</span>
<span class="linenos">1433</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos">1434</span><span class="sd">      See base class for more details.</span>
<span class="linenos">1435</span><span class="sd">    * **solver_kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1436</span><span class="sd">      --</span>
<span class="linenos">1437</span><span class="sd">      Keyword parameters passed to the ``fit()`` method of sub-iterative</span>
<span class="linenos">1438</span><span class="sd">      :py:class:`~pyxu.opt.solver.cg.CG` or :py:class:`~pyxu.opt.solver.nlcg.NLCG` solvers.</span>
<span class="linenos">1439</span>
<span class="linenos">1440</span><span class="sd">      `solver_kwargs` is ignored if `solver` was provided in ``__init__()``.</span>
<span class="linenos">1441</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1442</span><span class="sd">      --</span>
<span class="linenos">1443</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos">1444</span>
<span class="linenos">1445</span><span class="sd">    Warning</span>
<span class="linenos">1446</span><span class="sd">    -------</span>
<span class="linenos">1447</span><span class="sd">    ``tuning_strategy`` docstring says to look at base class for details, but nothing mentioned there!</span>
<span class="linenos">1448</span>
<span class="linenos">1449</span><span class="sd">    Example</span>
<span class="linenos">1450</span><span class="sd">    -------</span>
<span class="linenos">1451</span><span class="sd">    Consider the following optimization problem:</span>
<span class="linenos">1452</span>
<span class="linenos">1453</span><span class="sd">    .. math::</span>
<span class="linenos">1454</span>
<span class="linenos">1455</span><span class="sd">       \min_{\mathbf{x}\in\mathbb{R}^N}\frac{1}{2}\left\|\mathbf{y}-\mathbf{G}\mathbf{x}\right\|_2^2\quad+\quad\lambda \|\mathbf{D}\mathbf{x}\|_1,</span>
<span class="linenos">1456</span>
<span class="linenos">1457</span><span class="sd">    with :math:`\mathbf{D}\in\mathbb{R}^{N\times N}` the discrete second-order derivative operator,</span>
<span class="linenos">1458</span><span class="sd">    :math:`\mathbf{G}\in\mathbb{R}^{M\times N}, \, \mathbf{y}\in\mathbb{R}^M, \lambda&gt;0.`</span>
<span class="linenos">1459</span><span class="sd">    This problem can be solved via ADMM with :math:`\mathcal{F}(\mathbf{x})= \frac{1}{2}\left\|\mathbf{y}-\mathbf{G}\mathbf{x}\right\|_2^2`,</span>
<span class="linenos">1460</span><span class="sd">    :math:`\mathcal{H}(\mathbf{x})=\lambda \|\mathbf{D}\mathbf{x}\|_1,` and :math:`\mathbf{K}=\mathbf{D}`.</span>
<span class="linenos">1461</span><span class="sd">    The functional :math:`\mathcal{F}` being quadratic, the :math:`\mathbf{x}`-minimization step consists in solving a linear system of</span>
<span class="linenos">1462</span><span class="sd">    the form :math:numref:`eq:linear_system`.</span>
<span class="linenos">1463</span><span class="sd">    Here, we demonstrate how to provide a custom solver, which consists in applying a matrix inverse, for this step.</span>
<span class="linenos">1464</span><span class="sd">    Otherwise, a sub-iterative :py:class:`~pyxu.opt.solver.cg.CG` algorithm would have been used automatically instead.</span>
<span class="linenos">1465</span>
<span class="linenos">1466</span><span class="sd">    .. plot::</span>
<span class="linenos">1467</span>
<span class="linenos">1468</span><span class="sd">       import matplotlib.pyplot as plt</span>
<span class="linenos">1469</span><span class="sd">       import numpy as np</span>
<span class="linenos">1470</span><span class="sd">       import pyxu.abc as pxa</span>
<span class="linenos">1471</span><span class="sd">       import pyxu.operator as pxo</span>
<span class="linenos">1472</span><span class="sd">       import scipy as sp</span>
<span class="linenos">1473</span><span class="sd">       from pyxu.opt.solver import ADMM</span>
<span class="linenos">1474</span>
<span class="linenos">1475</span><span class="sd">       N = 100  # Dimension of the problem</span>
<span class="linenos">1476</span>
<span class="linenos">1477</span><span class="sd">       # Generate piecewise-linear ground truth</span>
<span class="linenos">1478</span><span class="sd">       x_gt = np.array([10, 25, 60, 90])  # Knot locations</span>
<span class="linenos">1479</span><span class="sd">       a_gt = np.array([2, -4, 3, -2])  # Amplitudes of the knots</span>
<span class="linenos">1480</span><span class="sd">       gt = np.zeros(N)  # Ground-truth signal</span>
<span class="linenos">1481</span><span class="sd">       for n in range(len(x_gt)):</span>
<span class="linenos">1482</span><span class="sd">           gt[x_gt[n] :] += a_gt[n] * np.arange(N - x_gt[n]) / N</span>
<span class="linenos">1483</span>
<span class="linenos">1484</span><span class="sd">       # Generate data (noisy samples at random locations)</span>
<span class="linenos">1485</span><span class="sd">       M = 20  # Number of data points</span>
<span class="linenos">1486</span><span class="sd">       rng = np.random.default_rng(seed=0)</span>
<span class="linenos">1487</span><span class="sd">       x_samp = rng.choice(np.arange(N // M), size=M) + np.arange(N, step=N // M)  # sampling locations</span>
<span class="linenos">1488</span><span class="sd">       sigma = 2 * 1e-2  # noise variance</span>
<span class="linenos">1489</span><span class="sd">       y = gt[x_samp] + sigma * rng.standard_normal(size=M)  # noisy data points</span>
<span class="linenos">1490</span>
<span class="linenos">1491</span><span class="sd">       # Data-fidelity term</span>
<span class="linenos">1492</span><span class="sd">       subsamp_mat = sp.sparse.lil_matrix((M, N))</span>
<span class="linenos">1493</span><span class="sd">       for i in range(M):</span>
<span class="linenos">1494</span><span class="sd">           subsamp_mat[i, x_samp[i]] = 1</span>
<span class="linenos">1495</span><span class="sd">       G = pxa.LinOp.from_array(subsamp_mat.tocsr())</span>
<span class="linenos">1496</span><span class="sd">       F = 1 / 2 * pxo.SquaredL2Norm(dim=y.size).argshift(-y) * G</span>
<span class="linenos">1497</span><span class="sd">       F.diff_lipschitz = F.estimate_diff_lipschitz(method=&quot;svd&quot;)</span>
<span class="linenos">1498</span>
<span class="linenos">1499</span><span class="sd">       # Regularization term (promotes sparse second derivatives)</span>
<span class="linenos">1500</span><span class="sd">       deriv_mat = sp.sparse.diags(diagonals=[1, -2, 1], offsets=[0, 1, 2], shape=(N - 2, N))</span>
<span class="linenos">1501</span><span class="sd">       D = pxa.LinOp.from_array(deriv_mat)</span>
<span class="linenos">1502</span><span class="sd">       _lambda = 1e-1  # regularization parameter</span>
<span class="linenos">1503</span><span class="sd">       H = _lambda * pxo.L1Norm(dim=D.codim)</span>
<span class="linenos">1504</span>
<span class="linenos">1505</span><span class="sd">       # Solver for ADMM</span>
<span class="linenos">1506</span><span class="sd">       tau = 1 / _lambda  # internal ADMM parameter</span>
<span class="linenos">1507</span><span class="sd">       # Inverse operator to solve the linear system</span>
<span class="linenos">1508</span><span class="sd">       A_inv = sp.linalg.inv(G.gram().asarray() + (1 / tau) * D.gram().asarray())</span>
<span class="linenos">1509</span>
<span class="linenos">1510</span>
<span class="linenos">1511</span><span class="sd">       def solver_ADMM(arr, tau):</span>
<span class="linenos">1512</span><span class="sd">           b = (1 / tau) * D.adjoint(arr) + G.adjoint(y)</span>
<span class="linenos">1513</span><span class="sd">           return A_inv @ b.squeeze()</span>
<span class="linenos">1514</span>
<span class="linenos">1515</span>
<span class="linenos">1516</span><span class="sd">       # Solve optimization problem</span>
<span class="linenos">1517</span><span class="sd">       admm = ADMM(f=F, h=H, K=D, solver=solver_ADMM,show_progress=False)  # with solver</span>
<span class="linenos">1518</span><span class="sd">       admm.fit(x0=np.zeros(N), tau=tau)</span>
<span class="linenos">1519</span><span class="sd">       x_opt = admm.solution()  # reconstructed signal</span>
<span class="linenos">1520</span>
<span class="linenos">1521</span><span class="sd">       # Plots</span>
<span class="linenos">1522</span><span class="sd">       plt.figure()</span>
<span class="linenos">1523</span><span class="sd">       plt.plot(np.arange(N), gt, label=&quot;Ground truth&quot;)</span>
<span class="linenos">1524</span><span class="sd">       plt.plot(x_samp, y, &quot;kx&quot;, label=&quot;Noisy data points&quot;)</span>
<span class="linenos">1525</span><span class="sd">       plt.plot(np.arange(N), x_opt, label=&quot;Reconstructed signal&quot;)</span>
<span class="linenos">1526</span><span class="sd">       plt.legend()</span>
<span class="linenos">1527</span>
<span class="linenos">1528</span><span class="sd">    See Also</span>
<span class="linenos">1529</span><span class="sd">    --------</span>
<span class="linenos">1530</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.CondatVu`,</span>
<span class="linenos">1531</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos">1532</span><span class="sd">    :py:class:`~pyxu.opt.solver.pgd.PGD`,</span>
<span class="linenos">1533</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos">1534</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos">1535</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1536</span>
<span class="linenos">1537</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1538</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1539</span>        <span class="n">f</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">Func</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1540</span>        <span class="n">h</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1541</span>        <span class="n">K</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffMap</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1542</span>        <span class="n">solver</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Callable</span><span class="p">[[</span><span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1543</span>        <span class="n">solver_kwargs</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1544</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1545</span>    <span class="p">):</span>
<span class="linenos">1546</span>        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)))</span>
<span class="linenos">1547</span>
<span class="linenos">1548</span>        <span class="n">x_update_solver</span> <span class="o">=</span> <span class="s2">&quot;custom&quot;</span>  <span class="c1"># Method for the x-minimization step</span>
<span class="linenos">1549</span>        <span class="n">g</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">1550</span>        <span class="k">if</span> <span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1551</span>            <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1552</span>                <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1553</span>                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
<span class="linenos">1554</span>                        <span class="p">[</span>
<span class="linenos">1555</span>                            <span class="s2">&quot;Cannot minimize always-0 functional.&quot;</span><span class="p">,</span>
<span class="linenos">1556</span>                            <span class="s2">&quot;At least one of Parameter[f, h] must be specified.&quot;</span><span class="p">,</span>
<span class="linenos">1557</span>                        <span class="p">]</span>
<span class="linenos">1558</span>                    <span class="p">)</span>
<span class="linenos">1559</span>                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="linenos">1560</span>                <span class="k">if</span> <span class="n">K</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Prox scenario (classical ADMM)</span>
<span class="linenos">1561</span>                    <span class="n">f</span> <span class="o">=</span> <span class="n">pxf</span><span class="o">.</span><span class="n">NullFunc</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
<span class="linenos">1562</span>                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Sub-iterative CG scenario</span>
<span class="linenos">1563</span>                    <span class="n">f</span> <span class="o">=</span> <span class="n">pxa</span><span class="o">.</span><span class="n">QuadraticFunc</span><span class="p">(</span>
<span class="linenos">1564</span>                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">Q</span><span class="o">=</span><span class="n">pxl</span><span class="o">.</span><span class="n">NullOp</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">dim</span><span class="p">)),</span> <span class="n">c</span><span class="o">=</span><span class="n">pxf</span><span class="o">.</span><span class="n">NullFunc</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">h</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
<span class="linenos">1565</span>                    <span class="p">)</span>
<span class="linenos">1566</span>            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">pxa</span><span class="o">.</span><span class="n">Property</span><span class="o">.</span><span class="n">PROXIMABLE</span><span class="p">)</span> <span class="ow">and</span> <span class="n">K</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1567</span>                <span class="n">x_update_solver</span> <span class="o">=</span> <span class="s2">&quot;prox&quot;</span>
<span class="linenos">1568</span>                <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>  <span class="c1"># In this case, f corresponds to g in the _PDS terminology</span>
<span class="linenos">1569</span>                <span class="n">f</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">1570</span>            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pxa</span><span class="o">.</span><span class="n">QuadraticFunc</span><span class="p">):</span>
<span class="linenos">1571</span>                <span class="n">x_update_solver</span> <span class="o">=</span> <span class="s2">&quot;cg&quot;</span>
<span class="linenos">1572</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_K_gram</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gram</span><span class="p">()</span>
<span class="linenos">1573</span>                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
<span class="linenos">1574</span>                    <span class="s2">&quot;A sub-iterative conjugate gradient algorithm is used for the x-minimization step &quot;</span>
<span class="linenos">1575</span>                    <span class="s2">&quot;of ADMM. This might be computationally expensive.&quot;</span><span class="p">,</span>
<span class="linenos">1576</span>                    <span class="ne">UserWarning</span><span class="p">,</span>
<span class="linenos">1577</span>                <span class="p">)</span>
<span class="linenos">1578</span>            <span class="k">elif</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">pxa</span><span class="o">.</span><span class="n">Property</span><span class="o">.</span><span class="n">DIFFERENTIABLE_FUNCTION</span><span class="p">):</span>
<span class="linenos">1579</span>                <span class="n">x_update_solver</span> <span class="o">=</span> <span class="s2">&quot;nlcg&quot;</span>
<span class="linenos">1580</span>                <span class="bp">self</span><span class="o">.</span><span class="n">_K_gram</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">gram</span><span class="p">()</span>
<span class="linenos">1581</span>                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
<span class="linenos">1582</span>                    <span class="s2">&quot;A sub-iterative non-linear conjugate gradient algorithm is used for the &quot;</span>
<span class="linenos">1583</span>                    <span class="s2">&quot;x-minimization step of ADMM. This might be computationally expensive.&quot;</span><span class="p">,</span>
<span class="linenos">1584</span>                    <span class="ne">UserWarning</span><span class="p">,</span>
<span class="linenos">1585</span>                <span class="p">)</span>
<span class="linenos">1586</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">1587</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">1588</span>                    <span class="s2">&quot;Unsupported scenario: f must either be a ProxFunc (in which case K must be None), a &quot;</span>
<span class="linenos">1589</span>                    <span class="s2">&quot;QuadraticFunc, or a DiffMap. If neither of these scenarios hold, a solver must be provided for &quot;</span>
<span class="linenos">1590</span>                    <span class="s2">&quot;the x-minimization step of ADMM.&quot;</span>
<span class="linenos">1591</span>                <span class="p">)</span>
<span class="linenos">1592</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span> <span class="o">=</span> <span class="n">solver</span>
<span class="linenos">1593</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_x_update_solver</span> <span class="o">=</span> <span class="n">x_update_solver</span>
<span class="linenos">1594</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">solver_kwargs</span> <span class="k">if</span> <span class="n">solver_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="linenos">1595</span>
<span class="linenos">1596</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1597</span>            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
<span class="linenos">1598</span>            <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
<span class="linenos">1599</span>            <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
<span class="linenos">1600</span>            <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span>
<span class="linenos">1601</span>            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1602</span>        <span class="p">)</span>
<span class="linenos">1603</span>
<span class="linenos">1604</span>    <span class="nd">@pxrt</span><span class="o">.</span><span class="n">enforce_precision</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="s2">&quot;z0&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="s2">&quot;rho&quot;</span><span class="p">),</span> <span class="n">allow_None</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">1605</span>    <span class="k">def</span> <span class="nf">m_init</span><span class="p">(</span>
<span class="linenos">1606</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1607</span>        <span class="n">x0</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
<span class="linenos">1608</span>        <span class="n">z0</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1609</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1610</span>        <span class="n">rho</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1611</span>        <span class="n">tuning_strategy</span><span class="p">:</span> <span class="n">_PDS</span><span class="o">.</span><span class="n">TuningSpec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="linenos">1612</span>        <span class="n">solver_kwargs</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1613</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1614</span>    <span class="p">):</span>
<span class="linenos">1615</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">m_init</span><span class="p">(</span>
<span class="linenos">1616</span>            <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
<span class="linenos">1617</span>            <span class="n">z0</span><span class="o">=</span><span class="n">z0</span><span class="p">,</span>
<span class="linenos">1618</span>            <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">,</span>
<span class="linenos">1619</span>            <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1620</span>            <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span>
<span class="linenos">1621</span>            <span class="n">tuning_strategy</span><span class="o">=</span><span class="n">tuning_strategy</span><span class="p">,</span>
<span class="linenos">1622</span>        <span class="p">)</span>
<span class="linenos">1623</span>        <span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span>  <span class="c1"># shorthand</span>
<span class="linenos">1624</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="linenos">1625</span>
<span class="linenos">1626</span>        <span class="c1"># Fit kwargs of sub-iterative solver</span>
<span class="linenos">1627</span>        <span class="k">if</span> <span class="n">solver_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1628</span>            <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="linenos">1629</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_fit_kwargs</span> <span class="o">=</span> <span class="n">solver_kwargs</span>
<span class="linenos">1630</span>
<span class="linenos">1631</span>    <span class="k">def</span> <span class="nf">m_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1632</span>        <span class="c1"># Algorithm (145) in [PSA]. Paper -&gt; code correspondence: L -&gt; K, K -&gt; -Id, c -&gt; 0, y -&gt; u, v -&gt; z, g -&gt; h</span>
<span class="linenos">1633</span>        <span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span>
<span class="linenos">1634</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_update</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">],</span> <span class="n">tau</span><span class="o">=</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">])</span>
<span class="linenos">1635</span>        <span class="n">z_temp</span> <span class="o">=</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span>
<span class="linenos">1636</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;NullFunc&quot;</span><span class="p">:</span>
<span class="linenos">1637</span>            <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h</span><span class="o">.</span><span class="n">prox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="n">z_temp</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">])</span>
<span class="linenos">1638</span>        <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_temp</span> <span class="o">+</span> <span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">(</span><span class="n">mst</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="n">mst</span><span class="p">[</span><span class="s2">&quot;u&quot;</span><span class="p">])</span>
<span class="linenos">1639</span>
<span class="linenos">1640</span>    <span class="k">def</span> <span class="nf">_x_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="linenos">1641</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_update_solver</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span><span class="p">:</span>
<span class="linenos">1642</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solver</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
<span class="linenos">1643</span>        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_update_solver</span> <span class="o">==</span> <span class="s2">&quot;prox&quot;</span><span class="p">:</span>
<span class="linenos">1644</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_g</span><span class="o">.</span><span class="n">prox</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
<span class="linenos">1645</span>        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_update_solver</span> <span class="o">==</span> <span class="s2">&quot;cg&quot;</span><span class="p">:</span>
<span class="linenos">1646</span>            <span class="kn">from</span> <span class="nn">pyxu.opt.solver</span> <span class="kn">import</span> <span class="n">CG</span>
<span class="linenos">1647</span>
<span class="linenos">1648</span>            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="linenos">1649</span>            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">_Q</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K_gram</span>
<span class="linenos">1650</span>            <span class="n">slvr</span> <span class="o">=</span> <span class="n">CG</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span><span class="p">)</span>
<span class="linenos">1651</span>            <span class="n">slvr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_kwargs</span><span class="p">)</span>  <span class="c1"># Initialize CG with previous iterate</span>
<span class="linenos">1652</span>            <span class="k">return</span> <span class="n">slvr</span><span class="o">.</span><span class="n">solution</span><span class="p">()</span>
<span class="linenos">1653</span>        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_update_solver</span> <span class="o">==</span> <span class="s2">&quot;nlcg&quot;</span><span class="p">:</span>
<span class="linenos">1654</span>            <span class="kn">from</span> <span class="nn">pyxu.opt.solver</span> <span class="kn">import</span> <span class="n">NLCG</span>
<span class="linenos">1655</span>
<span class="linenos">1656</span>            <span class="n">c</span> <span class="o">=</span> <span class="n">pxa</span><span class="o">.</span><span class="n">LinFunc</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
<span class="linenos">1657</span>            <span class="n">quad_func</span> <span class="o">=</span> <span class="n">pxa</span><span class="o">.</span><span class="n">QuadraticFunc</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span> <span class="n">Q</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K_gram</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="linenos">1658</span>            <span class="n">slvr</span> <span class="o">=</span> <span class="n">NLCG</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">quad_func</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span><span class="p">)</span>
<span class="linenos">1659</span>            <span class="n">slvr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_fit_kwargs</span><span class="p">)</span>  <span class="c1"># Initialize NLCG with previous iterate</span>
<span class="linenos">1660</span>            <span class="k">return</span> <span class="n">slvr</span><span class="o">.</span><span class="n">solution</span><span class="p">()</span>
<span class="linenos">1661</span>
<span class="linenos">1662</span>    <span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">which</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;primal&quot;</span><span class="p">,</span> <span class="s2">&quot;primal_h&quot;</span><span class="p">,</span> <span class="s2">&quot;dual&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;primal&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pxt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="linenos">1663</span>        <span class="n">data</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span>
<span class="linenos">1664</span>        <span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;primal&quot;</span><span class="p">:</span>
<span class="linenos">1665</span>            <span class="k">assert</span> <span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;Primal variable x in dom(g) was not logged (declare it in log_var to log it).&quot;</span>
<span class="linenos">1666</span>            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="linenos">1667</span>        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;primal_h&quot;</span><span class="p">:</span>
<span class="linenos">1668</span>            <span class="k">assert</span> <span class="s2">&quot;u&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;Primal variable u in dom(h) was not logged (declare it in log_var to log it).&quot;</span>
<span class="linenos">1669</span>            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">)</span>
<span class="linenos">1670</span>        <span class="k">elif</span> <span class="n">which</span> <span class="o">==</span> <span class="s2">&quot;dual&quot;</span><span class="p">:</span>
<span class="linenos">1671</span>            <span class="k">assert</span> <span class="s2">&quot;z&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;Dual variable z was not logged (declare it in log_var to log it).&quot;</span>
<span class="linenos">1672</span>            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mstate</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span>
<span class="linenos">1673</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1674</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter which must be one of [&#39;primal&#39;, &#39;primal_h&#39;, &#39;dual&#39;] got: </span><span class="si">{</span><span class="n">which</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="linenos">1675</span>
<span class="linenos">1676</span>    <span class="k">def</span> <span class="nf">_set_step_sizes</span><span class="p">(</span>
<span class="linenos">1677</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1678</span>        <span class="n">tau</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1679</span>        <span class="n">sigma</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">],</span>
<span class="linenos">1680</span>        <span class="n">gamma</span><span class="p">:</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span>
<span class="linenos">1681</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">,</span> <span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]:</span>
<span class="linenos">1682</span>        <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1683</span>            <span class="k">assert</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Parameter tau must be positive, got </span><span class="si">{</span><span class="n">tau</span><span class="si">}</span><span class="s2">.&quot;</span>
<span class="linenos">1684</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1685</span>            <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos">1686</span>        <span class="n">delta</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="linenos">1687</span>        <span class="k">return</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">tau</span><span class="p">),</span> <span class="n">pxrt</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span></div>

<span class="linenos">1688</span>
<span class="linenos">1689</span>
<div class="viewcode-block" id="ForwardBackward">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.ForwardBackward">[docs]</a>
<span class="linenos">1690</span><span class="k">class</span> <span class="nc">ForwardBackward</span><span class="p">(</span><span class="n">CondatVu</span><span class="p">):</span>
<span class="linenos">1691</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1692</span><span class="sd">    Forward-backward splitting algorithm.</span>
<span class="linenos">1693</span>
<span class="linenos">1694</span><span class="sd">    This solver is also accessible via the alias :py:class:`~pyxu.opt.solver.pds.FB`.</span>
<span class="linenos">1695</span>
<span class="linenos">1696</span><span class="sd">    The *Forward-backward (FB) splitting* method can be used to solve problems of the form:</span>
<span class="linenos">1697</span>
<span class="linenos">1698</span><span class="sd">    .. math::</span>
<span class="linenos">1699</span>
<span class="linenos">1700</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \;\mathcal{F}(\mathbf{x})\;\;+\;\;\mathcal{G}(\mathbf{x}),}</span>
<span class="linenos">1701</span>
<span class="linenos">1702</span><span class="sd">    where:</span>
<span class="linenos">1703</span>
<span class="linenos">1704</span><span class="sd">    * :math:`\mathcal{F}:\mathbb{R}^N\rightarrow \mathbb{R}` is *convex* and *differentiable*, with :math:`\beta`-*Lipschitz continuous* gradient,</span>
<span class="linenos">1705</span><span class="sd">      for some :math:`\beta\in[0,+\infty[`.</span>
<span class="linenos">1706</span><span class="sd">    * :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` is *proper*, *lower semicontinuous* and *convex function* with *simple proximal operator*.</span>
<span class="linenos">1707</span>
<span class="linenos">1708</span><span class="sd">    Remarks</span>
<span class="linenos">1709</span><span class="sd">    -------</span>
<span class="linenos">1710</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos">1711</span>
<span class="linenos">1712</span><span class="sd">    * The algorithm is still valid if one of the terms :math:`\mathcal{F}` or :math:`\mathcal{G}` is zero.</span>
<span class="linenos">1713</span>
<span class="linenos">1714</span><span class="sd">    * The *Forward-backward (FB) primal-dual splitting* method can be obtained by choosing :math:`\mathcal{H}=0` in :py:class:`~pyxu.opt.solver.pds.CondatVu`.</span>
<span class="linenos">1715</span><span class="sd">      Mercier originally introduced the algorithm without relaxation (:math:`\rho=1`) [FB]_.</span>
<span class="linenos">1716</span><span class="sd">      Relaxed versions have been proposed afterwards [PSA]_.</span>
<span class="linenos">1717</span><span class="sd">      The Forward-backward algorithm is also known as the *Proximal Gradient Descent (PGD)* algorithm.</span>
<span class="linenos">1718</span><span class="sd">      For the accelerated version of PGD, use :py:class:`~pyxu.opt.solver.pgd.PGD`.</span>
<span class="linenos">1719</span>
<span class="linenos">1720</span><span class="sd">    Parameters (``__init__()``)</span>
<span class="linenos">1721</span><span class="sd">    ---------------------------</span>
<span class="linenos">1722</span><span class="sd">    * **f** (:py:class:`~pyxu.abc.operator.DiffFunc`, :py:obj:`None`)</span>
<span class="linenos">1723</span><span class="sd">      --</span>
<span class="linenos">1724</span><span class="sd">      Differentiable function :math:`\mathcal{F}`.</span>
<span class="linenos">1725</span><span class="sd">    * **g** (:py:class:`~pyxu.abc.operator.ProxFunc`, :py:obj:`None`)</span>
<span class="linenos">1726</span><span class="sd">      --</span>
<span class="linenos">1727</span><span class="sd">      Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos">1728</span><span class="sd">    * **beta** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1729</span><span class="sd">      --</span>
<span class="linenos">1730</span><span class="sd">      Lipschitz constant :math:`\beta` of :math:`\nabla\mathcal{F}`.</span>
<span class="linenos">1731</span><span class="sd">      If not provided, it will be automatically estimated.</span>
<span class="linenos">1732</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1733</span><span class="sd">      --</span>
<span class="linenos">1734</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos">1735</span>
<span class="linenos">1736</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos">1737</span><span class="sd">    ----------------------</span>
<span class="linenos">1738</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos">1739</span><span class="sd">      --</span>
<span class="linenos">1740</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos">1741</span><span class="sd">    * **z0** (:py:attr:`~pyxu.info.ptype.NDArray`, :py:obj:`None`)</span>
<span class="linenos">1742</span><span class="sd">      --</span>
<span class="linenos">1743</span><span class="sd">      (..., N) initial point(s) for the dual variable.</span>
<span class="linenos">1744</span><span class="sd">      If ``None`` (default), then use ``x0`` as the initial point for the dual variable.</span>
<span class="linenos">1745</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1746</span><span class="sd">      --</span>
<span class="linenos">1747</span><span class="sd">      Primal step size.</span>
<span class="linenos">1748</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1749</span><span class="sd">      --</span>
<span class="linenos">1750</span><span class="sd">      Momentum parameter.</span>
<span class="linenos">1751</span><span class="sd">    * **tuning_strategy** (1, 2, 3)</span>
<span class="linenos">1752</span><span class="sd">      --</span>
<span class="linenos">1753</span><span class="sd">      Strategy to be employed when setting the hyperparameters (default to 1).</span>
<span class="linenos">1754</span><span class="sd">      See :py:class:`~pyxu.opt.solver.pds.CondatVu` for more details.</span>
<span class="linenos">1755</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1756</span><span class="sd">      --</span>
<span class="linenos">1757</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos">1758</span>
<span class="linenos">1759</span><span class="sd">    See Also</span>
<span class="linenos">1760</span><span class="sd">    --------</span>
<span class="linenos">1761</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.CondatVu`,</span>
<span class="linenos">1762</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos">1763</span><span class="sd">    :py:class:`~pyxu.opt.solver.pgd.PGD`,</span>
<span class="linenos">1764</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos">1765</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos">1766</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1767</span>
<span class="linenos">1768</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1769</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">1770</span>        <span class="n">f</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">DiffFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1771</span>        <span class="n">g</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1772</span>        <span class="n">beta</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxt</span><span class="o">.</span><span class="n">Real</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1773</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1774</span>    <span class="p">):</span>
<span class="linenos">1775</span>        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,)))</span>
<span class="linenos">1776</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">1777</span>            <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
<span class="linenos">1778</span>            <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
<span class="linenos">1779</span>            <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1780</span>            <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1781</span>            <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
<span class="linenos">1782</span>            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1783</span>        <span class="p">)</span></div>

<span class="linenos">1784</span>
<span class="linenos">1785</span>
<span class="linenos">1786</span><span class="n">FB</span> <span class="o">=</span> <span class="n">ForwardBackward</span>  <span class="c1">#: Alias of :py:class:`~pyxu.opt.solver.pds.ForwardBackward`.</span>
<span class="linenos">1787</span>
<span class="linenos">1788</span>
<div class="viewcode-block" id="ProximalPoint">
<a class="viewcode-back" href="../../../../api/opt.html#pyxu.opt.solver.pds.ProximalPoint">[docs]</a>
<span class="linenos">1789</span><span class="k">def</span> <span class="nf">ProximalPoint</span><span class="p">(</span>
<span class="linenos">1790</span>    <span class="n">g</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">pxa</span><span class="o">.</span><span class="n">ProxFunc</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">1791</span>    <span class="n">base</span><span class="p">:</span> <span class="n">typ</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_PrimalDualSplitting</span><span class="p">]</span> <span class="o">=</span> <span class="n">CondatVu</span><span class="p">,</span>
<span class="linenos">1792</span>    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1793</span><span class="p">):</span>
<span class="linenos">1794</span><span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">1795</span><span class="sd">    Proximal-point method.</span>
<span class="linenos">1796</span>
<span class="linenos">1797</span><span class="sd">    Parameters</span>
<span class="linenos">1798</span><span class="sd">    ----------</span>
<span class="linenos">1799</span><span class="sd">    g: :py:class:`~pyxu.abc.operator.ProxFunc`</span>
<span class="linenos">1800</span><span class="sd">        Proximable function :math:`\mathcal{G}`.</span>
<span class="linenos">1801</span><span class="sd">    base: :py:class:`~pyxu.opt.solver.pds.CondatVu`, :py:class:`~pyxu.opt.solver.pds.PD3O`</span>
<span class="linenos">1802</span><span class="sd">        Specifies the base primal-dual algorithm from which mathematical updates are inherited.</span>
<span class="linenos">1803</span><span class="sd">        (Default = :py:class:`~pyxu.opt.solver.pds.CondatVu`)</span>
<span class="linenos">1804</span><span class="sd">    \*\*kwargs: :py:class:`~collections.abc.Mapping`</span>
<span class="linenos">1805</span><span class="sd">        Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.__init__`.</span>
<span class="linenos">1806</span>
<span class="linenos">1807</span>
<span class="linenos">1808</span><span class="sd">    The *Proximal-point (PP)* method can be used to solve problems of the form:</span>
<span class="linenos">1809</span>
<span class="linenos">1810</span><span class="sd">    .. math::</span>
<span class="linenos">1811</span>
<span class="linenos">1812</span><span class="sd">       {\min_{\mathbf{x}\in\mathbb{R}^N} \;\mathcal{G}(\mathbf{x}),}</span>
<span class="linenos">1813</span>
<span class="linenos">1814</span><span class="sd">    where :math:`\mathcal{G}:\mathbb{R}^N\rightarrow \mathbb{R}\cup\{+\infty\}` is *proper*, *lower semicontinuous* and *convex function* with *simple proximal operator*.</span>
<span class="linenos">1815</span>
<span class="linenos">1816</span><span class="sd">    Remarks</span>
<span class="linenos">1817</span><span class="sd">    -------</span>
<span class="linenos">1818</span><span class="sd">    * The problem is *feasible*, i.e. there exists at least one solution.</span>
<span class="linenos">1819</span>
<span class="linenos">1820</span><span class="sd">    * The *Proximal-point* algorithm can be obtained by choosing :math:`\mathcal{F}=0` and :math:`\mathcal{H}=0` in :py:class:`~pyxu.opt.solver.pds.CondatVu` or :py:class:`~pyxu.opt.solver.pds.PD3O`.</span>
<span class="linenos">1821</span><span class="sd">      The original version of the algorithm was introduced without relaxation (:math:`\rho=1`) [PP]_.</span>
<span class="linenos">1822</span><span class="sd">      Relaxed versions have been proposed afterwards [PSA]_.</span>
<span class="linenos">1823</span>
<span class="linenos">1824</span><span class="sd">    Parameters (``fit()``)</span>
<span class="linenos">1825</span><span class="sd">    ----------------------</span>
<span class="linenos">1826</span><span class="sd">    * **x0** (:py:attr:`~pyxu.info.ptype.NDArray`)</span>
<span class="linenos">1827</span><span class="sd">      --</span>
<span class="linenos">1828</span><span class="sd">      (..., N) initial point(s) for the primal variable.</span>
<span class="linenos">1829</span><span class="sd">    * **tau** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1830</span><span class="sd">      --</span>
<span class="linenos">1831</span><span class="sd">      Primal step size.</span>
<span class="linenos">1832</span><span class="sd">    * **rho** (:py:attr:`~pyxu.info.ptype.Real`, :py:obj:`None`)</span>
<span class="linenos">1833</span><span class="sd">      --</span>
<span class="linenos">1834</span><span class="sd">      Momentum parameter.</span>
<span class="linenos">1835</span><span class="sd">    * **\*\*kwargs** (:py:class:`~collections.abc.Mapping`)</span>
<span class="linenos">1836</span><span class="sd">      --</span>
<span class="linenos">1837</span><span class="sd">      Other keyword parameters passed on to :py:meth:`pyxu.abc.solver.Solver.fit`.</span>
<span class="linenos">1838</span>
<span class="linenos">1839</span><span class="sd">    See Also</span>
<span class="linenos">1840</span><span class="sd">    --------</span>
<span class="linenos">1841</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PP`,</span>
<span class="linenos">1842</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.CondatVu`,</span>
<span class="linenos">1843</span><span class="sd">    :py:class:`~pyxu.opt.solver.pds.PD3O`,</span>
<span class="linenos">1844</span><span class="sd">    :py:class:`~pyxu.opt.solver.pgd.PGD`,</span>
<span class="linenos">1845</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.ChambollePock`,</span>
<span class="linenos">1846</span><span class="sd">    :py:func:`~pyxu.opt.solver.pds.DouglasRachford`</span>
<span class="linenos">1847</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1848</span>    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">log_var</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;log_var&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,)))</span>
<span class="linenos">1849</span>    <span class="n">obj</span> <span class="o">=</span> <span class="n">base</span><span class="p">(</span>
<span class="linenos">1850</span>        <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1851</span>        <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
<span class="linenos">1852</span>        <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1853</span>        <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1854</span>        <span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1855</span>        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">1856</span>    <span class="p">)</span>
<span class="linenos">1857</span>
<span class="linenos">1858</span>    <span class="n">obj</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="s2">&quot;ProximalPoint&quot;</span>
<span class="linenos">1859</span>    <span class="k">return</span> <span class="n">obj</span></div>

<span class="linenos">1860</span>
<span class="linenos">1861</span>
<span class="linenos">1862</span><span class="n">PP</span> <span class="o">=</span> <span class="n">ProximalPoint</span>  <span class="c1">#: Alias of :py:func:`~pyxu.opt.solver.pds.ProximalPoint`.</span>
</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
<div id="searchbox"></div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
       Copyright 2023, M. Simeoni, S. Kashani, J. Ru-Queralt &amp; Pyxu Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.5.
    <br/>
  </p>
</div>
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>