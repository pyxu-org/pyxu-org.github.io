
<!DOCTYPE html>


<html lang="en" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>typing &#8212; Pyxu Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-codeautolink.css?v=125d5c1c" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css?v=61a4c737" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=1031a718" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script src="../_static/documentation_options.js?v=29481255"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=30646c52"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../_static/design-tabs.js?v=36754332"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/typing';</script>
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  <div class="navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
    
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
    
  </div>
  
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../intro/index.html">
                        Getting Started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../guide/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../examples/index.html">
                        Example Gallery
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../api/index.html">
                        API Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../fair/index.html">
                        Extending Pyxu
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
        </div>
      
      
        <div class="navbar-item"><strong> v0.0.1 </strong></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/matthieumeo/pyxu" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pyxu/" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="mailto: matthieu.simeoni@gmail.com" title="Contact" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-telegram"></i></span>
            <label class="sr-only">Contact</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://imaging.epfl.ch/" title="EPFL Center for Imaging" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../_static/imaging.png" class="icon-link-image" alt="EPFL Center for Imaging"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../intro/index.html">
                        Getting Started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../guide/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../examples/index.html">
                        Example Gallery
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../api/index.html">
                        API Reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../fair/index.html">
                        Extending Pyxu
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><strong> v0.0.1 </strong></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/matthieumeo/pyxu" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/pyxu/" title="PyPI" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-python"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="mailto: matthieu.simeoni@gmail.com" title="Contact" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-telegram"></i></span>
            <label class="sr-only">Contact</label></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://imaging.epfl.ch/" title="EPFL Center for Imaging" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../_static/imaging.png" class="icon-link-image" alt="EPFL Center for Imaging"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumbs">
  <ul class="bd-breadcrumbs" role="navigation" aria-label="Breadcrumb">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">typing</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for typing</h1><div class="highlight"><pre>
<span></span><span class="linenos">   1</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">   2</span><span class="sd">The typing module: Support for gradual typing as defined by PEP 484 and subsequent PEPs.</span>
<span class="linenos">   3</span>
<span class="linenos">   4</span><span class="sd">Among other things, the module includes the following:</span>
<span class="linenos">   5</span><span class="sd">* Generic, Protocol, and internal machinery to support generic aliases.</span>
<span class="linenos">   6</span><span class="sd">  All subscripted types like X[int], Union[int, str] are generic aliases.</span>
<span class="linenos">   7</span><span class="sd">* Various &quot;special forms&quot; that have unique meanings in type annotations:</span>
<span class="linenos">   8</span><span class="sd">  NoReturn, Never, ClassVar, Self, Concatenate, Unpack, and others.</span>
<span class="linenos">   9</span><span class="sd">* Classes whose instances can be type arguments to generic classes and functions:</span>
<span class="linenos">  10</span><span class="sd">  TypeVar, ParamSpec, TypeVarTuple.</span>
<span class="linenos">  11</span><span class="sd">* Public helper functions: get_type_hints, overload, cast, final, and others.</span>
<span class="linenos">  12</span><span class="sd">* Several protocols to support duck-typing:</span>
<span class="linenos">  13</span><span class="sd">  SupportsFloat, SupportsIndex, SupportsAbs, and others.</span>
<span class="linenos">  14</span><span class="sd">* Special types: NewType, NamedTuple, TypedDict.</span>
<span class="linenos">  15</span><span class="sd">* Deprecated wrapper submodules for re and io related types.</span>
<span class="linenos">  16</span><span class="sd">* Deprecated aliases for builtin types and collections.abc ABCs.</span>
<span class="linenos">  17</span>
<span class="linenos">  18</span><span class="sd">Any name not present in __all__ is an implementation detail</span>
<span class="linenos">  19</span><span class="sd">that may be changed without notice. Use at your own risk!</span>
<span class="linenos">  20</span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">  21</span>
<span class="linenos">  22</span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">abstractmethod</span><span class="p">,</span> <span class="n">ABCMeta</span>
<span class="linenos">  23</span><span class="kn">import</span> <span class="nn">collections</span>
<span class="linenos">  24</span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="linenos">  25</span><span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="linenos">  26</span><span class="kn">import</span> <span class="nn">contextlib</span>
<span class="linenos">  27</span><span class="kn">import</span> <span class="nn">functools</span>
<span class="linenos">  28</span><span class="kn">import</span> <span class="nn">operator</span>
<span class="linenos">  29</span><span class="kn">import</span> <span class="nn">re</span> <span class="k">as</span> <span class="nn">stdlib_re</span>  <span class="c1"># Avoid confusion with the re we export.</span>
<span class="linenos">  30</span><span class="kn">import</span> <span class="nn">sys</span>
<span class="linenos">  31</span><span class="kn">import</span> <span class="nn">types</span>
<span class="linenos">  32</span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="linenos">  33</span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">WrapperDescriptorType</span><span class="p">,</span> <span class="n">MethodWrapperType</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">,</span> <span class="n">GenericAlias</span>
<span class="linenos">  34</span>
<span class="linenos">  35</span>
<span class="linenos">  36</span><span class="k">try</span><span class="p">:</span>
<span class="linenos">  37</span>    <span class="kn">from</span> <span class="nn">_typing</span> <span class="kn">import</span> <span class="n">_idfunc</span>
<span class="linenos">  38</span><span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
<span class="linenos">  39</span>    <span class="k">def</span> <span class="nf">_idfunc</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="linenos">  40</span>        <span class="k">return</span> <span class="n">x</span>
<span class="linenos">  41</span>
<span class="linenos">  42</span><span class="c1"># Please keep __all__ alphabetized within each category.</span>
<span class="linenos">  43</span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
<span class="linenos">  44</span>    <span class="c1"># Super-special typing primitives.</span>
<span class="linenos">  45</span>    <span class="s1">&#39;Annotated&#39;</span><span class="p">,</span>
<span class="linenos">  46</span>    <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
<span class="linenos">  47</span>    <span class="s1">&#39;Callable&#39;</span><span class="p">,</span>
<span class="linenos">  48</span>    <span class="s1">&#39;ClassVar&#39;</span><span class="p">,</span>
<span class="linenos">  49</span>    <span class="s1">&#39;Concatenate&#39;</span><span class="p">,</span>
<span class="linenos">  50</span>    <span class="s1">&#39;Final&#39;</span><span class="p">,</span>
<span class="linenos">  51</span>    <span class="s1">&#39;ForwardRef&#39;</span><span class="p">,</span>
<span class="linenos">  52</span>    <span class="s1">&#39;Generic&#39;</span><span class="p">,</span>
<span class="linenos">  53</span>    <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>
<span class="linenos">  54</span>    <span class="s1">&#39;Optional&#39;</span><span class="p">,</span>
<span class="linenos">  55</span>    <span class="s1">&#39;ParamSpec&#39;</span><span class="p">,</span>
<span class="linenos">  56</span>    <span class="s1">&#39;Protocol&#39;</span><span class="p">,</span>
<span class="linenos">  57</span>    <span class="s1">&#39;Tuple&#39;</span><span class="p">,</span>
<span class="linenos">  58</span>    <span class="s1">&#39;Type&#39;</span><span class="p">,</span>
<span class="linenos">  59</span>    <span class="s1">&#39;TypeVar&#39;</span><span class="p">,</span>
<span class="linenos">  60</span>    <span class="s1">&#39;TypeVarTuple&#39;</span><span class="p">,</span>
<span class="linenos">  61</span>    <span class="s1">&#39;Union&#39;</span><span class="p">,</span>
<span class="linenos">  62</span>
<span class="linenos">  63</span>    <span class="c1"># ABCs (from collections.abc).</span>
<span class="linenos">  64</span>    <span class="s1">&#39;AbstractSet&#39;</span><span class="p">,</span>  <span class="c1"># collections.abc.Set.</span>
<span class="linenos">  65</span>    <span class="s1">&#39;ByteString&#39;</span><span class="p">,</span>
<span class="linenos">  66</span>    <span class="s1">&#39;Container&#39;</span><span class="p">,</span>
<span class="linenos">  67</span>    <span class="s1">&#39;ContextManager&#39;</span><span class="p">,</span>
<span class="linenos">  68</span>    <span class="s1">&#39;Hashable&#39;</span><span class="p">,</span>
<span class="linenos">  69</span>    <span class="s1">&#39;ItemsView&#39;</span><span class="p">,</span>
<span class="linenos">  70</span>    <span class="s1">&#39;Iterable&#39;</span><span class="p">,</span>
<span class="linenos">  71</span>    <span class="s1">&#39;Iterator&#39;</span><span class="p">,</span>
<span class="linenos">  72</span>    <span class="s1">&#39;KeysView&#39;</span><span class="p">,</span>
<span class="linenos">  73</span>    <span class="s1">&#39;Mapping&#39;</span><span class="p">,</span>
<span class="linenos">  74</span>    <span class="s1">&#39;MappingView&#39;</span><span class="p">,</span>
<span class="linenos">  75</span>    <span class="s1">&#39;MutableMapping&#39;</span><span class="p">,</span>
<span class="linenos">  76</span>    <span class="s1">&#39;MutableSequence&#39;</span><span class="p">,</span>
<span class="linenos">  77</span>    <span class="s1">&#39;MutableSet&#39;</span><span class="p">,</span>
<span class="linenos">  78</span>    <span class="s1">&#39;Sequence&#39;</span><span class="p">,</span>
<span class="linenos">  79</span>    <span class="s1">&#39;Sized&#39;</span><span class="p">,</span>
<span class="linenos">  80</span>    <span class="s1">&#39;ValuesView&#39;</span><span class="p">,</span>
<span class="linenos">  81</span>    <span class="s1">&#39;Awaitable&#39;</span><span class="p">,</span>
<span class="linenos">  82</span>    <span class="s1">&#39;AsyncIterator&#39;</span><span class="p">,</span>
<span class="linenos">  83</span>    <span class="s1">&#39;AsyncIterable&#39;</span><span class="p">,</span>
<span class="linenos">  84</span>    <span class="s1">&#39;Coroutine&#39;</span><span class="p">,</span>
<span class="linenos">  85</span>    <span class="s1">&#39;Collection&#39;</span><span class="p">,</span>
<span class="linenos">  86</span>    <span class="s1">&#39;AsyncGenerator&#39;</span><span class="p">,</span>
<span class="linenos">  87</span>    <span class="s1">&#39;AsyncContextManager&#39;</span><span class="p">,</span>
<span class="linenos">  88</span>
<span class="linenos">  89</span>    <span class="c1"># Structural checks, a.k.a. protocols.</span>
<span class="linenos">  90</span>    <span class="s1">&#39;Reversible&#39;</span><span class="p">,</span>
<span class="linenos">  91</span>    <span class="s1">&#39;SupportsAbs&#39;</span><span class="p">,</span>
<span class="linenos">  92</span>    <span class="s1">&#39;SupportsBytes&#39;</span><span class="p">,</span>
<span class="linenos">  93</span>    <span class="s1">&#39;SupportsComplex&#39;</span><span class="p">,</span>
<span class="linenos">  94</span>    <span class="s1">&#39;SupportsFloat&#39;</span><span class="p">,</span>
<span class="linenos">  95</span>    <span class="s1">&#39;SupportsIndex&#39;</span><span class="p">,</span>
<span class="linenos">  96</span>    <span class="s1">&#39;SupportsInt&#39;</span><span class="p">,</span>
<span class="linenos">  97</span>    <span class="s1">&#39;SupportsRound&#39;</span><span class="p">,</span>
<span class="linenos">  98</span>
<span class="linenos">  99</span>    <span class="c1"># Concrete collection types.</span>
<span class="linenos"> 100</span>    <span class="s1">&#39;ChainMap&#39;</span><span class="p">,</span>
<span class="linenos"> 101</span>    <span class="s1">&#39;Counter&#39;</span><span class="p">,</span>
<span class="linenos"> 102</span>    <span class="s1">&#39;Deque&#39;</span><span class="p">,</span>
<span class="linenos"> 103</span>    <span class="s1">&#39;Dict&#39;</span><span class="p">,</span>
<span class="linenos"> 104</span>    <span class="s1">&#39;DefaultDict&#39;</span><span class="p">,</span>
<span class="linenos"> 105</span>    <span class="s1">&#39;List&#39;</span><span class="p">,</span>
<span class="linenos"> 106</span>    <span class="s1">&#39;OrderedDict&#39;</span><span class="p">,</span>
<span class="linenos"> 107</span>    <span class="s1">&#39;Set&#39;</span><span class="p">,</span>
<span class="linenos"> 108</span>    <span class="s1">&#39;FrozenSet&#39;</span><span class="p">,</span>
<span class="linenos"> 109</span>    <span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span>  <span class="c1"># Not really a type.</span>
<span class="linenos"> 110</span>    <span class="s1">&#39;TypedDict&#39;</span><span class="p">,</span>  <span class="c1"># Not really a type.</span>
<span class="linenos"> 111</span>    <span class="s1">&#39;Generator&#39;</span><span class="p">,</span>
<span class="linenos"> 112</span>
<span class="linenos"> 113</span>    <span class="c1"># Other concrete types.</span>
<span class="linenos"> 114</span>    <span class="s1">&#39;BinaryIO&#39;</span><span class="p">,</span>
<span class="linenos"> 115</span>    <span class="s1">&#39;IO&#39;</span><span class="p">,</span>
<span class="linenos"> 116</span>    <span class="s1">&#39;Match&#39;</span><span class="p">,</span>
<span class="linenos"> 117</span>    <span class="s1">&#39;Pattern&#39;</span><span class="p">,</span>
<span class="linenos"> 118</span>    <span class="s1">&#39;TextIO&#39;</span><span class="p">,</span>
<span class="linenos"> 119</span>
<span class="linenos"> 120</span>    <span class="c1"># One-off things.</span>
<span class="linenos"> 121</span>    <span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span>
<span class="linenos"> 122</span>    <span class="s1">&#39;assert_type&#39;</span><span class="p">,</span>
<span class="linenos"> 123</span>    <span class="s1">&#39;assert_never&#39;</span><span class="p">,</span>
<span class="linenos"> 124</span>    <span class="s1">&#39;cast&#39;</span><span class="p">,</span>
<span class="linenos"> 125</span>    <span class="s1">&#39;clear_overloads&#39;</span><span class="p">,</span>
<span class="linenos"> 126</span>    <span class="s1">&#39;dataclass_transform&#39;</span><span class="p">,</span>
<span class="linenos"> 127</span>    <span class="s1">&#39;final&#39;</span><span class="p">,</span>
<span class="linenos"> 128</span>    <span class="s1">&#39;get_args&#39;</span><span class="p">,</span>
<span class="linenos"> 129</span>    <span class="s1">&#39;get_origin&#39;</span><span class="p">,</span>
<span class="linenos"> 130</span>    <span class="s1">&#39;get_overloads&#39;</span><span class="p">,</span>
<span class="linenos"> 131</span>    <span class="s1">&#39;get_type_hints&#39;</span><span class="p">,</span>
<span class="linenos"> 132</span>    <span class="s1">&#39;is_typeddict&#39;</span><span class="p">,</span>
<span class="linenos"> 133</span>    <span class="s1">&#39;LiteralString&#39;</span><span class="p">,</span>
<span class="linenos"> 134</span>    <span class="s1">&#39;Never&#39;</span><span class="p">,</span>
<span class="linenos"> 135</span>    <span class="s1">&#39;NewType&#39;</span><span class="p">,</span>
<span class="linenos"> 136</span>    <span class="s1">&#39;no_type_check&#39;</span><span class="p">,</span>
<span class="linenos"> 137</span>    <span class="s1">&#39;no_type_check_decorator&#39;</span><span class="p">,</span>
<span class="linenos"> 138</span>    <span class="s1">&#39;NoReturn&#39;</span><span class="p">,</span>
<span class="linenos"> 139</span>    <span class="s1">&#39;NotRequired&#39;</span><span class="p">,</span>
<span class="linenos"> 140</span>    <span class="s1">&#39;overload&#39;</span><span class="p">,</span>
<span class="linenos"> 141</span>    <span class="s1">&#39;ParamSpecArgs&#39;</span><span class="p">,</span>
<span class="linenos"> 142</span>    <span class="s1">&#39;ParamSpecKwargs&#39;</span><span class="p">,</span>
<span class="linenos"> 143</span>    <span class="s1">&#39;Required&#39;</span><span class="p">,</span>
<span class="linenos"> 144</span>    <span class="s1">&#39;reveal_type&#39;</span><span class="p">,</span>
<span class="linenos"> 145</span>    <span class="s1">&#39;runtime_checkable&#39;</span><span class="p">,</span>
<span class="linenos"> 146</span>    <span class="s1">&#39;Self&#39;</span><span class="p">,</span>
<span class="linenos"> 147</span>    <span class="s1">&#39;Text&#39;</span><span class="p">,</span>
<span class="linenos"> 148</span>    <span class="s1">&#39;TYPE_CHECKING&#39;</span><span class="p">,</span>
<span class="linenos"> 149</span>    <span class="s1">&#39;TypeAlias&#39;</span><span class="p">,</span>
<span class="linenos"> 150</span>    <span class="s1">&#39;TypeGuard&#39;</span><span class="p">,</span>
<span class="linenos"> 151</span>    <span class="s1">&#39;Unpack&#39;</span><span class="p">,</span>
<span class="linenos"> 152</span><span class="p">]</span>
<span class="linenos"> 153</span>
<span class="linenos"> 154</span><span class="c1"># The pseudo-submodules &#39;re&#39; and &#39;io&#39; are part of the public</span>
<span class="linenos"> 155</span><span class="c1"># namespace, but excluded from __all__ because they might stomp on</span>
<span class="linenos"> 156</span><span class="c1"># legitimate imports of those modules.</span>
<span class="linenos"> 157</span>
<span class="linenos"> 158</span>
<span class="linenos"> 159</span><span class="k">def</span> <span class="nf">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos"> 160</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;For converting None to type(None), and strings to ForwardRef.&quot;&quot;&quot;</span>
<span class="linenos"> 161</span>    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 162</span>        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="linenos"> 163</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
<span class="linenos"> 164</span>        <span class="k">return</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="n">allow_special_forms</span><span class="p">)</span>
<span class="linenos"> 165</span>    <span class="k">return</span> <span class="n">arg</span>
<span class="linenos"> 166</span>
<span class="linenos"> 167</span>
<span class="linenos"> 168</span><span class="k">def</span> <span class="nf">_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos"> 169</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that the argument is a type, and return it (internal helper).</span>
<span class="linenos"> 170</span>
<span class="linenos"> 171</span><span class="sd">    As a special case, accept None and return type(None) instead. Also wrap strings</span>
<span class="linenos"> 172</span><span class="sd">    into ForwardRef instances. Consider several corner cases, for example plain</span>
<span class="linenos"> 173</span><span class="sd">    special forms like Union are not valid, while Union[int, str] is OK, etc.</span>
<span class="linenos"> 174</span><span class="sd">    The msg argument is a human-readable error message, e.g.::</span>
<span class="linenos"> 175</span>
<span class="linenos"> 176</span><span class="sd">        &quot;Union[arg, ...]: arg should be a type.&quot;</span>
<span class="linenos"> 177</span>
<span class="linenos"> 178</span><span class="sd">    We append the repr() of the actual value (truncated to 100 chars).</span>
<span class="linenos"> 179</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 180</span>    <span class="n">invalid_generic_forms</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">)</span>
<span class="linenos"> 181</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_special_forms</span><span class="p">:</span>
<span class="linenos"> 182</span>        <span class="n">invalid_generic_forms</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ClassVar</span><span class="p">,)</span>
<span class="linenos"> 183</span>        <span class="k">if</span> <span class="n">is_argument</span><span class="p">:</span>
<span class="linenos"> 184</span>            <span class="n">invalid_generic_forms</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Final</span><span class="p">,)</span>
<span class="linenos"> 185</span>
<span class="linenos"> 186</span>    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="n">allow_special_forms</span><span class="p">)</span>
<span class="linenos"> 187</span>    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span>
<span class="linenos"> 188</span>            <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="n">invalid_generic_forms</span><span class="p">):</span>
<span class="linenos"> 189</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
<span class="linenos"> 190</span>    <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">LiteralString</span><span class="p">,</span> <span class="n">NoReturn</span><span class="p">,</span> <span class="n">Never</span><span class="p">,</span> <span class="n">Self</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">):</span>
<span class="linenos"> 191</span>        <span class="k">return</span> <span class="n">arg</span>
<span class="linenos"> 192</span>    <span class="k">if</span> <span class="n">allow_special_forms</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ClassVar</span><span class="p">,</span> <span class="n">Final</span><span class="p">):</span>
<span class="linenos"> 193</span>        <span class="k">return</span> <span class="n">arg</span>
<span class="linenos"> 194</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_SpecialForm</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
<span class="linenos"> 195</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plain </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
<span class="linenos"> 196</span>    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="linenos"> 197</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2"> Got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r:</span><span class="s2">.100</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="linenos"> 198</span>    <span class="k">return</span> <span class="n">arg</span>
<span class="linenos"> 199</span>
<span class="linenos"> 200</span>
<span class="linenos"> 201</span><span class="k">def</span> <span class="nf">_is_param_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="linenos"> 202</span>    <span class="k">return</span> <span class="n">arg</span> <span class="ow">is</span> <span class="o">...</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span>
<span class="linenos"> 203</span>            <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">))</span>
<span class="linenos"> 204</span>
<span class="linenos"> 205</span>
<span class="linenos"> 206</span><span class="k">def</span> <span class="nf">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos"> 207</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for munging collections.abc.Callable&#39;s __args__.</span>
<span class="linenos"> 208</span>
<span class="linenos"> 209</span><span class="sd">    The canonical representation for a Callable&#39;s __args__ flattens the</span>
<span class="linenos"> 210</span><span class="sd">    argument types, see https://github.com/python/cpython/issues/86361.</span>
<span class="linenos"> 211</span>
<span class="linenos"> 212</span><span class="sd">    For example::</span>
<span class="linenos"> 213</span>
<span class="linenos"> 214</span><span class="sd">        assert collections.abc.Callable[[int, int], str].__args__ == (int, int, str)</span>
<span class="linenos"> 215</span><span class="sd">        assert collections.abc.Callable[ParamSpec, str].__args__ == (ParamSpec, str)</span>
<span class="linenos"> 216</span>
<span class="linenos"> 217</span><span class="sd">    As a result, if we need to reconstruct the Callable from its __args__,</span>
<span class="linenos"> 218</span><span class="sd">    we need to unflatten it.</span>
<span class="linenos"> 219</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 220</span>    <span class="k">return</span> <span class="p">(</span>
<span class="linenos"> 221</span>        <span class="n">typ</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span>
<span class="linenos"> 222</span>        <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="linenos"> 223</span>    <span class="p">)</span>
<span class="linenos"> 224</span>
<span class="linenos"> 225</span>
<span class="linenos"> 226</span><span class="k">def</span> <span class="nf">_type_repr</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="linenos"> 227</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the repr() of an object, special-casing types (internal helper).</span>
<span class="linenos"> 228</span>
<span class="linenos"> 229</span><span class="sd">    If obj is a type, we return a shorter version than the default</span>
<span class="linenos"> 230</span><span class="sd">    type.__repr__, based on the module and qualified name, which is</span>
<span class="linenos"> 231</span><span class="sd">    typically enough to uniquely identify a type.  For everything</span>
<span class="linenos"> 232</span><span class="sd">    else, we fall back on repr(obj).</span>
<span class="linenos"> 233</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 234</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GenericAlias</span><span class="p">):</span>
<span class="linenos"> 235</span>        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="linenos"> 236</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos"> 237</span>        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
<span class="linenos"> 238</span>            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="linenos"> 239</span>        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="linenos"> 240</span>    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
<span class="linenos"> 241</span>        <span class="k">return</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
<span class="linenos"> 242</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
<span class="linenos"> 243</span>        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos"> 244</span>    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="linenos"> 245</span>
<span class="linenos"> 246</span>
<span class="linenos"> 247</span><span class="k">def</span> <span class="nf">_collect_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="linenos"> 248</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect all type variables and parameter specifications in args</span>
<span class="linenos"> 249</span><span class="sd">    in order of first appearance (lexicographic order).</span>
<span class="linenos"> 250</span>
<span class="linenos"> 251</span><span class="sd">    For example::</span>
<span class="linenos"> 252</span>
<span class="linenos"> 253</span><span class="sd">        assert _collect_parameters((T, Callable[P, T])) == (T, P)</span>
<span class="linenos"> 254</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 255</span>    <span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 256</span>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="linenos"> 257</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos"> 258</span>            <span class="c1"># We don&#39;t want __parameters__ descriptor of a bare Python class.</span>
<span class="linenos"> 259</span>            <span class="k">pass</span>
<span class="linenos"> 260</span>        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos"> 261</span>            <span class="c1"># `t` might be a tuple, when `ParamSpec` is substituted with</span>
<span class="linenos"> 262</span>            <span class="c1"># `[T, int]`, or `[int, *Ts]`, etc.</span>
<span class="linenos"> 263</span>            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
<span class="linenos"> 264</span>                <span class="k">for</span> <span class="n">collected</span> <span class="ow">in</span> <span class="n">_collect_parameters</span><span class="p">([</span><span class="n">x</span><span class="p">]):</span>
<span class="linenos"> 265</span>                    <span class="k">if</span> <span class="n">collected</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
<span class="linenos"> 266</span>                        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collected</span><span class="p">)</span>
<span class="linenos"> 267</span>        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;__typing_subst__&#39;</span><span class="p">):</span>
<span class="linenos"> 268</span>            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
<span class="linenos"> 269</span>                <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="linenos"> 270</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 271</span>            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="p">()):</span>
<span class="linenos"> 272</span>                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
<span class="linenos"> 273</span>                    <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="linenos"> 274</span>    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 275</span>
<span class="linenos"> 276</span>
<span class="linenos"> 277</span><span class="k">def</span> <span class="nf">_check_generic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">elen</span><span class="p">):</span>
<span class="linenos"> 278</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper).</span>
<span class="linenos"> 279</span>
<span class="linenos"> 280</span><span class="sd">    This gives a nice error message in case of count mismatch.</span>
<span class="linenos"> 281</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 282</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">elen</span><span class="p">:</span>
<span class="linenos"> 283</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> is not a generic class&quot;</span><span class="p">)</span>
<span class="linenos"> 284</span>    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 285</span>    <span class="k">if</span> <span class="n">alen</span> <span class="o">!=</span> <span class="n">elen</span><span class="p">:</span>
<span class="linenos"> 286</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too </span><span class="si">{</span><span class="s1">&#39;many&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">alen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">elen</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;few&#39;</span><span class="si">}</span><span class="s2"> arguments for </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">;&quot;</span>
<span class="linenos"> 287</span>                        <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">elen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos"> 288</span>
<span class="linenos"> 289</span><span class="k">def</span> <span class="nf">_unpack_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="linenos"> 290</span>    <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 291</span>    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="linenos"> 292</span>        <span class="n">subargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__typing_unpacked_tuple_args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos"> 293</span>        <span class="k">if</span> <span class="n">subargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subargs</span> <span class="ow">and</span> <span class="n">subargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">):</span>
<span class="linenos"> 294</span>            <span class="n">newargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subargs</span><span class="p">)</span>
<span class="linenos"> 295</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 296</span>            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="linenos"> 297</span>    <span class="k">return</span> <span class="n">newargs</span>
<span class="linenos"> 298</span>
<span class="linenos"> 299</span><span class="k">def</span> <span class="nf">_deduplicate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="linenos"> 300</span>    <span class="c1"># Weed out strict duplicates, preserving the first of each occurrence.</span>
<span class="linenos"> 301</span>    <span class="n">all_params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos"> 302</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="linenos"> 303</span>        <span class="n">new_params</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 304</span>        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
<span class="linenos"> 305</span>            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">all_params</span><span class="p">:</span>
<span class="linenos"> 306</span>                <span class="n">new_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="linenos"> 307</span>                <span class="n">all_params</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="linenos"> 308</span>        <span class="n">params</span> <span class="o">=</span> <span class="n">new_params</span>
<span class="linenos"> 309</span>        <span class="k">assert</span> <span class="ow">not</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">all_params</span>
<span class="linenos"> 310</span>    <span class="k">return</span> <span class="n">params</span>
<span class="linenos"> 311</span>
<span class="linenos"> 312</span>
<span class="linenos"> 313</span><span class="k">def</span> <span class="nf">_remove_dups_flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 314</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for Union creation and substitution.</span>
<span class="linenos"> 315</span>
<span class="linenos"> 316</span><span class="sd">    Flatten Unions among parameters, then remove duplicates.</span>
<span class="linenos"> 317</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 318</span>    <span class="c1"># Flatten out Union[Union[...], ...].</span>
<span class="linenos"> 319</span>    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 320</span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
<span class="linenos"> 321</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">_UnionGenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
<span class="linenos"> 322</span>            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos"> 323</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 324</span>            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="linenos"> 325</span>
<span class="linenos"> 326</span>    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_deduplicate</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>
<span class="linenos"> 327</span>
<span class="linenos"> 328</span>
<span class="linenos"> 329</span><span class="k">def</span> <span class="nf">_flatten_literal_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 330</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for Literal creation: flatten Literals among parameters.&quot;&quot;&quot;</span>
<span class="linenos"> 331</span>    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 332</span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
<span class="linenos"> 333</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_LiteralGenericAlias</span><span class="p">):</span>
<span class="linenos"> 334</span>            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos"> 335</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 336</span>            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="linenos"> 337</span>    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos"> 338</span>
<span class="linenos"> 339</span>
<span class="linenos"> 340</span><span class="n">_cleanups</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos"> 341</span>
<span class="linenos"> 342</span>
<span class="linenos"> 343</span><span class="k">def</span> <span class="nf">_tp_cache</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos"> 344</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal wrapper caching __getitem__ of generic types.</span>
<span class="linenos"> 345</span>
<span class="linenos"> 346</span><span class="sd">    For non-hashable arguments, the original function is used as a fallback.</span>
<span class="linenos"> 347</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 348</span>    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="linenos"> 349</span>        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="n">typed</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
<span class="linenos"> 350</span>        <span class="n">_cleanups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cached</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">)</span>
<span class="linenos"> 351</span>
<span class="linenos"> 352</span>        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="linenos"> 353</span>        <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="linenos"> 354</span>            <span class="k">try</span><span class="p">:</span>
<span class="linenos"> 355</span>                <span class="k">return</span> <span class="n">cached</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos"> 356</span>            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
<span class="linenos"> 357</span>                <span class="k">pass</span>  <span class="c1"># All real errors (not unhashable args) are raised below.</span>
<span class="linenos"> 358</span>            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos"> 359</span>        <span class="k">return</span> <span class="n">inner</span>
<span class="linenos"> 360</span>
<span class="linenos"> 361</span>    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 362</span>        <span class="k">return</span> <span class="n">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="linenos"> 363</span>
<span class="linenos"> 364</span>    <span class="k">return</span> <span class="n">decorator</span>
<span class="linenos"> 365</span>
<span class="linenos"> 366</span><span class="k">def</span> <span class="nf">_eval_type</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()):</span>
<span class="linenos"> 367</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate all forward references in the given type t.</span>
<span class="linenos"> 368</span>
<span class="linenos"> 369</span><span class="sd">    For use of globalns and localns see the docstring for get_type_hints().</span>
<span class="linenos"> 370</span><span class="sd">    recursive_guard is used to prevent infinite recursion with a recursive</span>
<span class="linenos"> 371</span><span class="sd">    ForwardRef.</span>
<span class="linenos"> 372</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 373</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">):</span>
<span class="linenos"> 374</span>        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">)</span>
<span class="linenos"> 375</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
<span class="linenos"> 376</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
<span class="linenos"> 377</span>            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
<span class="linenos"> 378</span>                <span class="n">ForwardRef</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span>
<span class="linenos"> 379</span>                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos"> 380</span>            <span class="p">)</span>
<span class="linenos"> 381</span>            <span class="n">is_unpacked</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__unpacked__</span>
<span class="linenos"> 382</span>            <span class="k">if</span> <span class="n">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos"> 383</span>                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">[(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
<span class="linenos"> 384</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 385</span>                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
<span class="linenos"> 386</span>            <span class="k">if</span> <span class="n">is_unpacked</span><span class="p">:</span>
<span class="linenos"> 387</span>                <span class="n">t</span> <span class="o">=</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="linenos"> 388</span>        <span class="n">ev_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_eval_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos"> 389</span>        <span class="k">if</span> <span class="n">ev_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
<span class="linenos"> 390</span>            <span class="k">return</span> <span class="n">t</span>
<span class="linenos"> 391</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
<span class="linenos"> 392</span>            <span class="k">return</span> <span class="n">GenericAlias</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">ev_args</span><span class="p">)</span>
<span class="linenos"> 393</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
<span class="linenos"> 394</span>            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">ev_args</span><span class="p">)</span>
<span class="linenos"> 395</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 396</span>            <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">ev_args</span><span class="p">)</span>
<span class="linenos"> 397</span>    <span class="k">return</span> <span class="n">t</span>
<span class="linenos"> 398</span>
<span class="linenos"> 399</span>
<span class="linenos"> 400</span><span class="k">class</span> <span class="nc">_Final</span><span class="p">:</span>
<span class="linenos"> 401</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to prohibit subclassing.&quot;&quot;&quot;</span>
<span class="linenos"> 402</span>
<span class="linenos"> 403</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__weakref__&#39;</span><span class="p">,)</span>
<span class="linenos"> 404</span>
<span class="linenos"> 405</span>    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="linenos"> 406</span>        <span class="k">if</span> <span class="s1">&#39;_root&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
<span class="linenos"> 407</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot subclass special typing classes&quot;</span><span class="p">)</span>
<span class="linenos"> 408</span>
<span class="linenos"> 409</span><span class="k">class</span> <span class="nc">_Immutable</span><span class="p">:</span>
<span class="linenos"> 410</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>
<span class="linenos"> 411</span>
<span class="linenos"> 412</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos"> 413</span>
<span class="linenos"> 414</span>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 415</span>        <span class="k">return</span> <span class="bp">self</span>
<span class="linenos"> 416</span>
<span class="linenos"> 417</span>    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="linenos"> 418</span>        <span class="k">return</span> <span class="bp">self</span>
<span class="linenos"> 419</span>
<span class="linenos"> 420</span>
<span class="linenos"> 421</span><span class="k">class</span> <span class="nc">_NotIterable</span><span class="p">:</span>
<span class="linenos"> 422</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to prevent iteration, without being compatible with Iterable.</span>
<span class="linenos"> 423</span>
<span class="linenos"> 424</span><span class="sd">    That is, we could do::</span>
<span class="linenos"> 425</span>
<span class="linenos"> 426</span><span class="sd">        def __iter__(self): raise TypeError()</span>
<span class="linenos"> 427</span>
<span class="linenos"> 428</span><span class="sd">    But this would make users of this mixin duck type-compatible with</span>
<span class="linenos"> 429</span><span class="sd">    collections.abc.Iterable - isinstance(foo, Iterable) would be True.</span>
<span class="linenos"> 430</span>
<span class="linenos"> 431</span><span class="sd">    Luckily, we can instead prevent iteration by setting __iter__ to None, which</span>
<span class="linenos"> 432</span><span class="sd">    is treated specially.</span>
<span class="linenos"> 433</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 434</span>
<span class="linenos"> 435</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos"> 436</span>    <span class="fm">__iter__</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos"> 437</span>
<span class="linenos"> 438</span>
<span class="linenos"> 439</span><span class="c1"># Internal indicator of special typing constructs.</span>
<span class="linenos"> 440</span><span class="c1"># See __doc__ instance attribute for specific docs.</span>
<span class="linenos"> 441</span><span class="k">class</span> <span class="nc">_SpecialForm</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos"> 442</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;_getitem&#39;</span><span class="p">)</span>
<span class="linenos"> 443</span>
<span class="linenos"> 444</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getitem</span><span class="p">):</span>
<span class="linenos"> 445</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span> <span class="o">=</span> <span class="n">getitem</span>
<span class="linenos"> 446</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">getitem</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos"> 447</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">getitem</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="linenos"> 448</span>
<span class="linenos"> 449</span>    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="linenos"> 450</span>        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
<span class="linenos"> 451</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
<span class="linenos"> 452</span>
<span class="linenos"> 453</span>        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="linenos"> 454</span>
<span class="linenos"> 455</span>    <span class="k">def</span> <span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
<span class="linenos"> 456</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subclass </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos"> 457</span>
<span class="linenos"> 458</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 459</span>        <span class="k">return</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
<span class="linenos"> 460</span>
<span class="linenos"> 461</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 462</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
<span class="linenos"> 463</span>
<span class="linenos"> 464</span>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="linenos"> 465</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot instantiate </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos"> 466</span>
<span class="linenos"> 467</span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 468</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
<span class="linenos"> 469</span>
<span class="linenos"> 470</span>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 471</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
<span class="linenos"> 472</span>
<span class="linenos"> 473</span>    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="linenos"> 474</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> cannot be used with isinstance()&quot;</span><span class="p">)</span>
<span class="linenos"> 475</span>
<span class="linenos"> 476</span>    <span class="k">def</span> <span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="linenos"> 477</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> cannot be used with issubclass()&quot;</span><span class="p">)</span>
<span class="linenos"> 478</span>
<span class="linenos"> 479</span>    <span class="nd">@_tp_cache</span>
<span class="linenos"> 480</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 481</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 482</span>
<span class="linenos"> 483</span>
<span class="linenos"> 484</span><span class="k">class</span> <span class="nc">_LiteralSpecialForm</span><span class="p">(</span><span class="n">_SpecialForm</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos"> 485</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 486</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos"> 487</span>            <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
<span class="linenos"> 488</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 489</span>
<span class="linenos"> 490</span>
<span class="linenos"> 491</span><span class="k">class</span> <span class="nc">_AnyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="linenos"> 492</span>    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="linenos"> 493</span>        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
<span class="linenos"> 494</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;typing.Any cannot be used with isinstance()&quot;</span><span class="p">)</span>
<span class="linenos"> 495</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="linenos"> 496</span>
<span class="linenos"> 497</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 498</span>        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
<span class="linenos"> 499</span>            <span class="k">return</span> <span class="s2">&quot;typing.Any&quot;</span>
<span class="linenos"> 500</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>  <span class="c1"># respect to subclasses</span>
<span class="linenos"> 501</span>
<span class="linenos"> 502</span>
<span class="linenos"> 503</span><span class="k">class</span> <span class="nc">Any</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_AnyMeta</span><span class="p">):</span>
<span class="linenos"> 504</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type indicating an unconstrained type.</span>
<span class="linenos"> 505</span>
<span class="linenos"> 506</span><span class="sd">    - Any is compatible with every type.</span>
<span class="linenos"> 507</span><span class="sd">    - Any assumed to have all methods.</span>
<span class="linenos"> 508</span><span class="sd">    - All values assumed to be instances of Any.</span>
<span class="linenos"> 509</span>
<span class="linenos"> 510</span><span class="sd">    Note that all the above statements are true from the point of view of</span>
<span class="linenos"> 511</span><span class="sd">    static type checkers. At runtime, Any should not be used with instance</span>
<span class="linenos"> 512</span><span class="sd">    checks.</span>
<span class="linenos"> 513</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 514</span>
<span class="linenos"> 515</span>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos"> 516</span>        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
<span class="linenos"> 517</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Any cannot be instantiated&quot;</span><span class="p">)</span>
<span class="linenos"> 518</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos"> 519</span>
<span class="linenos"> 520</span>
<span class="linenos"> 521</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 522</span><span class="k">def</span> <span class="nf">NoReturn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 523</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type indicating functions that never return.</span>
<span class="linenos"> 524</span>
<span class="linenos"> 525</span><span class="sd">    Example::</span>
<span class="linenos"> 526</span>
<span class="linenos"> 527</span><span class="sd">        from typing import NoReturn</span>
<span class="linenos"> 528</span>
<span class="linenos"> 529</span><span class="sd">        def stop() -&gt; NoReturn:</span>
<span class="linenos"> 530</span><span class="sd">            raise Exception(&#39;no way&#39;)</span>
<span class="linenos"> 531</span>
<span class="linenos"> 532</span><span class="sd">    NoReturn can also be used as a bottom type, a type that</span>
<span class="linenos"> 533</span><span class="sd">    has no values. Starting in Python 3.11, the Never type should</span>
<span class="linenos"> 534</span><span class="sd">    be used for this concept instead. Type checkers should treat the two</span>
<span class="linenos"> 535</span><span class="sd">    equivalently.</span>
<span class="linenos"> 536</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 537</span>    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
<span class="linenos"> 538</span>
<span class="linenos"> 539</span><span class="c1"># This is semantically identical to NoReturn, but it is implemented</span>
<span class="linenos"> 540</span><span class="c1"># separately so that type checkers can distinguish between the two</span>
<span class="linenos"> 541</span><span class="c1"># if they want.</span>
<span class="linenos"> 542</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 543</span><span class="k">def</span> <span class="nf">Never</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 544</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;The bottom type, a type that has no members.</span>
<span class="linenos"> 545</span>
<span class="linenos"> 546</span><span class="sd">    This can be used to define a function that should never be</span>
<span class="linenos"> 547</span><span class="sd">    called, or a function that never returns::</span>
<span class="linenos"> 548</span>
<span class="linenos"> 549</span><span class="sd">        from typing import Never</span>
<span class="linenos"> 550</span>
<span class="linenos"> 551</span><span class="sd">        def never_call_me(arg: Never) -&gt; None:</span>
<span class="linenos"> 552</span><span class="sd">            pass</span>
<span class="linenos"> 553</span>
<span class="linenos"> 554</span><span class="sd">        def int_or_str(arg: int | str) -&gt; None:</span>
<span class="linenos"> 555</span><span class="sd">            never_call_me(arg)  # type checker error</span>
<span class="linenos"> 556</span><span class="sd">            match arg:</span>
<span class="linenos"> 557</span><span class="sd">                case int():</span>
<span class="linenos"> 558</span><span class="sd">                    print(&quot;It&#39;s an int&quot;)</span>
<span class="linenos"> 559</span><span class="sd">                case str():</span>
<span class="linenos"> 560</span><span class="sd">                    print(&quot;It&#39;s a str&quot;)</span>
<span class="linenos"> 561</span><span class="sd">                case _:</span>
<span class="linenos"> 562</span><span class="sd">                    never_call_me(arg)  # OK, arg is of type Never</span>
<span class="linenos"> 563</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 564</span>    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
<span class="linenos"> 565</span>
<span class="linenos"> 566</span>
<span class="linenos"> 567</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 568</span><span class="k">def</span> <span class="nf">Self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 569</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes.</span>
<span class="linenos"> 570</span>
<span class="linenos"> 571</span><span class="sd">    Example::</span>
<span class="linenos"> 572</span>
<span class="linenos"> 573</span><span class="sd">        from typing import Self</span>
<span class="linenos"> 574</span>
<span class="linenos"> 575</span><span class="sd">        class Foo:</span>
<span class="linenos"> 576</span><span class="sd">            def return_self(self) -&gt; Self:</span>
<span class="linenos"> 577</span><span class="sd">                ...</span>
<span class="linenos"> 578</span><span class="sd">                return self</span>
<span class="linenos"> 579</span>
<span class="linenos"> 580</span><span class="sd">    This is especially useful for:</span>
<span class="linenos"> 581</span><span class="sd">        - classmethods that are used as alternative constructors</span>
<span class="linenos"> 582</span><span class="sd">        - annotating an `__enter__` method which returns self</span>
<span class="linenos"> 583</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 584</span>    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
<span class="linenos"> 585</span>
<span class="linenos"> 586</span>
<span class="linenos"> 587</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 588</span><span class="k">def</span> <span class="nf">LiteralString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 589</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an arbitrary literal string.</span>
<span class="linenos"> 590</span>
<span class="linenos"> 591</span><span class="sd">    Example::</span>
<span class="linenos"> 592</span>
<span class="linenos"> 593</span><span class="sd">        from typing import LiteralString</span>
<span class="linenos"> 594</span>
<span class="linenos"> 595</span><span class="sd">        def run_query(sql: LiteralString) -&gt; None:</span>
<span class="linenos"> 596</span><span class="sd">            ...</span>
<span class="linenos"> 597</span>
<span class="linenos"> 598</span><span class="sd">        def caller(arbitrary_string: str, literal_string: LiteralString) -&gt; None:</span>
<span class="linenos"> 599</span><span class="sd">            run_query(&quot;SELECT * FROM students&quot;)  # OK</span>
<span class="linenos"> 600</span><span class="sd">            run_query(literal_string)  # OK</span>
<span class="linenos"> 601</span><span class="sd">            run_query(&quot;SELECT * FROM &quot; + literal_string)  # OK</span>
<span class="linenos"> 602</span><span class="sd">            run_query(arbitrary_string)  # type checker error</span>
<span class="linenos"> 603</span><span class="sd">            run_query(  # type checker error</span>
<span class="linenos"> 604</span><span class="sd">                f&quot;SELECT * FROM students WHERE name = {arbitrary_string}&quot;</span>
<span class="linenos"> 605</span><span class="sd">            )</span>
<span class="linenos"> 606</span>
<span class="linenos"> 607</span><span class="sd">    Only string literals and other LiteralStrings are compatible</span>
<span class="linenos"> 608</span><span class="sd">    with LiteralString. This provides a tool to help prevent</span>
<span class="linenos"> 609</span><span class="sd">    security issues such as SQL injection.</span>
<span class="linenos"> 610</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 611</span>    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
<span class="linenos"> 612</span>
<span class="linenos"> 613</span>
<span class="linenos"> 614</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 615</span><span class="k">def</span> <span class="nf">ClassVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 616</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type construct to mark class variables.</span>
<span class="linenos"> 617</span>
<span class="linenos"> 618</span><span class="sd">    An annotation wrapped in ClassVar indicates that a given</span>
<span class="linenos"> 619</span><span class="sd">    attribute is intended to be used as a class variable and</span>
<span class="linenos"> 620</span><span class="sd">    should not be set on instances of that class.</span>
<span class="linenos"> 621</span>
<span class="linenos"> 622</span><span class="sd">    Usage::</span>
<span class="linenos"> 623</span>
<span class="linenos"> 624</span><span class="sd">        class Starship:</span>
<span class="linenos"> 625</span><span class="sd">            stats: ClassVar[dict[str, int]] = {} # class variable</span>
<span class="linenos"> 626</span><span class="sd">            damage: int = 10                     # instance variable</span>
<span class="linenos"> 627</span>
<span class="linenos"> 628</span><span class="sd">    ClassVar accepts only types and cannot be further subscribed.</span>
<span class="linenos"> 629</span>
<span class="linenos"> 630</span><span class="sd">    Note that ClassVar is not a class itself, and should not</span>
<span class="linenos"> 631</span><span class="sd">    be used with isinstance() or issubclass().</span>
<span class="linenos"> 632</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 633</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
<span class="linenos"> 634</span>    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
<span class="linenos"> 635</span>
<span class="linenos"> 636</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 637</span><span class="k">def</span> <span class="nf">Final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 638</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to indicate final names to type checkers.</span>
<span class="linenos"> 639</span>
<span class="linenos"> 640</span><span class="sd">    A final name cannot be re-assigned or overridden in a subclass.</span>
<span class="linenos"> 641</span>
<span class="linenos"> 642</span><span class="sd">    For example::</span>
<span class="linenos"> 643</span>
<span class="linenos"> 644</span><span class="sd">        MAX_SIZE: Final = 9000</span>
<span class="linenos"> 645</span><span class="sd">        MAX_SIZE += 1  # Error reported by type checker</span>
<span class="linenos"> 646</span>
<span class="linenos"> 647</span><span class="sd">        class Connection:</span>
<span class="linenos"> 648</span><span class="sd">            TIMEOUT: Final[int] = 10</span>
<span class="linenos"> 649</span>
<span class="linenos"> 650</span><span class="sd">        class FastConnector(Connection):</span>
<span class="linenos"> 651</span><span class="sd">            TIMEOUT = 1  # Error reported by type checker</span>
<span class="linenos"> 652</span>
<span class="linenos"> 653</span><span class="sd">    There is no runtime checking of these properties.</span>
<span class="linenos"> 654</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 655</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
<span class="linenos"> 656</span>    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
<span class="linenos"> 657</span>
<span class="linenos"> 658</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 659</span><span class="k">def</span> <span class="nf">Union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 660</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Union type; Union[X, Y] means either X or Y.</span>
<span class="linenos"> 661</span>
<span class="linenos"> 662</span><span class="sd">    On Python 3.10 and higher, the | operator</span>
<span class="linenos"> 663</span><span class="sd">    can also be used to denote unions;</span>
<span class="linenos"> 664</span><span class="sd">    X | Y means the same thing to the type checker as Union[X, Y].</span>
<span class="linenos"> 665</span>
<span class="linenos"> 666</span><span class="sd">    To define a union, use e.g. Union[int, str]. Details:</span>
<span class="linenos"> 667</span><span class="sd">    - The arguments must be types and there must be at least one.</span>
<span class="linenos"> 668</span><span class="sd">    - None as an argument is a special case and is replaced by</span>
<span class="linenos"> 669</span><span class="sd">      type(None).</span>
<span class="linenos"> 670</span><span class="sd">    - Unions of unions are flattened, e.g.::</span>
<span class="linenos"> 671</span>
<span class="linenos"> 672</span><span class="sd">        assert Union[Union[int, str], float] == Union[int, str, float]</span>
<span class="linenos"> 673</span>
<span class="linenos"> 674</span><span class="sd">    - Unions of a single argument vanish, e.g.::</span>
<span class="linenos"> 675</span>
<span class="linenos"> 676</span><span class="sd">        assert Union[int] == int  # The constructor actually returns int</span>
<span class="linenos"> 677</span>
<span class="linenos"> 678</span><span class="sd">    - Redundant arguments are skipped, e.g.::</span>
<span class="linenos"> 679</span>
<span class="linenos"> 680</span><span class="sd">        assert Union[int, str, int] == Union[int, str]</span>
<span class="linenos"> 681</span>
<span class="linenos"> 682</span><span class="sd">    - When comparing unions, the argument order is ignored, e.g.::</span>
<span class="linenos"> 683</span>
<span class="linenos"> 684</span><span class="sd">        assert Union[int, str] == Union[str, int]</span>
<span class="linenos"> 685</span>
<span class="linenos"> 686</span><span class="sd">    - You cannot subclass or instantiate a union.</span>
<span class="linenos"> 687</span><span class="sd">    - You can use Optional[X] as a shorthand for Union[X, None].</span>
<span class="linenos"> 688</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 689</span>    <span class="k">if</span> <span class="n">parameters</span> <span class="o">==</span> <span class="p">():</span>
<span class="linenos"> 690</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Union of no types.&quot;</span><span class="p">)</span>
<span class="linenos"> 691</span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos"> 692</span>        <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
<span class="linenos"> 693</span>    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Union[arg, ...]: each arg must be a type.&quot;</span>
<span class="linenos"> 694</span>    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 695</span>    <span class="n">parameters</span> <span class="o">=</span> <span class="n">_remove_dups_flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 696</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="linenos"> 697</span>        <span class="k">return</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="linenos"> 698</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
<span class="linenos"> 699</span>        <span class="k">return</span> <span class="n">_UnionGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Optional&quot;</span><span class="p">)</span>
<span class="linenos"> 700</span>    <span class="k">return</span> <span class="n">_UnionGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 701</span>
<span class="linenos"> 702</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 703</span><span class="k">def</span> <span class="nf">Optional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 704</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Optional[X] is equivalent to Union[X, None].&quot;&quot;&quot;</span>
<span class="linenos"> 705</span>    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> requires a single type.&quot;</span><span class="p">)</span>
<span class="linenos"> 706</span>    <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
<span class="linenos"> 707</span>
<span class="linenos"> 708</span><span class="nd">@_LiteralSpecialForm</span>
<span class="linenos"> 709</span><span class="nd">@_tp_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 710</span><span class="k">def</span> <span class="nf">Literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 711</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing form to define literal types (a.k.a. value types).</span>
<span class="linenos"> 712</span>
<span class="linenos"> 713</span><span class="sd">    This form can be used to indicate to type checkers that the corresponding</span>
<span class="linenos"> 714</span><span class="sd">    variable or function parameter has a value equivalent to the provided</span>
<span class="linenos"> 715</span><span class="sd">    literal (or one of several literals)::</span>
<span class="linenos"> 716</span>
<span class="linenos"> 717</span><span class="sd">        def validate_simple(data: Any) -&gt; Literal[True]:  # always returns True</span>
<span class="linenos"> 718</span><span class="sd">            ...</span>
<span class="linenos"> 719</span>
<span class="linenos"> 720</span><span class="sd">        MODE = Literal[&#39;r&#39;, &#39;rb&#39;, &#39;w&#39;, &#39;wb&#39;]</span>
<span class="linenos"> 721</span><span class="sd">        def open_helper(file: str, mode: MODE) -&gt; str:</span>
<span class="linenos"> 722</span><span class="sd">            ...</span>
<span class="linenos"> 723</span>
<span class="linenos"> 724</span><span class="sd">        open_helper(&#39;/some/path&#39;, &#39;r&#39;)  # Passes type check</span>
<span class="linenos"> 725</span><span class="sd">        open_helper(&#39;/other/path&#39;, &#39;typo&#39;)  # Error in type checker</span>
<span class="linenos"> 726</span>
<span class="linenos"> 727</span><span class="sd">    Literal[...] cannot be subclassed. At runtime, an arbitrary value</span>
<span class="linenos"> 728</span><span class="sd">    is allowed as type argument to Literal[...], but type checkers may</span>
<span class="linenos"> 729</span><span class="sd">    impose restrictions.</span>
<span class="linenos"> 730</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 731</span>    <span class="c1"># There is no &#39;_type_check&#39; call because arguments to Literal[...] are</span>
<span class="linenos"> 732</span>    <span class="c1"># values, not types.</span>
<span class="linenos"> 733</span>    <span class="n">parameters</span> <span class="o">=</span> <span class="n">_flatten_literal_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 734</span>
<span class="linenos"> 735</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos"> 736</span>        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_deduplicate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">))))</span>
<span class="linenos"> 737</span>    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># unhashable parameters</span>
<span class="linenos"> 738</span>        <span class="k">pass</span>
<span class="linenos"> 739</span>
<span class="linenos"> 740</span>    <span class="k">return</span> <span class="n">_LiteralGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
<span class="linenos"> 741</span>
<span class="linenos"> 742</span>
<span class="linenos"> 743</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 744</span><span class="k">def</span> <span class="nf">TypeAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 745</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special form for marking type aliases.</span>
<span class="linenos"> 746</span>
<span class="linenos"> 747</span><span class="sd">    Use TypeAlias to indicate that an assignment should</span>
<span class="linenos"> 748</span><span class="sd">    be recognized as a proper type alias definition by type</span>
<span class="linenos"> 749</span><span class="sd">    checkers.</span>
<span class="linenos"> 750</span>
<span class="linenos"> 751</span><span class="sd">    For example::</span>
<span class="linenos"> 752</span>
<span class="linenos"> 753</span><span class="sd">        Predicate: TypeAlias = Callable[..., bool]</span>
<span class="linenos"> 754</span>
<span class="linenos"> 755</span><span class="sd">    It&#39;s invalid when used anywhere except as in the example above.</span>
<span class="linenos"> 756</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 757</span>    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>
<span class="linenos"> 758</span>
<span class="linenos"> 759</span>
<span class="linenos"> 760</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 761</span><span class="k">def</span> <span class="nf">Concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 762</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special form for annotating higher-order functions.</span>
<span class="linenos"> 763</span>
<span class="linenos"> 764</span><span class="sd">    ``Concatenate`` can be used in conjunction with ``ParamSpec`` and</span>
<span class="linenos"> 765</span><span class="sd">    ``Callable`` to represent a higher-order function which adds, removes or</span>
<span class="linenos"> 766</span><span class="sd">    transforms the parameters of a callable.</span>
<span class="linenos"> 767</span>
<span class="linenos"> 768</span><span class="sd">    For example::</span>
<span class="linenos"> 769</span>
<span class="linenos"> 770</span><span class="sd">        Callable[Concatenate[int, P], int]</span>
<span class="linenos"> 771</span>
<span class="linenos"> 772</span><span class="sd">    See PEP 612 for detailed information.</span>
<span class="linenos"> 773</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 774</span>    <span class="k">if</span> <span class="n">parameters</span> <span class="o">==</span> <span class="p">():</span>
<span class="linenos"> 775</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="p">)</span>
<span class="linenos"> 776</span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos"> 777</span>        <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
<span class="linenos"> 778</span>    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ParamSpec</span><span class="p">)):</span>
<span class="linenos"> 779</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The last parameter to Concatenate should be a &quot;</span>
<span class="linenos"> 780</span>                        <span class="s2">&quot;ParamSpec variable or ellipsis.&quot;</span><span class="p">)</span>
<span class="linenos"> 781</span>    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
<span class="linenos"> 782</span>    <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="linenos"> 783</span>    <span class="k">return</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
<span class="linenos"> 784</span>                                    <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 785</span>
<span class="linenos"> 786</span>
<span class="linenos"> 787</span><span class="nd">@_SpecialForm</span>
<span class="linenos"> 788</span><span class="k">def</span> <span class="nf">TypeGuard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos"> 789</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct for marking user-defined type guard functions.</span>
<span class="linenos"> 790</span>
<span class="linenos"> 791</span><span class="sd">    ``TypeGuard`` can be used to annotate the return type of a user-defined</span>
<span class="linenos"> 792</span><span class="sd">    type guard function.  ``TypeGuard`` only accepts a single type argument.</span>
<span class="linenos"> 793</span><span class="sd">    At runtime, functions marked this way should return a boolean.</span>
<span class="linenos"> 794</span>
<span class="linenos"> 795</span><span class="sd">    ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static</span>
<span class="linenos"> 796</span><span class="sd">    type checkers to determine a more precise type of an expression within a</span>
<span class="linenos"> 797</span><span class="sd">    program&#39;s code flow.  Usually type narrowing is done by analyzing</span>
<span class="linenos"> 798</span><span class="sd">    conditional code flow and applying the narrowing to a block of code.  The</span>
<span class="linenos"> 799</span><span class="sd">    conditional expression here is sometimes referred to as a &quot;type guard&quot;.</span>
<span class="linenos"> 800</span>
<span class="linenos"> 801</span><span class="sd">    Sometimes it would be convenient to use a user-defined boolean function</span>
<span class="linenos"> 802</span><span class="sd">    as a type guard.  Such a function should use ``TypeGuard[...]`` as its</span>
<span class="linenos"> 803</span><span class="sd">    return type to alert static type checkers to this intention.</span>
<span class="linenos"> 804</span>
<span class="linenos"> 805</span><span class="sd">    Using  ``-&gt; TypeGuard`` tells the static type checker that for a given</span>
<span class="linenos"> 806</span><span class="sd">    function:</span>
<span class="linenos"> 807</span>
<span class="linenos"> 808</span><span class="sd">    1. The return value is a boolean.</span>
<span class="linenos"> 809</span><span class="sd">    2. If the return value is ``True``, the type of its argument</span>
<span class="linenos"> 810</span><span class="sd">       is the type inside ``TypeGuard``.</span>
<span class="linenos"> 811</span>
<span class="linenos"> 812</span><span class="sd">       For example::</span>
<span class="linenos"> 813</span>
<span class="linenos"> 814</span><span class="sd">           def is_str(val: Union[str, float]):</span>
<span class="linenos"> 815</span><span class="sd">               # &quot;isinstance&quot; type guard</span>
<span class="linenos"> 816</span><span class="sd">               if isinstance(val, str):</span>
<span class="linenos"> 817</span><span class="sd">                   # Type of ``val`` is narrowed to ``str``</span>
<span class="linenos"> 818</span><span class="sd">                   ...</span>
<span class="linenos"> 819</span><span class="sd">               else:</span>
<span class="linenos"> 820</span><span class="sd">                   # Else, type of ``val`` is narrowed to ``float``.</span>
<span class="linenos"> 821</span><span class="sd">                   ...</span>
<span class="linenos"> 822</span>
<span class="linenos"> 823</span><span class="sd">    Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower</span>
<span class="linenos"> 824</span><span class="sd">    form of ``TypeA`` (it can even be a wider form) and this may lead to</span>
<span class="linenos"> 825</span><span class="sd">    type-unsafe results.  The main reason is to allow for things like</span>
<span class="linenos"> 826</span><span class="sd">    narrowing ``List[object]`` to ``List[str]`` even though the latter is not</span>
<span class="linenos"> 827</span><span class="sd">    a subtype of the former, since ``List`` is invariant.  The responsibility of</span>
<span class="linenos"> 828</span><span class="sd">    writing type-safe type guards is left to the user.</span>
<span class="linenos"> 829</span>
<span class="linenos"> 830</span><span class="sd">    ``TypeGuard`` also works with type variables.  For more information, see</span>
<span class="linenos"> 831</span><span class="sd">    PEP 647 (User-Defined Type Guards).</span>
<span class="linenos"> 832</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 833</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
<span class="linenos"> 834</span>    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
<span class="linenos"> 835</span>
<span class="linenos"> 836</span>
<span class="linenos"> 837</span><span class="k">class</span> <span class="nc">ForwardRef</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos"> 838</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal wrapper to hold a forward reference.&quot;&quot;&quot;</span>
<span class="linenos"> 839</span>
<span class="linenos"> 840</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__forward_arg__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_code__&#39;</span><span class="p">,</span>
<span class="linenos"> 841</span>                 <span class="s1">&#39;__forward_evaluated__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_value__&#39;</span><span class="p">,</span>
<span class="linenos"> 842</span>                 <span class="s1">&#39;__forward_is_argument__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_is_class__&#39;</span><span class="p">,</span>
<span class="linenos"> 843</span>                 <span class="s1">&#39;__forward_module__&#39;</span><span class="p">)</span>
<span class="linenos"> 844</span>
<span class="linenos"> 845</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos"> 846</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
<span class="linenos"> 847</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward reference must be a string -- got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos"> 848</span>
<span class="linenos"> 849</span>        <span class="c1"># If we do `def f(*args: *Ts)`, then we&#39;ll have `arg = &#39;*Ts&#39;`.</span>
<span class="linenos"> 850</span>        <span class="c1"># Unfortunately, this isn&#39;t a valid expression on its own, so we</span>
<span class="linenos"> 851</span>        <span class="c1"># do the unpacking manually.</span>
<span class="linenos"> 852</span>        <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
<span class="linenos"> 853</span>            <span class="n">arg_to_compile</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s1">,)[0]&#39;</span>  <span class="c1"># E.g. (*Ts,)[0] or (*tuple[int, int],)[0]</span>
<span class="linenos"> 854</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 855</span>            <span class="n">arg_to_compile</span> <span class="o">=</span> <span class="n">arg</span>
<span class="linenos"> 856</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos"> 857</span>            <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">arg_to_compile</span><span class="p">,</span> <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;eval&#39;</span><span class="p">)</span>
<span class="linenos"> 858</span>        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
<span class="linenos"> 859</span>            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward reference must be an expression -- got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos"> 860</span>
<span class="linenos"> 861</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">=</span> <span class="n">arg</span>
<span class="linenos"> 862</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_code__</span> <span class="o">=</span> <span class="n">code</span>
<span class="linenos"> 863</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="o">=</span> <span class="kc">False</span>
<span class="linenos"> 864</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos"> 865</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_argument__</span> <span class="o">=</span> <span class="n">is_argument</span>
<span class="linenos"> 866</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span> <span class="o">=</span> <span class="n">is_class</span>
<span class="linenos"> 867</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="o">=</span> <span class="n">module</span>
<span class="linenos"> 868</span>
<span class="linenos"> 869</span>    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">):</span>
<span class="linenos"> 870</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">in</span> <span class="n">recursive_guard</span><span class="p">:</span>
<span class="linenos"> 871</span>            <span class="k">return</span> <span class="bp">self</span>
<span class="linenos"> 872</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="ow">or</span> <span class="n">localns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">globalns</span><span class="p">:</span>
<span class="linenos"> 873</span>            <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 874</span>                <span class="n">globalns</span> <span class="o">=</span> <span class="n">localns</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos"> 875</span>            <span class="k">elif</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 876</span>                <span class="n">globalns</span> <span class="o">=</span> <span class="n">localns</span>
<span class="linenos"> 877</span>            <span class="k">elif</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 878</span>                <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
<span class="linenos"> 879</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 880</span>                <span class="n">globalns</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
<span class="linenos"> 881</span>                    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="n">globalns</span>
<span class="linenos"> 882</span>                <span class="p">)</span>
<span class="linenos"> 883</span>            <span class="n">type_</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span>
<span class="linenos"> 884</span>                <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_code__</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">),</span>
<span class="linenos"> 885</span>                <span class="s2">&quot;Forward references must evaluate to types.&quot;</span><span class="p">,</span>
<span class="linenos"> 886</span>                <span class="n">is_argument</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_argument__</span><span class="p">,</span>
<span class="linenos"> 887</span>                <span class="n">allow_special_forms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span><span class="p">,</span>
<span class="linenos"> 888</span>            <span class="p">)</span>
<span class="linenos"> 889</span>            <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span>
<span class="linenos"> 890</span>                <span class="n">type_</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="p">}</span>
<span class="linenos"> 891</span>            <span class="p">)</span>
<span class="linenos"> 892</span>            <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos"> 893</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span>
<span class="linenos"> 894</span>
<span class="linenos"> 895</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 896</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">):</span>
<span class="linenos"> 897</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos"> 898</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_evaluated__</span><span class="p">:</span>
<span class="linenos"> 899</span>            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">and</span>
<span class="linenos"> 900</span>                    <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_value__</span><span class="p">)</span>
<span class="linenos"> 901</span>        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">and</span>
<span class="linenos"> 902</span>                <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">)</span>
<span class="linenos"> 903</span>
<span class="linenos"> 904</span>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 905</span>        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">))</span>
<span class="linenos"> 906</span>
<span class="linenos"> 907</span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 908</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
<span class="linenos"> 909</span>
<span class="linenos"> 910</span>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos"> 911</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
<span class="linenos"> 912</span>
<span class="linenos"> 913</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 914</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 915</span>            <span class="n">module_repr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="linenos"> 916</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 917</span>            <span class="n">module_repr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;, module=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="si">!r}</span><span class="s1">&#39;</span>
<span class="linenos"> 918</span>        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;ForwardRef(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="si">!r}{</span><span class="n">module_repr</span><span class="si">}</span><span class="s1">)&#39;</span>
<span class="linenos"> 919</span>
<span class="linenos"> 920</span>
<span class="linenos"> 921</span><span class="k">def</span> <span class="nf">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos"> 922</span>    <span class="k">return</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span> <span class="ow">and</span>
<span class="linenos"> 923</span>            <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__typing_is_unpacked_typevartuple__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="linenos"> 924</span>
<span class="linenos"> 925</span>
<span class="linenos"> 926</span><span class="k">def</span> <span class="nf">_is_typevar_like</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos"> 927</span>    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">TypeVar</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">))</span> <span class="ow">or</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="linenos"> 928</span>
<span class="linenos"> 929</span>
<span class="linenos"> 930</span><span class="k">class</span> <span class="nc">_PickleUsingNameMixin</span><span class="p">:</span>
<span class="linenos"> 931</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin enabling pickling based on self.__name__.&quot;&quot;&quot;</span>
<span class="linenos"> 932</span>
<span class="linenos"> 933</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 934</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos"> 935</span>
<span class="linenos"> 936</span>
<span class="linenos"> 937</span><span class="k">class</span> <span class="nc">_BoundVarianceMixin</span><span class="p">:</span>
<span class="linenos"> 938</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin giving __init__ bound and variance arguments.</span>
<span class="linenos"> 939</span>
<span class="linenos"> 940</span><span class="sd">    This is used by TypeVar and ParamSpec, which both employ the notions of</span>
<span class="linenos"> 941</span><span class="sd">    a type &#39;bound&#39; (restricting type arguments to be a subtype of some</span>
<span class="linenos"> 942</span><span class="sd">    specified type) and type &#39;variance&#39; (determining subtype relations between</span>
<span class="linenos"> 943</span><span class="sd">    generic types).</span>
<span class="linenos"> 944</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 945</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">covariant</span><span class="p">,</span> <span class="n">contravariant</span><span class="p">):</span>
<span class="linenos"> 946</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Used to setup TypeVars and ParamSpec&#39;s bound, covariant and</span>
<span class="linenos"> 947</span><span class="sd">        contravariant attributes.</span>
<span class="linenos"> 948</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos"> 949</span>        <span class="k">if</span> <span class="n">covariant</span> <span class="ow">and</span> <span class="n">contravariant</span><span class="p">:</span>
<span class="linenos"> 950</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bivariant types are not supported.&quot;</span><span class="p">)</span>
<span class="linenos"> 951</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__covariant__</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">covariant</span><span class="p">)</span>
<span class="linenos"> 952</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__contravariant__</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">contravariant</span><span class="p">)</span>
<span class="linenos"> 953</span>        <span class="k">if</span> <span class="n">bound</span><span class="p">:</span>
<span class="linenos"> 954</span>            <span class="bp">self</span><span class="o">.</span><span class="n">__bound__</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="s2">&quot;Bound must be a type.&quot;</span><span class="p">)</span>
<span class="linenos"> 955</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 956</span>            <span class="bp">self</span><span class="o">.</span><span class="n">__bound__</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos"> 957</span>
<span class="linenos"> 958</span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="linenos"> 959</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
<span class="linenos"> 960</span>
<span class="linenos"> 961</span>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
<span class="linenos"> 962</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
<span class="linenos"> 963</span>
<span class="linenos"> 964</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos"> 965</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__covariant__</span><span class="p">:</span>
<span class="linenos"> 966</span>            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
<span class="linenos"> 967</span>        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__contravariant__</span><span class="p">:</span>
<span class="linenos"> 968</span>            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
<span class="linenos"> 969</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 970</span>            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;~&#39;</span>
<span class="linenos"> 971</span>        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos"> 972</span>
<span class="linenos"> 973</span>
<span class="linenos"> 974</span><span class="k">class</span> <span class="nc">TypeVar</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_BoundVarianceMixin</span><span class="p">,</span> <span class="n">_PickleUsingNameMixin</span><span class="p">,</span>
<span class="linenos"> 975</span>              <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos"> 976</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Type variable.</span>
<span class="linenos"> 977</span>
<span class="linenos"> 978</span><span class="sd">    Usage::</span>
<span class="linenos"> 979</span>
<span class="linenos"> 980</span><span class="sd">      T = TypeVar(&#39;T&#39;)  # Can be anything</span>
<span class="linenos"> 981</span><span class="sd">      A = TypeVar(&#39;A&#39;, str, bytes)  # Must be str or bytes</span>
<span class="linenos"> 982</span>
<span class="linenos"> 983</span><span class="sd">    Type variables exist primarily for the benefit of static type</span>
<span class="linenos"> 984</span><span class="sd">    checkers.  They serve as the parameters for generic types as well</span>
<span class="linenos"> 985</span><span class="sd">    as for generic function definitions.  See class Generic for more</span>
<span class="linenos"> 986</span><span class="sd">    information on generic types.  Generic functions work as follows:</span>
<span class="linenos"> 987</span>
<span class="linenos"> 988</span><span class="sd">      def repeat(x: T, n: int) -&gt; List[T]:</span>
<span class="linenos"> 989</span><span class="sd">          &#39;&#39;&#39;Return a list containing n references to x.&#39;&#39;&#39;</span>
<span class="linenos"> 990</span><span class="sd">          return [x]*n</span>
<span class="linenos"> 991</span>
<span class="linenos"> 992</span><span class="sd">      def longest(x: A, y: A) -&gt; A:</span>
<span class="linenos"> 993</span><span class="sd">          &#39;&#39;&#39;Return the longest of two strings.&#39;&#39;&#39;</span>
<span class="linenos"> 994</span><span class="sd">          return x if len(x) &gt;= len(y) else y</span>
<span class="linenos"> 995</span>
<span class="linenos"> 996</span><span class="sd">    The latter example&#39;s signature is essentially the overloading</span>
<span class="linenos"> 997</span><span class="sd">    of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note</span>
<span class="linenos"> 998</span><span class="sd">    that if the arguments are instances of some subclass of str,</span>
<span class="linenos"> 999</span><span class="sd">    the return type is still plain str.</span>
<span class="linenos">1000</span>
<span class="linenos">1001</span><span class="sd">    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.</span>
<span class="linenos">1002</span>
<span class="linenos">1003</span><span class="sd">    Type variables defined with covariant=True or contravariant=True</span>
<span class="linenos">1004</span><span class="sd">    can be used to declare covariant or contravariant generic types.</span>
<span class="linenos">1005</span><span class="sd">    See PEP 484 for more details. By default generic types are invariant</span>
<span class="linenos">1006</span><span class="sd">    in all type variables.</span>
<span class="linenos">1007</span>
<span class="linenos">1008</span><span class="sd">    Type variables can be introspected. e.g.:</span>
<span class="linenos">1009</span>
<span class="linenos">1010</span><span class="sd">      T.__name__ == &#39;T&#39;</span>
<span class="linenos">1011</span><span class="sd">      T.__constraints__ == ()</span>
<span class="linenos">1012</span><span class="sd">      T.__covariant__ == False</span>
<span class="linenos">1013</span><span class="sd">      T.__contravariant__ = False</span>
<span class="linenos">1014</span><span class="sd">      A.__constraints__ == (str, bytes)</span>
<span class="linenos">1015</span>
<span class="linenos">1016</span><span class="sd">    Note that only type variables defined in global scope can be pickled.</span>
<span class="linenos">1017</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1018</span>
<span class="linenos">1019</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">constraints</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1020</span>                 <span class="n">covariant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos">1021</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
<span class="linenos">1022</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">covariant</span><span class="p">,</span> <span class="n">contravariant</span><span class="p">)</span>
<span class="linenos">1023</span>        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">and</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1024</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Constraints cannot be combined with bound=...&quot;</span><span class="p">)</span>
<span class="linenos">1025</span>        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="linenos">1026</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A single constraint is not allowed&quot;</span><span class="p">)</span>
<span class="linenos">1027</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;TypeVar(name, constraint, ...): constraints must be types.&quot;</span>
<span class="linenos">1028</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__constraints__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">)</span>
<span class="linenos">1029</span>        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
<span class="linenos">1030</span>        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
<span class="linenos">1031</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>
<span class="linenos">1032</span>
<span class="linenos">1033</span>    <span class="k">def</span> <span class="nf">__typing_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="linenos">1034</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters to generic types must be types.&quot;</span>
<span class="linenos">1035</span>        <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">1036</span>        <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span><span class="p">)</span> <span class="ow">or</span>
<span class="linenos">1037</span>            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__unpacked__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))):</span>
<span class="linenos">1038</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
<span class="linenos">1039</span>        <span class="k">return</span> <span class="n">arg</span>
<span class="linenos">1040</span>
<span class="linenos">1041</span>
<span class="linenos">1042</span><span class="k">class</span> <span class="nc">TypeVarTuple</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_PickleUsingNameMixin</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1043</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Type variable tuple.</span>
<span class="linenos">1044</span>
<span class="linenos">1045</span><span class="sd">    Usage:</span>
<span class="linenos">1046</span>
<span class="linenos">1047</span><span class="sd">      Ts = TypeVarTuple(&#39;Ts&#39;)  # Can be given any name</span>
<span class="linenos">1048</span>
<span class="linenos">1049</span><span class="sd">    Just as a TypeVar (type variable) is a placeholder for a single type,</span>
<span class="linenos">1050</span><span class="sd">    a TypeVarTuple is a placeholder for an *arbitrary* number of types. For</span>
<span class="linenos">1051</span><span class="sd">    example, if we define a generic class using a TypeVarTuple:</span>
<span class="linenos">1052</span>
<span class="linenos">1053</span><span class="sd">      class C(Generic[*Ts]): ...</span>
<span class="linenos">1054</span>
<span class="linenos">1055</span><span class="sd">    Then we can parameterize that class with an arbitrary number of type</span>
<span class="linenos">1056</span><span class="sd">    arguments:</span>
<span class="linenos">1057</span>
<span class="linenos">1058</span><span class="sd">      C[int]       # Fine</span>
<span class="linenos">1059</span><span class="sd">      C[int, str]  # Also fine</span>
<span class="linenos">1060</span><span class="sd">      C[()]        # Even this is fine</span>
<span class="linenos">1061</span>
<span class="linenos">1062</span><span class="sd">    For more details, see PEP 646.</span>
<span class="linenos">1063</span>
<span class="linenos">1064</span><span class="sd">    Note that only TypeVarTuples defined in global scope can be pickled.</span>
<span class="linenos">1065</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1066</span>
<span class="linenos">1067</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="linenos">1068</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
<span class="linenos">1069</span>
<span class="linenos">1070</span>        <span class="c1"># Used for pickling.</span>
<span class="linenos">1071</span>        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
<span class="linenos">1072</span>        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
<span class="linenos">1073</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>
<span class="linenos">1074</span>
<span class="linenos">1075</span>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1076</span>        <span class="k">yield</span> <span class="n">Unpack</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
<span class="linenos">1077</span>
<span class="linenos">1078</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1079</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos">1080</span>
<span class="linenos">1081</span>    <span class="k">def</span> <span class="nf">__typing_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="linenos">1082</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Substitution of bare TypeVarTuple is not supported&quot;</span><span class="p">)</span>
<span class="linenos">1083</span>
<span class="linenos">1084</span>    <span class="k">def</span> <span class="nf">__typing_prepare_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos">1085</span>        <span class="n">params</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">__parameters__</span>
<span class="linenos">1086</span>        <span class="n">typevartuple_index</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1087</span>        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="n">typevartuple_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
<span class="linenos">1088</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
<span class="linenos">1089</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one TypeVarTuple parameter in </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1090</span>
<span class="linenos">1091</span>        <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="linenos">1092</span>        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1093</span>        <span class="n">left</span> <span class="o">=</span> <span class="n">typevartuple_index</span>
<span class="linenos">1094</span>        <span class="n">right</span> <span class="o">=</span> <span class="n">plen</span> <span class="o">-</span> <span class="n">typevartuple_index</span> <span class="o">-</span> <span class="mi">1</span>
<span class="linenos">1095</span>        <span class="n">var_tuple_index</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">1096</span>        <span class="n">fillarg</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">1097</span>        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="linenos">1098</span>            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos">1099</span>                <span class="n">subargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__typing_unpacked_tuple_args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos">1100</span>                <span class="k">if</span> <span class="n">subargs</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">subargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
<span class="linenos">1101</span>                    <span class="k">if</span> <span class="n">var_tuple_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1102</span>                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;More than one unpacked arbitrary-length tuple argument&quot;</span><span class="p">)</span>
<span class="linenos">1103</span>                    <span class="n">var_tuple_index</span> <span class="o">=</span> <span class="n">k</span>
<span class="linenos">1104</span>                    <span class="n">fillarg</span> <span class="o">=</span> <span class="n">subargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="linenos">1105</span>        <span class="k">if</span> <span class="n">var_tuple_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1106</span>            <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">var_tuple_index</span><span class="p">)</span>
<span class="linenos">1107</span>            <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">var_tuple_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">1108</span>        <span class="k">elif</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">alen</span><span class="p">:</span>
<span class="linenos">1109</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too few arguments for </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">;&quot;</span>
<span class="linenos">1110</span>                            <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected at least </span><span class="si">{</span><span class="n">plen</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1111</span>
<span class="linenos">1112</span>        <span class="k">return</span> <span class="p">(</span>
<span class="linenos">1113</span>            <span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="n">left</span><span class="p">],</span>
<span class="linenos">1114</span>            <span class="o">*</span><span class="p">([</span><span class="n">fillarg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">typevartuple_index</span> <span class="o">-</span> <span class="n">left</span><span class="p">)),</span>
<span class="linenos">1115</span>            <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">left</span><span class="p">:</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">right</span><span class="p">]),</span>
<span class="linenos">1116</span>            <span class="o">*</span><span class="p">([</span><span class="n">fillarg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">plen</span> <span class="o">-</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="n">typevartuple_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
<span class="linenos">1117</span>            <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">alen</span> <span class="o">-</span> <span class="n">right</span><span class="p">:],</span>
<span class="linenos">1118</span>        <span class="p">)</span>
<span class="linenos">1119</span>
<span class="linenos">1120</span>
<span class="linenos">1121</span><span class="k">class</span> <span class="nc">ParamSpecArgs</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1122</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;The args for a ParamSpec object.</span>
<span class="linenos">1123</span>
<span class="linenos">1124</span><span class="sd">    Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.</span>
<span class="linenos">1125</span>
<span class="linenos">1126</span><span class="sd">    ParamSpecArgs objects have a reference back to their ParamSpec:</span>
<span class="linenos">1127</span>
<span class="linenos">1128</span><span class="sd">       P.args.__origin__ is P</span>
<span class="linenos">1129</span>
<span class="linenos">1130</span><span class="sd">    This type is meant for runtime introspection and has no special meaning to</span>
<span class="linenos">1131</span><span class="sd">    static type checkers.</span>
<span class="linenos">1132</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1133</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
<span class="linenos">1134</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>
<span class="linenos">1135</span>
<span class="linenos">1136</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1137</span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.args&quot;</span>
<span class="linenos">1138</span>
<span class="linenos">1139</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">1140</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParamSpecArgs</span><span class="p">):</span>
<span class="linenos">1141</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">1142</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">1143</span>
<span class="linenos">1144</span>
<span class="linenos">1145</span><span class="k">class</span> <span class="nc">ParamSpecKwargs</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1146</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;The kwargs for a ParamSpec object.</span>
<span class="linenos">1147</span>
<span class="linenos">1148</span><span class="sd">    Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.</span>
<span class="linenos">1149</span>
<span class="linenos">1150</span><span class="sd">    ParamSpecKwargs objects have a reference back to their ParamSpec:</span>
<span class="linenos">1151</span>
<span class="linenos">1152</span><span class="sd">       P.kwargs.__origin__ is P</span>
<span class="linenos">1153</span>
<span class="linenos">1154</span><span class="sd">    This type is meant for runtime introspection and has no special meaning to</span>
<span class="linenos">1155</span><span class="sd">    static type checkers.</span>
<span class="linenos">1156</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1157</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
<span class="linenos">1158</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>
<span class="linenos">1159</span>
<span class="linenos">1160</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1161</span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.kwargs&quot;</span>
<span class="linenos">1162</span>
<span class="linenos">1163</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">1164</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParamSpecKwargs</span><span class="p">):</span>
<span class="linenos">1165</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">1166</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">1167</span>
<span class="linenos">1168</span>
<span class="linenos">1169</span><span class="k">class</span> <span class="nc">ParamSpec</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_BoundVarianceMixin</span><span class="p">,</span> <span class="n">_PickleUsingNameMixin</span><span class="p">,</span>
<span class="linenos">1170</span>                <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1171</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Parameter specification variable.</span>
<span class="linenos">1172</span>
<span class="linenos">1173</span><span class="sd">    Usage::</span>
<span class="linenos">1174</span>
<span class="linenos">1175</span><span class="sd">       P = ParamSpec(&#39;P&#39;)</span>
<span class="linenos">1176</span>
<span class="linenos">1177</span><span class="sd">    Parameter specification variables exist primarily for the benefit of static</span>
<span class="linenos">1178</span><span class="sd">    type checkers.  They are used to forward the parameter types of one</span>
<span class="linenos">1179</span><span class="sd">    callable to another callable, a pattern commonly found in higher order</span>
<span class="linenos">1180</span><span class="sd">    functions and decorators.  They are only valid when used in ``Concatenate``,</span>
<span class="linenos">1181</span><span class="sd">    or as the first argument to ``Callable``, or as parameters for user-defined</span>
<span class="linenos">1182</span><span class="sd">    Generics.  See class Generic for more information on generic types.  An</span>
<span class="linenos">1183</span><span class="sd">    example for annotating a decorator::</span>
<span class="linenos">1184</span>
<span class="linenos">1185</span><span class="sd">       T = TypeVar(&#39;T&#39;)</span>
<span class="linenos">1186</span><span class="sd">       P = ParamSpec(&#39;P&#39;)</span>
<span class="linenos">1187</span>
<span class="linenos">1188</span><span class="sd">       def add_logging(f: Callable[P, T]) -&gt; Callable[P, T]:</span>
<span class="linenos">1189</span><span class="sd">           &#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
<span class="linenos">1190</span><span class="sd">           def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T:</span>
<span class="linenos">1191</span><span class="sd">               logging.info(f&#39;{f.__name__} was called&#39;)</span>
<span class="linenos">1192</span><span class="sd">               return f(*args, **kwargs)</span>
<span class="linenos">1193</span><span class="sd">           return inner</span>
<span class="linenos">1194</span>
<span class="linenos">1195</span><span class="sd">       @add_logging</span>
<span class="linenos">1196</span><span class="sd">       def add_two(x: float, y: float) -&gt; float:</span>
<span class="linenos">1197</span><span class="sd">           &#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
<span class="linenos">1198</span><span class="sd">           return x + y</span>
<span class="linenos">1199</span>
<span class="linenos">1200</span><span class="sd">    Parameter specification variables can be introspected. e.g.:</span>
<span class="linenos">1201</span>
<span class="linenos">1202</span><span class="sd">       P.__name__ == &#39;P&#39;</span>
<span class="linenos">1203</span>
<span class="linenos">1204</span><span class="sd">    Note that only parameter specification variables defined in global scope can</span>
<span class="linenos">1205</span><span class="sd">    be pickled.</span>
<span class="linenos">1206</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1207</span>
<span class="linenos">1208</span>    <span class="nd">@property</span>
<span class="linenos">1209</span>    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1210</span>        <span class="k">return</span> <span class="n">ParamSpecArgs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1211</span>
<span class="linenos">1212</span>    <span class="nd">@property</span>
<span class="linenos">1213</span>    <span class="k">def</span> <span class="nf">kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1214</span>        <span class="k">return</span> <span class="n">ParamSpecKwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1215</span>
<span class="linenos">1216</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos">1217</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
<span class="linenos">1218</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">covariant</span><span class="p">,</span> <span class="n">contravariant</span><span class="p">)</span>
<span class="linenos">1219</span>        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
<span class="linenos">1220</span>        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
<span class="linenos">1221</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>
<span class="linenos">1222</span>
<span class="linenos">1223</span>    <span class="k">def</span> <span class="nf">__typing_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="linenos">1224</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
<span class="linenos">1225</span>            <span class="n">arg</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;Expected a type.&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
<span class="linenos">1226</span>        <span class="k">elif</span> <span class="ow">not</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="linenos">1227</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected a list of types, an ellipsis, &quot;</span>
<span class="linenos">1228</span>                            <span class="sa">f</span><span class="s2">&quot;ParamSpec, or Concatenate. Got </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1229</span>        <span class="k">return</span> <span class="n">arg</span>
<span class="linenos">1230</span>
<span class="linenos">1231</span>    <span class="k">def</span> <span class="nf">__typing_prepare_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos">1232</span>        <span class="n">params</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">__parameters__</span>
<span class="linenos">1233</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1234</span>        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="linenos">1235</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too few arguments for </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1236</span>        <span class="c1"># Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.</span>
<span class="linenos">1237</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="linenos">1238</span>            <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>
<span class="linenos">1239</span>            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
<span class="linenos">1240</span>        <span class="c1"># Convert lists to tuples to help other libraries cache the results.</span>
<span class="linenos">1241</span>        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
<span class="linenos">1242</span>            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
<span class="linenos">1243</span>        <span class="k">return</span> <span class="n">args</span>
<span class="linenos">1244</span>
<span class="linenos">1245</span><span class="k">def</span> <span class="nf">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="linenos">1246</span>    <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span>
<span class="linenos">1247</span>
<span class="linenos">1248</span><span class="k">class</span> <span class="nc">_BaseGenericAlias</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1249</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;The central part of the internal API.</span>
<span class="linenos">1250</span>
<span class="linenos">1251</span><span class="sd">    This represents a generic version of type &#39;origin&#39; with type arguments &#39;params&#39;.</span>
<span class="linenos">1252</span><span class="sd">    There are two kind of these aliases: user defined and special. The special ones</span>
<span class="linenos">1253</span><span class="sd">    are wrappers around builtin collections and ABCs in collections.abc. These must</span>
<span class="linenos">1254</span><span class="sd">    have &#39;name&#39; always set. If &#39;inst&#39; is False, then the alias can&#39;t be instantiated;</span>
<span class="linenos">1255</span><span class="sd">    this is used by e.g. typing.List and typing.Dict.</span>
<span class="linenos">1256</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1257</span>
<span class="linenos">1258</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos">1259</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_inst</span> <span class="o">=</span> <span class="n">inst</span>
<span class="linenos">1260</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
<span class="linenos">1261</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>
<span class="linenos">1262</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This is not documented.</span>
<span class="linenos">1263</span>
<span class="linenos">1264</span>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">1265</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">:</span>
<span class="linenos">1266</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> cannot be instantiated; &quot;</span>
<span class="linenos">1267</span>                            <span class="sa">f</span><span class="s2">&quot;use </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() instead&quot;</span><span class="p">)</span>
<span class="linenos">1268</span>        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos">1269</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">1270</span>            <span class="n">result</span><span class="o">.</span><span class="n">__orig_class__</span> <span class="o">=</span> <span class="bp">self</span>
<span class="linenos">1271</span>        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
<span class="linenos">1272</span>            <span class="k">pass</span>
<span class="linenos">1273</span>        <span class="k">return</span> <span class="n">result</span>
<span class="linenos">1274</span>
<span class="linenos">1275</span>    <span class="k">def</span> <span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
<span class="linenos">1276</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos">1277</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">1278</span>            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
<span class="linenos">1279</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1280</span>        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
<span class="linenos">1281</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Generic</span><span class="p">):</span>
<span class="linenos">1282</span>                <span class="k">break</span>
<span class="linenos">1283</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1284</span>            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Generic</span><span class="p">)</span>
<span class="linenos">1285</span>        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="linenos">1286</span>
<span class="linenos">1287</span>    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="linenos">1288</span>        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
<span class="linenos">1289</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos">1290</span>
<span class="linenos">1291</span>        <span class="c1"># We are careful for copy and pickle.</span>
<span class="linenos">1292</span>        <span class="c1"># Also for simplicity we don&#39;t relay any dunder names</span>
<span class="linenos">1293</span>        <span class="k">if</span> <span class="s1">&#39;__origin__&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="linenos">1294</span>            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
<span class="linenos">1295</span>        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
<span class="linenos">1296</span>
<span class="linenos">1297</span>    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="linenos">1298</span>        <span class="k">if</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_inst&#39;</span><span class="p">,</span> <span class="s1">&#39;_nparams&#39;</span><span class="p">,</span>
<span class="linenos">1299</span>                                        <span class="s1">&#39;_paramspec_tvars&#39;</span><span class="p">}:</span>
<span class="linenos">1300</span>            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="linenos">1301</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1302</span>            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="linenos">1303</span>
<span class="linenos">1304</span>    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="linenos">1305</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="linenos">1306</span>
<span class="linenos">1307</span>    <span class="k">def</span> <span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="linenos">1308</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Subscripted generics cannot be used with&quot;</span>
<span class="linenos">1309</span>                        <span class="s2">&quot; class and instance checks&quot;</span><span class="p">)</span>
<span class="linenos">1310</span>
<span class="linenos">1311</span>    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1312</span>        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>
<span class="linenos">1313</span>                <span class="o">+</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">)]))</span>
<span class="linenos">1314</span>
<span class="linenos">1315</span>
<span class="linenos">1316</span><span class="c1"># Special typing constructs Union, Optional, Generic, Callable and Tuple</span>
<span class="linenos">1317</span><span class="c1"># use three special attributes for internal bookkeeping of generic types:</span>
<span class="linenos">1318</span><span class="c1"># * __parameters__ is a tuple of unique free type parameters of a generic</span>
<span class="linenos">1319</span><span class="c1">#   type, for example, Dict[T, T].__parameters__ == (T,);</span>
<span class="linenos">1320</span><span class="c1"># * __origin__ keeps a reference to a type that was subscripted,</span>
<span class="linenos">1321</span><span class="c1">#   e.g., Union[T, int].__origin__ == Union, or the non-generic version of</span>
<span class="linenos">1322</span><span class="c1">#   the type.</span>
<span class="linenos">1323</span><span class="c1"># * __args__ is a tuple of all arguments used in subscripting,</span>
<span class="linenos">1324</span><span class="c1">#   e.g., Dict[T, int].__args__ == (T, int).</span>
<span class="linenos">1325</span>
<span class="linenos">1326</span>
<span class="linenos">1327</span><span class="k">class</span> <span class="nc">_GenericAlias</span><span class="p">(</span><span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1328</span>    <span class="c1"># The type of parameterized generics.</span>
<span class="linenos">1329</span>    <span class="c1">#</span>
<span class="linenos">1330</span>    <span class="c1"># That is, for example, `type(List[int])` is `_GenericAlias`.</span>
<span class="linenos">1331</span>    <span class="c1">#</span>
<span class="linenos">1332</span>    <span class="c1"># Objects which are instances of this class include:</span>
<span class="linenos">1333</span>    <span class="c1"># * Parameterized container types, e.g. `Tuple[int]`, `List[int]`.</span>
<span class="linenos">1334</span>    <span class="c1">#  * Note that native container types, e.g. `tuple`, `list`, use</span>
<span class="linenos">1335</span>    <span class="c1">#    `types.GenericAlias` instead.</span>
<span class="linenos">1336</span>    <span class="c1"># * Parameterized classes:</span>
<span class="linenos">1337</span>    <span class="c1">#     T = TypeVar(&#39;T&#39;)</span>
<span class="linenos">1338</span>    <span class="c1">#     class C(Generic[T]): pass</span>
<span class="linenos">1339</span>    <span class="c1">#     # C[int] is a _GenericAlias</span>
<span class="linenos">1340</span>    <span class="c1"># * `Callable` aliases, generic `Callable` aliases, and</span>
<span class="linenos">1341</span>    <span class="c1">#   parameterized `Callable` aliases:</span>
<span class="linenos">1342</span>    <span class="c1">#     T = TypeVar(&#39;T&#39;)</span>
<span class="linenos">1343</span>    <span class="c1">#     # _CallableGenericAlias inherits from _GenericAlias.</span>
<span class="linenos">1344</span>    <span class="c1">#     A = Callable[[], None]  # _CallableGenericAlias</span>
<span class="linenos">1345</span>    <span class="c1">#     B = Callable[[T], None]  # _CallableGenericAlias</span>
<span class="linenos">1346</span>    <span class="c1">#     C = B[int]  # _CallableGenericAlias</span>
<span class="linenos">1347</span>    <span class="c1"># * Parameterized `Final`, `ClassVar` and `TypeGuard`:</span>
<span class="linenos">1348</span>    <span class="c1">#     # All _GenericAlias</span>
<span class="linenos">1349</span>    <span class="c1">#     Final[int]</span>
<span class="linenos">1350</span>    <span class="c1">#     ClassVar[float]</span>
<span class="linenos">1351</span>    <span class="c1">#     TypeVar[bool]</span>
<span class="linenos">1352</span>
<span class="linenos">1353</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="linenos">1354</span>                 <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos">1355</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
<span class="linenos">1356</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1357</span>            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
<span class="linenos">1358</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">...</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">_TypingEllipsis</span> <span class="k">else</span>
<span class="linenos">1359</span>                              <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1360</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="n">_collect_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="linenos">1361</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_paramspec_tvars</span> <span class="o">=</span> <span class="n">_paramspec_tvars</span>
<span class="linenos">1362</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
<span class="linenos">1363</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span>
<span class="linenos">1364</span>
<span class="linenos">1365</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">1366</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
<span class="linenos">1367</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">1368</span>        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">1369</span>                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">1370</span>
<span class="linenos">1371</span>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1372</span>        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>
<span class="linenos">1373</span>
<span class="linenos">1374</span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="linenos">1375</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
<span class="linenos">1376</span>
<span class="linenos">1377</span>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
<span class="linenos">1378</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
<span class="linenos">1379</span>
<span class="linenos">1380</span>    <span class="nd">@_tp_cache</span>
<span class="linenos">1381</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos">1382</span>        <span class="c1"># Parameterizes an already-parameterized object.</span>
<span class="linenos">1383</span>        <span class="c1">#</span>
<span class="linenos">1384</span>        <span class="c1"># For example, we arrive here doing something like:</span>
<span class="linenos">1385</span>        <span class="c1">#   T1 = TypeVar(&#39;T1&#39;)</span>
<span class="linenos">1386</span>        <span class="c1">#   T2 = TypeVar(&#39;T2&#39;)</span>
<span class="linenos">1387</span>        <span class="c1">#   T3 = TypeVar(&#39;T3&#39;)</span>
<span class="linenos">1388</span>        <span class="c1">#   class A(Generic[T1]): pass</span>
<span class="linenos">1389</span>        <span class="c1">#   B = A[T2]  # B is a _GenericAlias</span>
<span class="linenos">1390</span>        <span class="c1">#   C = B[T3]  # Invokes _GenericAlias.__getitem__</span>
<span class="linenos">1391</span>        <span class="c1">#</span>
<span class="linenos">1392</span>        <span class="c1"># We also arrive here when parameterizing a generic `Callable` alias:</span>
<span class="linenos">1393</span>        <span class="c1">#   T = TypeVar(&#39;T&#39;)</span>
<span class="linenos">1394</span>        <span class="c1">#   C = Callable[[T], None]</span>
<span class="linenos">1395</span>        <span class="c1">#   C[int]  # Invokes _GenericAlias.__getitem__</span>
<span class="linenos">1396</span>
<span class="linenos">1397</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">1398</span>            <span class="c1"># Can&#39;t subscript Generic[...] or Protocol[...].</span>
<span class="linenos">1399</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subscript already-subscripted </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1400</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">:</span>
<span class="linenos">1401</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not a generic class&quot;</span><span class="p">)</span>
<span class="linenos">1402</span>
<span class="linenos">1403</span>        <span class="c1"># Preprocess `args`.</span>
<span class="linenos">1404</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1405</span>            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
<span class="linenos">1406</span>        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1407</span>        <span class="n">args</span> <span class="o">=</span> <span class="n">_unpack_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="linenos">1408</span>        <span class="n">new_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_new_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="linenos">1409</span>        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>
<span class="linenos">1410</span>        <span class="k">return</span> <span class="n">r</span>
<span class="linenos">1411</span>
<span class="linenos">1412</span>    <span class="k">def</span> <span class="nf">_determine_new_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos">1413</span>        <span class="c1"># Determines new __args__ for __getitem__.</span>
<span class="linenos">1414</span>        <span class="c1">#</span>
<span class="linenos">1415</span>        <span class="c1"># For example, suppose we had:</span>
<span class="linenos">1416</span>        <span class="c1">#   T1 = TypeVar(&#39;T1&#39;)</span>
<span class="linenos">1417</span>        <span class="c1">#   T2 = TypeVar(&#39;T2&#39;)</span>
<span class="linenos">1418</span>        <span class="c1">#   class A(Generic[T1, T2]): pass</span>
<span class="linenos">1419</span>        <span class="c1">#   T3 = TypeVar(&#39;T3&#39;)</span>
<span class="linenos">1420</span>        <span class="c1">#   B = A[int, T3]</span>
<span class="linenos">1421</span>        <span class="c1">#   C = B[str]</span>
<span class="linenos">1422</span>        <span class="c1"># `B.__args__` is `(int, T3)`, so `C.__args__` should be `(int, str)`.</span>
<span class="linenos">1423</span>        <span class="c1"># Unfortunately, this is harder than it looks, because if `T3` is</span>
<span class="linenos">1424</span>        <span class="c1"># anything more exotic than a plain `TypeVar`, we need to consider</span>
<span class="linenos">1425</span>        <span class="c1"># edge cases.</span>
<span class="linenos">1426</span>
<span class="linenos">1427</span>        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span>
<span class="linenos">1428</span>        <span class="c1"># In the example above, this would be {T3: str}</span>
<span class="linenos">1429</span>        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
<span class="linenos">1430</span>            <span class="n">prepare</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;__typing_prepare_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos">1431</span>            <span class="k">if</span> <span class="n">prepare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1432</span>                <span class="n">args</span> <span class="o">=</span> <span class="n">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1433</span>        <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="linenos">1434</span>        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1435</span>        <span class="k">if</span> <span class="n">alen</span> <span class="o">!=</span> <span class="n">plen</span><span class="p">:</span>
<span class="linenos">1436</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too </span><span class="si">{</span><span class="s1">&#39;many&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">alen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">plen</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;few&#39;</span><span class="si">}</span><span class="s2"> arguments for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">;&quot;</span>
<span class="linenos">1437</span>                            <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">plen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1438</span>        <span class="n">new_arg_by_param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
<span class="linenos">1439</span>        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_substitution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">))</span>
<span class="linenos">1440</span>
<span class="linenos">1441</span>    <span class="k">def</span> <span class="nf">_make_substitution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">):</span>
<span class="linenos">1442</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a list of new type arguments.&quot;&quot;&quot;</span>
<span class="linenos">1443</span>        <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos">1444</span>        <span class="k">for</span> <span class="n">old_arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="linenos">1445</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos">1446</span>                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_arg</span><span class="p">)</span>
<span class="linenos">1447</span>                <span class="k">continue</span>
<span class="linenos">1448</span>
<span class="linenos">1449</span>            <span class="n">substfunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="s1">&#39;__typing_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos">1450</span>            <span class="k">if</span> <span class="n">substfunc</span><span class="p">:</span>
<span class="linenos">1451</span>                <span class="n">new_arg</span> <span class="o">=</span> <span class="n">substfunc</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">old_arg</span><span class="p">])</span>
<span class="linenos">1452</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">1453</span>                <span class="n">subparams</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="p">())</span>
<span class="linenos">1454</span>                <span class="k">if</span> <span class="ow">not</span> <span class="n">subparams</span><span class="p">:</span>
<span class="linenos">1455</span>                    <span class="n">new_arg</span> <span class="o">=</span> <span class="n">old_arg</span>
<span class="linenos">1456</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos">1457</span>                    <span class="n">subargs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos">1458</span>                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subparams</span><span class="p">:</span>
<span class="linenos">1459</span>                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
<span class="linenos">1460</span>                            <span class="n">subargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="linenos">1461</span>                        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1462</span>                            <span class="n">subargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="linenos">1463</span>                    <span class="n">new_arg</span> <span class="o">=</span> <span class="n">old_arg</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">subargs</span><span class="p">)]</span>
<span class="linenos">1464</span>
<span class="linenos">1465</span>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1466</span>                <span class="c1"># Consider the following `Callable`.</span>
<span class="linenos">1467</span>                <span class="c1">#   C = Callable[[int], str]</span>
<span class="linenos">1468</span>                <span class="c1"># Here, `C.__args__` should be (int, str) - NOT ([int], str).</span>
<span class="linenos">1469</span>                <span class="c1"># That means that if we had something like...</span>
<span class="linenos">1470</span>                <span class="c1">#   P = ParamSpec(&#39;P&#39;)</span>
<span class="linenos">1471</span>                <span class="c1">#   T = TypeVar(&#39;T&#39;)</span>
<span class="linenos">1472</span>                <span class="c1">#   C = Callable[P, T]</span>
<span class="linenos">1473</span>                <span class="c1">#   D = C[[int, str], float]</span>
<span class="linenos">1474</span>                <span class="c1"># ...we need to be careful; `new_args` should end up as</span>
<span class="linenos">1475</span>                <span class="c1"># `(int, str, float)` rather than `([int, str], float)`.</span>
<span class="linenos">1476</span>                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
<span class="linenos">1477</span>            <span class="k">elif</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">old_arg</span><span class="p">):</span>
<span class="linenos">1478</span>                <span class="c1"># Consider the following `_GenericAlias`, `B`:</span>
<span class="linenos">1479</span>                <span class="c1">#   class A(Generic[*Ts]): ...</span>
<span class="linenos">1480</span>                <span class="c1">#   B = A[T, *Ts]</span>
<span class="linenos">1481</span>                <span class="c1"># If we then do:</span>
<span class="linenos">1482</span>                <span class="c1">#   B[float, int, str]</span>
<span class="linenos">1483</span>                <span class="c1"># The `new_arg` corresponding to `T` will be `float`, and the</span>
<span class="linenos">1484</span>                <span class="c1"># `new_arg` corresponding to `*Ts` will be `(int, str)`. We</span>
<span class="linenos">1485</span>                <span class="c1"># should join all these types together in a flat list</span>
<span class="linenos">1486</span>                <span class="c1"># `(float, int, str)` - so again, we should `extend`.</span>
<span class="linenos">1487</span>                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
<span class="linenos">1488</span>            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1489</span>                <span class="c1"># Corner case:</span>
<span class="linenos">1490</span>                <span class="c1">#    P = ParamSpec(&#39;P&#39;)</span>
<span class="linenos">1491</span>                <span class="c1">#    T = TypeVar(&#39;T&#39;)</span>
<span class="linenos">1492</span>                <span class="c1">#    class Base(Generic[P]): ...</span>
<span class="linenos">1493</span>                <span class="c1"># Can be substituted like this:</span>
<span class="linenos">1494</span>                <span class="c1">#    X = Base[[int, T]]</span>
<span class="linenos">1495</span>                <span class="c1"># In this case, `old_arg` will be a tuple:</span>
<span class="linenos">1496</span>                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
<span class="linenos">1497</span>                    <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_substitution</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">)),</span>
<span class="linenos">1498</span>                <span class="p">)</span>
<span class="linenos">1499</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">1500</span>                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
<span class="linenos">1501</span>        <span class="k">return</span> <span class="n">new_args</span>
<span class="linenos">1502</span>
<span class="linenos">1503</span>    <span class="k">def</span> <span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos">1504</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">,</span>
<span class="linenos">1505</span>                              <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_paramspec_tvars</span><span class="p">)</span>
<span class="linenos">1506</span>
<span class="linenos">1507</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1508</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
<span class="linenos">1509</span>            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
<span class="linenos">1510</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1511</span>            <span class="n">name</span> <span class="o">=</span> <span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
<span class="linenos">1512</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
<span class="linenos">1513</span>            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">])</span>
<span class="linenos">1514</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1515</span>            <span class="c1"># To ensure the repr is eval-able.</span>
<span class="linenos">1516</span>            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;()&quot;</span>
<span class="linenos">1517</span>        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">]&#39;</span>
<span class="linenos">1518</span>
<span class="linenos">1519</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1520</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
<span class="linenos">1521</span>            <span class="n">origin</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
<span class="linenos">1522</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1523</span>            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">1524</span>        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">1525</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1526</span>            <span class="n">args</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
<span class="linenos">1527</span>        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1528</span>
<span class="linenos">1529</span>    <span class="k">def</span> <span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
<span class="linenos">1530</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">_SpecialForm</span><span class="p">):</span>
<span class="linenos">1531</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subclass </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">1532</span>
<span class="linenos">1533</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>  <span class="c1"># generic version of an ABC or built-in class</span>
<span class="linenos">1534</span>            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__mro_entries__</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
<span class="linenos">1535</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">:</span>
<span class="linenos">1536</span>            <span class="k">if</span> <span class="n">Protocol</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">1537</span>                <span class="k">return</span> <span class="p">()</span>
<span class="linenos">1538</span>            <span class="n">i</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1539</span>            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
<span class="linenos">1540</span>                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
<span class="linenos">1541</span>                    <span class="k">return</span> <span class="p">()</span>
<span class="linenos">1542</span>        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span>
<span class="linenos">1543</span>
<span class="linenos">1544</span>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1545</span>        <span class="k">yield</span> <span class="n">Unpack</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
<span class="linenos">1546</span>
<span class="linenos">1547</span>
<span class="linenos">1548</span><span class="c1"># _nparams is the number of accepted parameters, e.g. 0 for Hashable,</span>
<span class="linenos">1549</span><span class="c1"># 1 for List and 2 for Dict.  It may be -1 if variable number of</span>
<span class="linenos">1550</span><span class="c1"># parameters are accepted (needs custom __getitem__).</span>
<span class="linenos">1551</span>
<span class="linenos">1552</span><span class="k">class</span> <span class="nc">_SpecialGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1553</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">nparams</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos">1554</span>        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1555</span>            <span class="n">name</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos">1556</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
<span class="linenos">1557</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">=</span> <span class="n">nparams</span>
<span class="linenos">1558</span>        <span class="k">if</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
<span class="linenos">1559</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A generic version of </span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>
<span class="linenos">1560</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1561</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A generic version of </span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>
<span class="linenos">1562</span>
<span class="linenos">1563</span>    <span class="nd">@_tp_cache</span>
<span class="linenos">1564</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1565</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1566</span>            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
<span class="linenos">1567</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters to generic types must be types.&quot;</span>
<span class="linenos">1568</span>        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
<span class="linenos">1569</span>        <span class="n">_check_generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">)</span>
<span class="linenos">1570</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1571</span>
<span class="linenos">1572</span>    <span class="k">def</span> <span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1573</span>        <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
<span class="linenos">1574</span>                             <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">)</span>
<span class="linenos">1575</span>
<span class="linenos">1576</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1577</span>        <span class="k">return</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
<span class="linenos">1578</span>
<span class="linenos">1579</span>    <span class="k">def</span> <span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="linenos">1580</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_SpecialGenericAlias</span><span class="p">):</span>
<span class="linenos">1581</span>            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
<span class="linenos">1582</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
<span class="linenos">1583</span>            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
<span class="linenos">1584</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="linenos">1585</span>
<span class="linenos">1586</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1587</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
<span class="linenos">1588</span>
<span class="linenos">1589</span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
<span class="linenos">1590</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>
<span class="linenos">1591</span>
<span class="linenos">1592</span>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
<span class="linenos">1593</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
<span class="linenos">1594</span>
<span class="linenos">1595</span><span class="k">class</span> <span class="nc">_CallableGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1596</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1597</span>        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s1">&#39;Callable&#39;</span>
<span class="linenos">1598</span>        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">1599</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="linenos">1600</span>            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
<span class="linenos">1601</span>        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;typing.Callable&#39;</span>
<span class="linenos">1602</span>                <span class="sa">f</span><span class="s1">&#39;[[</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="si">}</span><span class="s1">], &#39;</span>
<span class="linenos">1603</span>                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>
<span class="linenos">1604</span>
<span class="linenos">1605</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1606</span>        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">1607</span>        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
<span class="linenos">1608</span>            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="linenos">1609</span>        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1610</span>
<span class="linenos">1611</span>
<span class="linenos">1612</span><span class="k">class</span> <span class="nc">_CallableType</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1613</span>    <span class="k">def</span> <span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1614</span>        <span class="k">return</span> <span class="n">_CallableGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
<span class="linenos">1615</span>                                     <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">,</span>
<span class="linenos">1616</span>                                     <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">1617</span>
<span class="linenos">1618</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1619</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">1620</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Callable must be used as &quot;</span>
<span class="linenos">1621</span>                            <span class="s2">&quot;Callable[[arg, ...], result].&quot;</span><span class="p">)</span>
<span class="linenos">1622</span>        <span class="n">args</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">params</span>
<span class="linenos">1623</span>        <span class="c1"># This relaxes what args can be on purpose to allow things like</span>
<span class="linenos">1624</span>        <span class="c1"># PEP 612 ParamSpec.  Responsibility for whether a user is using</span>
<span class="linenos">1625</span>        <span class="c1"># Callable[...] properly is deferred to static type checkers.</span>
<span class="linenos">1626</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
<span class="linenos">1627</span>            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">result</span><span class="p">)</span>
<span class="linenos">1628</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1629</span>            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="linenos">1630</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem_inner__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1631</span>
<span class="linenos">1632</span>    <span class="nd">@_tp_cache</span>
<span class="linenos">1633</span>    <span class="k">def</span> <span class="nf">__getitem_inner__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1634</span>        <span class="n">args</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">params</span>
<span class="linenos">1635</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Callable[args, result]: result must be a type.&quot;</span>
<span class="linenos">1636</span>        <span class="n">result</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
<span class="linenos">1637</span>        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
<span class="linenos">1638</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">((</span><span class="n">_TypingEllipsis</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
<span class="linenos">1639</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1640</span>            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
<span class="linenos">1641</span>        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1642</span>        <span class="n">params</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">result</span><span class="p">,)</span>
<span class="linenos">1643</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1644</span>
<span class="linenos">1645</span>
<span class="linenos">1646</span><span class="k">class</span> <span class="nc">_TupleType</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1647</span>    <span class="nd">@_tp_cache</span>
<span class="linenos">1648</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1649</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1650</span>            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
<span class="linenos">1651</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
<span class="linenos">1652</span>            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tuple[t, ...]: t must be a type.&quot;</span>
<span class="linenos">1653</span>            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="linenos">1654</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">((</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">_TypingEllipsis</span><span class="p">))</span>
<span class="linenos">1655</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tuple[t0, t1, ...]: each t must be a type.&quot;</span>
<span class="linenos">1656</span>        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
<span class="linenos">1657</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1658</span>
<span class="linenos">1659</span>
<span class="linenos">1660</span><span class="k">class</span> <span class="nc">_UnionGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1661</span>    <span class="k">def</span> <span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1662</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">params</span><span class="p">]</span>
<span class="linenos">1663</span>
<span class="linenos">1664</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">1665</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">_UnionGenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
<span class="linenos">1666</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">1667</span>        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">1668</span>
<span class="linenos">1669</span>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1670</span>        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>
<span class="linenos">1671</span>
<span class="linenos">1672</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1673</span>        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">1674</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">1675</span>            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos">1676</span>                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Optional[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
<span class="linenos">1677</span>            <span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
<span class="linenos">1678</span>                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Optional[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
<span class="linenos">1679</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
<span class="linenos">1680</span>
<span class="linenos">1681</span>    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="linenos">1682</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="linenos">1683</span>
<span class="linenos">1684</span>    <span class="k">def</span> <span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
<span class="linenos">1685</span>        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
<span class="linenos">1686</span>            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="linenos">1687</span>                <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">1688</span>
<span class="linenos">1689</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1690</span>        <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
<span class="linenos">1691</span>        <span class="k">return</span> <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">Union</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
<span class="linenos">1692</span>
<span class="linenos">1693</span>
<span class="linenos">1694</span><span class="k">def</span> <span class="nf">_value_and_type_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="linenos">1695</span>    <span class="k">return</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
<span class="linenos">1696</span>
<span class="linenos">1697</span>
<span class="linenos">1698</span><span class="k">class</span> <span class="nc">_LiteralGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1699</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">1700</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_LiteralGenericAlias</span><span class="p">):</span>
<span class="linenos">1701</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">1702</span>
<span class="linenos">1703</span>        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>
<span class="linenos">1704</span>
<span class="linenos">1705</span>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1706</span>        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)))</span>
<span class="linenos">1707</span>
<span class="linenos">1708</span>
<span class="linenos">1709</span><span class="k">class</span> <span class="nc">_ConcatenateGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1710</span>    <span class="k">def</span> <span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1711</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
<span class="linenos">1712</span>            <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="linenos">1713</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">):</span>
<span class="linenos">1714</span>            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">1715</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="linenos">1716</span>
<span class="linenos">1717</span>
<span class="linenos">1718</span><span class="nd">@_SpecialForm</span>
<span class="linenos">1719</span><span class="k">def</span> <span class="nf">Unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos">1720</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Type unpack operator.</span>
<span class="linenos">1721</span>
<span class="linenos">1722</span><span class="sd">    The type unpack operator takes the child types from some container type,</span>
<span class="linenos">1723</span><span class="sd">    such as `tuple[int, str]` or a `TypeVarTuple`, and &#39;pulls them out&#39;.</span>
<span class="linenos">1724</span>
<span class="linenos">1725</span><span class="sd">    For example::</span>
<span class="linenos">1726</span>
<span class="linenos">1727</span><span class="sd">        # For some generic class `Foo`:</span>
<span class="linenos">1728</span><span class="sd">        Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]</span>
<span class="linenos">1729</span>
<span class="linenos">1730</span><span class="sd">        Ts = TypeVarTuple(&#39;Ts&#39;)</span>
<span class="linenos">1731</span><span class="sd">        # Specifies that `Bar` is generic in an arbitrary number of types.</span>
<span class="linenos">1732</span><span class="sd">        # (Think of `Ts` as a tuple of an arbitrary number of individual</span>
<span class="linenos">1733</span><span class="sd">        #  `TypeVar`s, which the `Unpack` is &#39;pulling out&#39; directly into the</span>
<span class="linenos">1734</span><span class="sd">        #  `Generic[]`.)</span>
<span class="linenos">1735</span><span class="sd">        class Bar(Generic[Unpack[Ts]]): ...</span>
<span class="linenos">1736</span><span class="sd">        Bar[int]  # Valid</span>
<span class="linenos">1737</span><span class="sd">        Bar[int, str]  # Also valid</span>
<span class="linenos">1738</span>
<span class="linenos">1739</span><span class="sd">    From Python 3.11, this can also be done using the `*` operator::</span>
<span class="linenos">1740</span>
<span class="linenos">1741</span><span class="sd">        Foo[*tuple[int, str]]</span>
<span class="linenos">1742</span><span class="sd">        class Bar(Generic[*Ts]): ...</span>
<span class="linenos">1743</span>
<span class="linenos">1744</span><span class="sd">    Note that there is only some runtime checking of this operator. Not</span>
<span class="linenos">1745</span><span class="sd">    everything the runtime allows may be accepted by static type checkers.</span>
<span class="linenos">1746</span>
<span class="linenos">1747</span><span class="sd">    For more information, see PEP 646.</span>
<span class="linenos">1748</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1749</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
<span class="linenos">1750</span>    <span class="k">return</span> <span class="n">_UnpackGenericAlias</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">item</span><span class="p">,))</span>
<span class="linenos">1751</span>
<span class="linenos">1752</span>
<span class="linenos">1753</span><span class="k">class</span> <span class="nc">_UnpackGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">1754</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1755</span>        <span class="c1"># `Unpack` only takes one argument, so __args__ should contain only</span>
<span class="linenos">1756</span>        <span class="c1"># a single item.</span>
<span class="linenos">1757</span>        <span class="k">return</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="linenos">1758</span>
<span class="linenos">1759</span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="linenos">1760</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__typing_is_unpacked_typevartuple__</span><span class="p">:</span>
<span class="linenos">1761</span>            <span class="k">return</span> <span class="n">args</span>
<span class="linenos">1762</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="linenos">1763</span>
<span class="linenos">1764</span>    <span class="nd">@property</span>
<span class="linenos">1765</span>    <span class="k">def</span> <span class="nf">__typing_unpacked_tuple_args__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1766</span>        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span>
<span class="linenos">1767</span>        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="linenos">1768</span>        <span class="n">arg</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">1769</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
<span class="linenos">1770</span>            <span class="k">assert</span> <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="nb">tuple</span>
<span class="linenos">1771</span>            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">1772</span>        <span class="k">return</span> <span class="kc">None</span>
<span class="linenos">1773</span>
<span class="linenos">1774</span>    <span class="nd">@property</span>
<span class="linenos">1775</span>    <span class="k">def</span> <span class="nf">__typing_is_unpacked_typevartuple__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">1776</span>        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span>
<span class="linenos">1777</span>        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="linenos">1778</span>        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TypeVarTuple</span><span class="p">)</span>
<span class="linenos">1779</span>
<span class="linenos">1780</span>
<span class="linenos">1781</span><span class="k">class</span> <span class="nc">Generic</span><span class="p">:</span>
<span class="linenos">1782</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for generic types.</span>
<span class="linenos">1783</span>
<span class="linenos">1784</span><span class="sd">    A generic type is typically declared by inheriting from</span>
<span class="linenos">1785</span><span class="sd">    this class parameterized with one or more type variables.</span>
<span class="linenos">1786</span><span class="sd">    For example, a generic mapping type might be defined as::</span>
<span class="linenos">1787</span>
<span class="linenos">1788</span><span class="sd">      class Mapping(Generic[KT, VT]):</span>
<span class="linenos">1789</span><span class="sd">          def __getitem__(self, key: KT) -&gt; VT:</span>
<span class="linenos">1790</span><span class="sd">              ...</span>
<span class="linenos">1791</span><span class="sd">          # Etc.</span>
<span class="linenos">1792</span>
<span class="linenos">1793</span><span class="sd">    This class can then be used as follows::</span>
<span class="linenos">1794</span>
<span class="linenos">1795</span><span class="sd">      def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:</span>
<span class="linenos">1796</span><span class="sd">          try:</span>
<span class="linenos">1797</span><span class="sd">              return mapping[key]</span>
<span class="linenos">1798</span><span class="sd">          except KeyError:</span>
<span class="linenos">1799</span><span class="sd">              return default</span>
<span class="linenos">1800</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1801</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">1802</span>    <span class="n">_is_protocol</span> <span class="o">=</span> <span class="kc">False</span>
<span class="linenos">1803</span>
<span class="linenos">1804</span>    <span class="nd">@_tp_cache</span>
<span class="linenos">1805</span>    <span class="k">def</span> <span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1806</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameterizes a generic class.</span>
<span class="linenos">1807</span>
<span class="linenos">1808</span><span class="sd">        At least, parameterizing a generic class is the *main* thing this method</span>
<span class="linenos">1809</span><span class="sd">        does. For example, for some generic class `Foo`, this is called when we</span>
<span class="linenos">1810</span><span class="sd">        do `Foo[int]` - there, with `cls=Foo` and `params=int`.</span>
<span class="linenos">1811</span>
<span class="linenos">1812</span><span class="sd">        However, note that this method is also called when defining generic</span>
<span class="linenos">1813</span><span class="sd">        classes in the first place with `class Foo(Generic[T]): ...`.</span>
<span class="linenos">1814</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">1815</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="linenos">1816</span>            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
<span class="linenos">1817</span>
<span class="linenos">1818</span>        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
<span class="linenos">1819</span>        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">1820</span>            <span class="c1"># Generic and Protocol can only be subscripted with unique type variables.</span>
<span class="linenos">1821</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
<span class="linenos">1822</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">1823</span>                    <span class="sa">f</span><span class="s2">&quot;Parameter list to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">[...] cannot be empty&quot;</span>
<span class="linenos">1824</span>                <span class="p">)</span>
<span class="linenos">1825</span>            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_typevar_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1826</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">1827</span>                    <span class="sa">f</span><span class="s2">&quot;Parameters to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[...] must all be type variables &quot;</span>
<span class="linenos">1828</span>                    <span class="sa">f</span><span class="s2">&quot;or parameter specification variables.&quot;</span><span class="p">)</span>
<span class="linenos">1829</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
<span class="linenos">1830</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">1831</span>                    <span class="sa">f</span><span class="s2">&quot;Parameters to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[...] must all be unique&quot;</span><span class="p">)</span>
<span class="linenos">1832</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1833</span>            <span class="c1"># Subscripting a regular Generic subclass.</span>
<span class="linenos">1834</span>            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">:</span>
<span class="linenos">1835</span>                <span class="n">prepare</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;__typing_prepare_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos">1836</span>                <span class="k">if</span> <span class="n">prepare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1837</span>                    <span class="n">params</span> <span class="o">=</span> <span class="n">prepare</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="linenos">1838</span>            <span class="n">_check_generic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">))</span>
<span class="linenos">1839</span>
<span class="linenos">1840</span>            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos">1841</span>            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">new_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">1842</span>                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
<span class="linenos">1843</span>                    <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
<span class="linenos">1844</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos">1845</span>                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
<span class="linenos">1846</span>            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>
<span class="linenos">1847</span>
<span class="linenos">1848</span>        <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
<span class="linenos">1849</span>                             <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">1850</span>
<span class="linenos">1851</span>    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">1852</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos">1853</span>        <span class="n">tvars</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos">1854</span>        <span class="k">if</span> <span class="s1">&#39;__orig_bases__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
<span class="linenos">1855</span>            <span class="n">error</span> <span class="o">=</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span>
<span class="linenos">1856</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">1857</span>            <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span> <span class="ow">and</span>
<span class="linenos">1858</span>                        <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;Protocol&#39;</span> <span class="ow">and</span>
<span class="linenos">1859</span>                        <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_TypedDictMeta</span><span class="p">)</span>
<span class="linenos">1860</span>        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
<span class="linenos">1861</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot inherit from plain Generic&quot;</span><span class="p">)</span>
<span class="linenos">1862</span>        <span class="k">if</span> <span class="s1">&#39;__orig_bases__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
<span class="linenos">1863</span>            <span class="n">tvars</span> <span class="o">=</span> <span class="n">_collect_parameters</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span><span class="p">)</span>
<span class="linenos">1864</span>            <span class="c1"># Look for Generic[T1, ..., Tn].</span>
<span class="linenos">1865</span>            <span class="c1"># If found, tvars must be a subset of it.</span>
<span class="linenos">1866</span>            <span class="c1"># If not found, tvars is it.</span>
<span class="linenos">1867</span>            <span class="c1"># Also check for and reject plain Generic,</span>
<span class="linenos">1868</span>            <span class="c1"># and reject multiple Generic[...].</span>
<span class="linenos">1869</span>            <span class="n">gvars</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">1870</span>            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span><span class="p">:</span>
<span class="linenos">1871</span>                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span>
<span class="linenos">1872</span>                        <span class="n">base</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">):</span>
<span class="linenos">1873</span>                    <span class="k">if</span> <span class="n">gvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1874</span>                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">1875</span>                            <span class="s2">&quot;Cannot inherit from Generic[...] multiple times.&quot;</span><span class="p">)</span>
<span class="linenos">1876</span>                    <span class="n">gvars</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">__parameters__</span>
<span class="linenos">1877</span>            <span class="k">if</span> <span class="n">gvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">1878</span>                <span class="n">tvarset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tvars</span><span class="p">)</span>
<span class="linenos">1879</span>                <span class="n">gvarset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gvars</span><span class="p">)</span>
<span class="linenos">1880</span>                <span class="k">if</span> <span class="ow">not</span> <span class="n">tvarset</span> <span class="o">&lt;=</span> <span class="n">gvarset</span><span class="p">:</span>
<span class="linenos">1881</span>                    <span class="n">s_vars</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tvars</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gvarset</span><span class="p">)</span>
<span class="linenos">1882</span>                    <span class="n">s_args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gvars</span><span class="p">)</span>
<span class="linenos">1883</span>                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some type variables (</span><span class="si">{</span><span class="n">s_vars</span><span class="si">}</span><span class="s2">) are&quot;</span>
<span class="linenos">1884</span>                                    <span class="sa">f</span><span class="s2">&quot; not listed in Generic[</span><span class="si">{</span><span class="n">s_args</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
<span class="linenos">1885</span>                <span class="n">tvars</span> <span class="o">=</span> <span class="n">gvars</span>
<span class="linenos">1886</span>        <span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tvars</span><span class="p">)</span>
<span class="linenos">1887</span>
<span class="linenos">1888</span>
<span class="linenos">1889</span><span class="k">class</span> <span class="nc">_TypingEllipsis</span><span class="p">:</span>
<span class="linenos">1890</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal placeholder for ... (ellipsis).&quot;&quot;&quot;</span>
<span class="linenos">1891</span>
<span class="linenos">1892</span>
<span class="linenos">1893</span><span class="n">_TYPING_INTERNALS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="s1">&#39;__orig_bases__&#39;</span><span class="p">,</span>  <span class="s1">&#39;__orig_class__&#39;</span><span class="p">,</span>
<span class="linenos">1894</span>                     <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;__final__&#39;</span><span class="p">]</span>
<span class="linenos">1895</span>
<span class="linenos">1896</span><span class="n">_SPECIAL_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__abstractmethods__&#39;</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span>
<span class="linenos">1897</span>                  <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span>
<span class="linenos">1898</span>                  <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">]</span>
<span class="linenos">1899</span>
<span class="linenos">1900</span><span class="c1"># These special attributes will be not collected as protocol members.</span>
<span class="linenos">1901</span><span class="n">EXCLUDED_ATTRIBUTES</span> <span class="o">=</span> <span class="n">_TYPING_INTERNALS</span> <span class="o">+</span> <span class="n">_SPECIAL_NAMES</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_MutableMapping__marker&#39;</span><span class="p">]</span>
<span class="linenos">1902</span>
<span class="linenos">1903</span>
<span class="linenos">1904</span><span class="k">def</span> <span class="nf">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="linenos">1905</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect protocol members from a protocol class objects.</span>
<span class="linenos">1906</span>
<span class="linenos">1907</span><span class="sd">    This includes names actually defined in the class dictionary, as well</span>
<span class="linenos">1908</span><span class="sd">    as names that appear in annotations. Special names (above) are skipped.</span>
<span class="linenos">1909</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1910</span>    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="linenos">1911</span>    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># without object</span>
<span class="linenos">1912</span>        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;Generic&#39;</span><span class="p">):</span>
<span class="linenos">1913</span>            <span class="k">continue</span>
<span class="linenos">1914</span>        <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">1915</span>        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
<span class="linenos">1916</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_abc_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">EXCLUDED_ATTRIBUTES</span><span class="p">:</span>
<span class="linenos">1917</span>                <span class="n">attrs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
<span class="linenos">1918</span>    <span class="k">return</span> <span class="n">attrs</span>
<span class="linenos">1919</span>
<span class="linenos">1920</span>
<span class="linenos">1921</span><span class="k">def</span> <span class="nf">_is_callable_members_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="linenos">1922</span>    <span class="c1"># PEP 544 prohibits using issubclass() with protocols that have non-method members.</span>
<span class="linenos">1923</span>    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>
<span class="linenos">1924</span>
<span class="linenos">1925</span>
<span class="linenos">1926</span><span class="k">def</span> <span class="nf">_no_init_or_replace_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">1927</span>    <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="linenos">1928</span>
<span class="linenos">1929</span>    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
<span class="linenos">1930</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Protocols cannot be instantiated&#39;</span><span class="p">)</span>
<span class="linenos">1931</span>
<span class="linenos">1932</span>    <span class="c1"># Already using a custom `__init__`. No need to calculate correct</span>
<span class="linenos">1933</span>    <span class="c1"># `__init__` to call. This can lead to RecursionError. See bpo-45121.</span>
<span class="linenos">1934</span>    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_no_init_or_replace_init</span><span class="p">:</span>
<span class="linenos">1935</span>        <span class="k">return</span>
<span class="linenos">1936</span>
<span class="linenos">1937</span>    <span class="c1"># Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`.</span>
<span class="linenos">1938</span>    <span class="c1"># The first instantiation of the subclass will call `_no_init_or_replace_init` which</span>
<span class="linenos">1939</span>    <span class="c1"># searches for a proper new `__init__` in the MRO. The new `__init__`</span>
<span class="linenos">1940</span>    <span class="c1"># replaces the subclass&#39; old `__init__` (ie `_no_init_or_replace_init`). Subsequent</span>
<span class="linenos">1941</span>    <span class="c1"># instantiation of the protocol subclass will thus use the new</span>
<span class="linenos">1942</span>    <span class="c1"># `__init__` and no longer call `_no_init_or_replace_init`.</span>
<span class="linenos">1943</span>    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
<span class="linenos">1944</span>        <span class="n">init</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="n">_no_init_or_replace_init</span><span class="p">)</span>
<span class="linenos">1945</span>        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_no_init_or_replace_init</span><span class="p">:</span>
<span class="linenos">1946</span>            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">init</span>
<span class="linenos">1947</span>            <span class="k">break</span>
<span class="linenos">1948</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos">1949</span>        <span class="c1"># should not happen</span>
<span class="linenos">1950</span>        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span>
<span class="linenos">1951</span>
<span class="linenos">1952</span>    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos">1953</span>
<span class="linenos">1954</span>
<span class="linenos">1955</span><span class="k">def</span> <span class="nf">_caller</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;__main__&#39;</span><span class="p">):</span>
<span class="linenos">1956</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">1957</span>        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
<span class="linenos">1958</span>    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>  <span class="c1"># For platforms without _getframe()</span>
<span class="linenos">1959</span>        <span class="k">return</span> <span class="kc">None</span>
<span class="linenos">1960</span>
<span class="linenos">1961</span>
<span class="linenos">1962</span><span class="k">def</span> <span class="nf">_allow_reckless_class_checks</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="linenos">1963</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Allow instance and class checks for special stdlib modules.</span>
<span class="linenos">1964</span>
<span class="linenos">1965</span><span class="sd">    The abc and functools modules indiscriminately call isinstance() and</span>
<span class="linenos">1966</span><span class="sd">    issubclass() on the whole MRO of a user class, which may contain protocols.</span>
<span class="linenos">1967</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">1968</span>    <span class="k">return</span> <span class="n">_caller</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;functools&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span>
<span class="linenos">1969</span>
<span class="linenos">1970</span>
<span class="linenos">1971</span><span class="n">_PROTO_ALLOWLIST</span> <span class="o">=</span> <span class="p">{</span>
<span class="linenos">1972</span>    <span class="s1">&#39;collections.abc&#39;</span><span class="p">:</span> <span class="p">[</span>
<span class="linenos">1973</span>        <span class="s1">&#39;Callable&#39;</span><span class="p">,</span> <span class="s1">&#39;Awaitable&#39;</span><span class="p">,</span> <span class="s1">&#39;Iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;Iterator&#39;</span><span class="p">,</span> <span class="s1">&#39;AsyncIterable&#39;</span><span class="p">,</span>
<span class="linenos">1974</span>        <span class="s1">&#39;Hashable&#39;</span><span class="p">,</span> <span class="s1">&#39;Sized&#39;</span><span class="p">,</span> <span class="s1">&#39;Container&#39;</span><span class="p">,</span> <span class="s1">&#39;Collection&#39;</span><span class="p">,</span> <span class="s1">&#39;Reversible&#39;</span><span class="p">,</span>
<span class="linenos">1975</span>    <span class="p">],</span>
<span class="linenos">1976</span>    <span class="s1">&#39;contextlib&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;AbstractContextManager&#39;</span><span class="p">,</span> <span class="s1">&#39;AbstractAsyncContextManager&#39;</span><span class="p">],</span>
<span class="linenos">1977</span><span class="p">}</span>
<span class="linenos">1978</span>
<span class="linenos">1979</span>
<span class="linenos">1980</span><span class="k">class</span> <span class="nc">_ProtocolMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="linenos">1981</span>    <span class="c1"># This metaclass is really unfortunate and exists only because of</span>
<span class="linenos">1982</span>    <span class="c1"># the lack of __instancehook__.</span>
<span class="linenos">1983</span>    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
<span class="linenos">1984</span>        <span class="c1"># We need this method for situations where attributes are</span>
<span class="linenos">1985</span>        <span class="c1"># assigned in __init__.</span>
<span class="linenos">1986</span>        <span class="k">if</span> <span class="p">(</span>
<span class="linenos">1987</span>            <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>
<span class="linenos">1988</span>            <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>
<span class="linenos">1989</span>            <span class="ow">not</span> <span class="n">_allow_reckless_class_checks</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="linenos">1990</span>        <span class="p">):</span>
<span class="linenos">1991</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Instance and class checks can only be used with&quot;</span>
<span class="linenos">1992</span>                            <span class="s2">&quot; @runtime_checkable protocols&quot;</span><span class="p">)</span>
<span class="linenos">1993</span>
<span class="linenos">1994</span>        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
<span class="linenos">1995</span>                <span class="n">_is_callable_members_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span> <span class="ow">and</span>
<span class="linenos">1996</span>                <span class="nb">issubclass</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)):</span>
<span class="linenos">1997</span>            <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">1998</span>        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
<span class="linenos">1999</span>            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span>
<span class="linenos">2000</span>                    <span class="c1"># All *methods* can be blocked by setting them to None.</span>
<span class="linenos">2001</span>                    <span class="p">(</span><span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span>
<span class="linenos">2002</span>                     <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos">2003</span>                    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">)):</span>
<span class="linenos">2004</span>                <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">2005</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
<span class="linenos">2006</span>
<span class="linenos">2007</span>
<span class="linenos">2008</span><span class="k">class</span> <span class="nc">Protocol</span><span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ProtocolMeta</span><span class="p">):</span>
<span class="linenos">2009</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for protocol classes.</span>
<span class="linenos">2010</span>
<span class="linenos">2011</span><span class="sd">    Protocol classes are defined as::</span>
<span class="linenos">2012</span>
<span class="linenos">2013</span><span class="sd">        class Proto(Protocol):</span>
<span class="linenos">2014</span><span class="sd">            def meth(self) -&gt; int:</span>
<span class="linenos">2015</span><span class="sd">                ...</span>
<span class="linenos">2016</span>
<span class="linenos">2017</span><span class="sd">    Such classes are primarily used with static type checkers that recognize</span>
<span class="linenos">2018</span><span class="sd">    structural subtyping (static duck-typing).</span>
<span class="linenos">2019</span>
<span class="linenos">2020</span><span class="sd">    For example::</span>
<span class="linenos">2021</span>
<span class="linenos">2022</span><span class="sd">        class C:</span>
<span class="linenos">2023</span><span class="sd">            def meth(self) -&gt; int:</span>
<span class="linenos">2024</span><span class="sd">                return 0</span>
<span class="linenos">2025</span>
<span class="linenos">2026</span><span class="sd">        def func(x: Proto) -&gt; int:</span>
<span class="linenos">2027</span><span class="sd">            return x.meth()</span>
<span class="linenos">2028</span>
<span class="linenos">2029</span><span class="sd">        func(C())  # Passes static type check</span>
<span class="linenos">2030</span>
<span class="linenos">2031</span><span class="sd">    See PEP 544 for details. Protocol classes decorated with</span>
<span class="linenos">2032</span><span class="sd">    @typing.runtime_checkable act as simple-minded runtime protocols that check</span>
<span class="linenos">2033</span><span class="sd">    only the presence of given attributes, ignoring their type signatures.</span>
<span class="linenos">2034</span><span class="sd">    Protocol classes can be generic, they are defined as::</span>
<span class="linenos">2035</span>
<span class="linenos">2036</span><span class="sd">        class GenProto(Protocol[T]):</span>
<span class="linenos">2037</span><span class="sd">            def meth(self) -&gt; T:</span>
<span class="linenos">2038</span><span class="sd">                ...</span>
<span class="linenos">2039</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2040</span>
<span class="linenos">2041</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2042</span>    <span class="n">_is_protocol</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos">2043</span>    <span class="n">_is_runtime_protocol</span> <span class="o">=</span> <span class="kc">False</span>
<span class="linenos">2044</span>
<span class="linenos">2045</span>    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">2046</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="linenos">2047</span>
<span class="linenos">2048</span>        <span class="c1"># Determine if this is a protocol or a concrete subclass.</span>
<span class="linenos">2049</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
<span class="linenos">2050</span>            <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">Protocol</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)</span>
<span class="linenos">2051</span>
<span class="linenos">2052</span>        <span class="c1"># Set (or override) the protocol subclass hook.</span>
<span class="linenos">2053</span>        <span class="k">def</span> <span class="nf">_proto_hook</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
<span class="linenos">2054</span>            <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
<span class="linenos">2055</span>                <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">2056</span>
<span class="linenos">2057</span>            <span class="c1"># First, perform various sanity checks.</span>
<span class="linenos">2058</span>            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
<span class="linenos">2059</span>                <span class="k">if</span> <span class="n">_allow_reckless_class_checks</span><span class="p">():</span>
<span class="linenos">2060</span>                    <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">2061</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Instance and class checks can only be used with&quot;</span>
<span class="linenos">2062</span>                                <span class="s2">&quot; @runtime_checkable protocols&quot;</span><span class="p">)</span>
<span class="linenos">2063</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_callable_members_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="linenos">2064</span>                <span class="k">if</span> <span class="n">_allow_reckless_class_checks</span><span class="p">():</span>
<span class="linenos">2065</span>                    <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">2066</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Protocols with non-method members&quot;</span>
<span class="linenos">2067</span>                                <span class="s2">&quot; don&#39;t support issubclass()&quot;</span><span class="p">)</span>
<span class="linenos">2068</span>            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos">2069</span>                <span class="c1"># Same error message as for issubclass(1, int).</span>
<span class="linenos">2070</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;issubclass() arg 1 must be a class&#39;</span><span class="p">)</span>
<span class="linenos">2071</span>
<span class="linenos">2072</span>            <span class="c1"># Second, perform the actual structural compatibility check.</span>
<span class="linenos">2073</span>            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="linenos">2074</span>                <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
<span class="linenos">2075</span>                    <span class="c1"># Check if the members appears in the class dictionary...</span>
<span class="linenos">2076</span>                    <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
<span class="linenos">2077</span>                        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2078</span>                            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">2079</span>                        <span class="k">break</span>
<span class="linenos">2080</span>
<span class="linenos">2081</span>                    <span class="c1"># ...or in annotations, if it is a sub-protocol.</span>
<span class="linenos">2082</span>                    <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">2083</span>                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span> <span class="ow">and</span>
<span class="linenos">2084</span>                            <span class="n">attr</span> <span class="ow">in</span> <span class="n">annotations</span> <span class="ow">and</span>
<span class="linenos">2085</span>                            <span class="nb">issubclass</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">):</span>
<span class="linenos">2086</span>                        <span class="k">break</span>
<span class="linenos">2087</span>                <span class="k">else</span><span class="p">:</span>
<span class="linenos">2088</span>                    <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">2089</span>            <span class="k">return</span> <span class="kc">True</span>
<span class="linenos">2090</span>
<span class="linenos">2091</span>        <span class="k">if</span> <span class="s1">&#39;__subclasshook__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
<span class="linenos">2092</span>            <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasshook__</span> <span class="o">=</span> <span class="n">_proto_hook</span>
<span class="linenos">2093</span>
<span class="linenos">2094</span>        <span class="c1"># We have nothing more to do for non-protocols...</span>
<span class="linenos">2095</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
<span class="linenos">2096</span>            <span class="k">return</span>
<span class="linenos">2097</span>
<span class="linenos">2098</span>        <span class="c1"># ... otherwise check consistency of bases, and prohibit instantiation.</span>
<span class="linenos">2099</span>        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
<span class="linenos">2100</span>            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">base</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">or</span>
<span class="linenos">2101</span>                    <span class="n">base</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">in</span> <span class="n">_PROTO_ALLOWLIST</span> <span class="ow">and</span>
<span class="linenos">2102</span>                    <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">_PROTO_ALLOWLIST</span><span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span> <span class="ow">or</span>
<span class="linenos">2103</span>                    <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">):</span>
<span class="linenos">2104</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Protocols can only inherit from other&#39;</span>
<span class="linenos">2105</span>                                <span class="s1">&#39; protocols, got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
<span class="linenos">2106</span>        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="n">Protocol</span><span class="o">.</span><span class="fm">__init__</span><span class="p">:</span>
<span class="linenos">2107</span>            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">_no_init_or_replace_init</span>
<span class="linenos">2108</span>
<span class="linenos">2109</span>
<span class="linenos">2110</span><span class="k">class</span> <span class="nc">_AnnotatedAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">2111</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Runtime representation of an annotated type.</span>
<span class="linenos">2112</span>
<span class="linenos">2113</span><span class="sd">    At its core &#39;Annotated[t, dec1, dec2, ...]&#39; is an alias for the type &#39;t&#39;</span>
<span class="linenos">2114</span><span class="sd">    with extra annotations. The alias behaves like a normal typing alias.</span>
<span class="linenos">2115</span><span class="sd">    Instantiating is the same as instantiating the underlying type; binding</span>
<span class="linenos">2116</span><span class="sd">    it to types is also the same.</span>
<span class="linenos">2117</span>
<span class="linenos">2118</span><span class="sd">    The metadata itself is stored in a &#39;__metadata__&#39; attribute as a tuple.</span>
<span class="linenos">2119</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2120</span>
<span class="linenos">2121</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
<span class="linenos">2122</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
<span class="linenos">2123</span>            <span class="n">metadata</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">+</span> <span class="n">metadata</span>
<span class="linenos">2124</span>            <span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">2125</span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
<span class="linenos">2126</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">=</span> <span class="n">metadata</span>
<span class="linenos">2127</span>
<span class="linenos">2128</span>    <span class="k">def</span> <span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">2129</span>        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
<span class="linenos">2130</span>        <span class="n">new_type</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="linenos">2131</span>        <span class="k">return</span> <span class="n">_AnnotatedAlias</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
<span class="linenos">2132</span>
<span class="linenos">2133</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">2134</span>        <span class="k">return</span> <span class="s2">&quot;typing.Annotated[</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="linenos">2135</span>            <span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">),</span>
<span class="linenos">2136</span>            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
<span class="linenos">2137</span>        <span class="p">)</span>
<span class="linenos">2138</span>
<span class="linenos">2139</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">2140</span>        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span>
<span class="linenos">2141</span>            <span class="n">Annotated</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span>
<span class="linenos">2142</span>        <span class="p">)</span>
<span class="linenos">2143</span>
<span class="linenos">2144</span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">2145</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
<span class="linenos">2146</span>            <span class="k">return</span> <span class="bp">NotImplemented</span>
<span class="linenos">2147</span>        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">2148</span>                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
<span class="linenos">2149</span>
<span class="linenos">2150</span>    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">2151</span>        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">))</span>
<span class="linenos">2152</span>
<span class="linenos">2153</span>    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="linenos">2154</span>        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
<span class="linenos">2155</span>            <span class="k">return</span> <span class="s1">&#39;Annotated&#39;</span>
<span class="linenos">2156</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
<span class="linenos">2157</span>
<span class="linenos">2158</span>
<span class="linenos">2159</span><span class="k">class</span> <span class="nc">Annotated</span><span class="p">:</span>
<span class="linenos">2160</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Add context-specific metadata to a type.</span>
<span class="linenos">2161</span>
<span class="linenos">2162</span><span class="sd">    Example: Annotated[int, runtime_check.Unsigned] indicates to the</span>
<span class="linenos">2163</span><span class="sd">    hypothetical runtime_check module that this type is an unsigned int.</span>
<span class="linenos">2164</span><span class="sd">    Every other consumer of this type can ignore this metadata and treat</span>
<span class="linenos">2165</span><span class="sd">    this type as int.</span>
<span class="linenos">2166</span>
<span class="linenos">2167</span><span class="sd">    The first argument to Annotated must be a valid type.</span>
<span class="linenos">2168</span>
<span class="linenos">2169</span><span class="sd">    Details:</span>
<span class="linenos">2170</span>
<span class="linenos">2171</span><span class="sd">    - It&#39;s an error to call `Annotated` with less than two arguments.</span>
<span class="linenos">2172</span><span class="sd">    - Access the metadata via the ``__metadata__`` attribute::</span>
<span class="linenos">2173</span>
<span class="linenos">2174</span><span class="sd">        assert Annotated[int, &#39;$&#39;].__metadata__ == (&#39;$&#39;,)</span>
<span class="linenos">2175</span>
<span class="linenos">2176</span><span class="sd">    - Nested Annotated types are flattened::</span>
<span class="linenos">2177</span>
<span class="linenos">2178</span><span class="sd">        assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]</span>
<span class="linenos">2179</span>
<span class="linenos">2180</span><span class="sd">    - Instantiating an annotated type is equivalent to instantiating the</span>
<span class="linenos">2181</span><span class="sd">    underlying type::</span>
<span class="linenos">2182</span>
<span class="linenos">2183</span><span class="sd">        assert Annotated[C, Ann1](5) == C(5)</span>
<span class="linenos">2184</span>
<span class="linenos">2185</span><span class="sd">    - Annotated can be used as a generic type alias::</span>
<span class="linenos">2186</span>
<span class="linenos">2187</span><span class="sd">        Optimized: TypeAlias = Annotated[T, runtime.Optimize()]</span>
<span class="linenos">2188</span><span class="sd">        assert Optimized[int] == Annotated[int, runtime.Optimize()]</span>
<span class="linenos">2189</span>
<span class="linenos">2190</span><span class="sd">        OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]</span>
<span class="linenos">2191</span><span class="sd">        assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]</span>
<span class="linenos">2192</span>
<span class="linenos">2193</span><span class="sd">    - Annotated cannot be used with an unpacked TypeVarTuple::</span>
<span class="linenos">2194</span>
<span class="linenos">2195</span><span class="sd">        Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid</span>
<span class="linenos">2196</span>
<span class="linenos">2197</span><span class="sd">      This would be equivalent to::</span>
<span class="linenos">2198</span>
<span class="linenos">2199</span><span class="sd">        Annotated[T1, T2, T3, ..., Ann1]</span>
<span class="linenos">2200</span>
<span class="linenos">2201</span><span class="sd">      where T1, T2 etc. are TypeVars, which would be invalid, because</span>
<span class="linenos">2202</span><span class="sd">      only one type should be passed to Annotated.</span>
<span class="linenos">2203</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2204</span>
<span class="linenos">2205</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2206</span>
<span class="linenos">2207</span>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">2208</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="p">)</span>
<span class="linenos">2209</span>
<span class="linenos">2210</span>    <span class="nd">@_tp_cache</span>
<span class="linenos">2211</span>    <span class="k">def</span> <span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="linenos">2212</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">2213</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Annotated[...] should be used &quot;</span>
<span class="linenos">2214</span>                            <span class="s2">&quot;with at least two arguments (a type and an &quot;</span>
<span class="linenos">2215</span>                            <span class="s2">&quot;annotation).&quot;</span><span class="p">)</span>
<span class="linenos">2216</span>        <span class="k">if</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="linenos">2217</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Annotated[...] should not be used with an &quot;</span>
<span class="linenos">2218</span>                            <span class="s2">&quot;unpacked TypeVarTuple&quot;</span><span class="p">)</span>
<span class="linenos">2219</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
<span class="linenos">2220</span>        <span class="n">origin</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">2221</span>        <span class="n">metadata</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="linenos">2222</span>        <span class="k">return</span> <span class="n">_AnnotatedAlias</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
<span class="linenos">2223</span>
<span class="linenos">2224</span>    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">2225</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">2226</span>            <span class="s2">&quot;Cannot subclass </span><span class="si">{}</span><span class="s2">.Annotated&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
<span class="linenos">2227</span>        <span class="p">)</span>
<span class="linenos">2228</span>
<span class="linenos">2229</span>
<span class="linenos">2230</span><span class="k">def</span> <span class="nf">runtime_checkable</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="linenos">2231</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Mark a protocol class as a runtime protocol.</span>
<span class="linenos">2232</span>
<span class="linenos">2233</span><span class="sd">    Such protocol can be used with isinstance() and issubclass().</span>
<span class="linenos">2234</span><span class="sd">    Raise TypeError if applied to a non-protocol class.</span>
<span class="linenos">2235</span><span class="sd">    This allows a simple-minded structural check very similar to</span>
<span class="linenos">2236</span><span class="sd">    one trick ponies in collections.abc such as Iterable.</span>
<span class="linenos">2237</span>
<span class="linenos">2238</span><span class="sd">    For example::</span>
<span class="linenos">2239</span>
<span class="linenos">2240</span><span class="sd">        @runtime_checkable</span>
<span class="linenos">2241</span><span class="sd">        class Closable(Protocol):</span>
<span class="linenos">2242</span><span class="sd">            def close(self): ...</span>
<span class="linenos">2243</span>
<span class="linenos">2244</span><span class="sd">        assert isinstance(open(&#39;/some/file&#39;), Closable)</span>
<span class="linenos">2245</span>
<span class="linenos">2246</span><span class="sd">    Warning: this will check only the presence of the required methods,</span>
<span class="linenos">2247</span><span class="sd">    not their type signatures!</span>
<span class="linenos">2248</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2249</span>    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
<span class="linenos">2250</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;@runtime_checkable can be only applied to protocol classes,&#39;</span>
<span class="linenos">2251</span>                        <span class="s1">&#39; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
<span class="linenos">2252</span>    <span class="bp">cls</span><span class="o">.</span><span class="n">_is_runtime_protocol</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos">2253</span>    <span class="k">return</span> <span class="bp">cls</span>
<span class="linenos">2254</span>
<span class="linenos">2255</span>
<span class="linenos">2256</span><span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="linenos">2257</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Cast a value to a type.</span>
<span class="linenos">2258</span>
<span class="linenos">2259</span><span class="sd">    This returns the value unchanged.  To the type checker this</span>
<span class="linenos">2260</span><span class="sd">    signals that the return value has the designated type, but at</span>
<span class="linenos">2261</span><span class="sd">    runtime we intentionally don&#39;t check anything (we want this</span>
<span class="linenos">2262</span><span class="sd">    to be as fast as possible).</span>
<span class="linenos">2263</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2264</span>    <span class="k">return</span> <span class="n">val</span>
<span class="linenos">2265</span>
<span class="linenos">2266</span>
<span class="linenos">2267</span><span class="k">def</span> <span class="nf">assert_type</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="linenos">2268</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Ask a static type checker to confirm that the value is of the given type.</span>
<span class="linenos">2269</span>
<span class="linenos">2270</span><span class="sd">    At runtime this does nothing: it returns the first argument unchanged with no</span>
<span class="linenos">2271</span><span class="sd">    checks or side effects, no matter the actual type of the argument.</span>
<span class="linenos">2272</span>
<span class="linenos">2273</span><span class="sd">    When a static type checker encounters a call to assert_type(), it</span>
<span class="linenos">2274</span><span class="sd">    emits an error if the value is not of the specified type::</span>
<span class="linenos">2275</span>
<span class="linenos">2276</span><span class="sd">        def greet(name: str) -&gt; None:</span>
<span class="linenos">2277</span><span class="sd">            assert_type(name, str)  # OK</span>
<span class="linenos">2278</span><span class="sd">            assert_type(name, int)  # type checker error</span>
<span class="linenos">2279</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2280</span>    <span class="k">return</span> <span class="n">val</span>
<span class="linenos">2281</span>
<span class="linenos">2282</span>
<span class="linenos">2283</span><span class="n">_allowed_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">,</span>
<span class="linenos">2284</span>                  <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span>
<span class="linenos">2285</span>                  <span class="n">WrapperDescriptorType</span><span class="p">,</span> <span class="n">MethodWrapperType</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">)</span>
<span class="linenos">2286</span>
<span class="linenos">2287</span>
<span class="linenos">2288</span><span class="k">def</span> <span class="nf">get_type_hints</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">globalns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">localns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="linenos">2289</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Return type hints for an object.</span>
<span class="linenos">2290</span>
<span class="linenos">2291</span><span class="sd">    This is often the same as obj.__annotations__, but it handles</span>
<span class="linenos">2292</span><span class="sd">    forward references encoded as string literals and recursively replaces all</span>
<span class="linenos">2293</span><span class="sd">    &#39;Annotated[T, ...]&#39; with &#39;T&#39; (unless &#39;include_extras=True&#39;).</span>
<span class="linenos">2294</span>
<span class="linenos">2295</span><span class="sd">    The argument may be a module, class, method, or function. The annotations</span>
<span class="linenos">2296</span><span class="sd">    are returned as a dictionary. For classes, annotations include also</span>
<span class="linenos">2297</span><span class="sd">    inherited members.</span>
<span class="linenos">2298</span>
<span class="linenos">2299</span><span class="sd">    TypeError is raised if the argument is not of a type that can contain</span>
<span class="linenos">2300</span><span class="sd">    annotations, and an empty dictionary is returned if no annotations are</span>
<span class="linenos">2301</span><span class="sd">    present.</span>
<span class="linenos">2302</span>
<span class="linenos">2303</span><span class="sd">    BEWARE -- the behavior of globalns and localns is counterintuitive</span>
<span class="linenos">2304</span><span class="sd">    (unless you are familiar with how eval() and exec() work).  The</span>
<span class="linenos">2305</span><span class="sd">    search order is locals first, then globals.</span>
<span class="linenos">2306</span>
<span class="linenos">2307</span><span class="sd">    - If no dict arguments are passed, an attempt is made to use the</span>
<span class="linenos">2308</span><span class="sd">      globals from obj (or the respective module&#39;s globals for classes),</span>
<span class="linenos">2309</span><span class="sd">      and these are also used as the locals.  If the object does not appear</span>
<span class="linenos">2310</span><span class="sd">      to have globals, an empty dictionary is used.  For classes, the search</span>
<span class="linenos">2311</span><span class="sd">      order is globals first then locals.</span>
<span class="linenos">2312</span>
<span class="linenos">2313</span><span class="sd">    - If one dict argument is passed, it is used for both globals and</span>
<span class="linenos">2314</span><span class="sd">      locals.</span>
<span class="linenos">2315</span>
<span class="linenos">2316</span><span class="sd">    - If two dict arguments are passed, they specify globals and</span>
<span class="linenos">2317</span><span class="sd">      locals, respectively.</span>
<span class="linenos">2318</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2319</span>    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__no_type_check__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
<span class="linenos">2320</span>        <span class="k">return</span> <span class="p">{}</span>
<span class="linenos">2321</span>    <span class="c1"># Classes require a special treatment.</span>
<span class="linenos">2322</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos">2323</span>        <span class="n">hints</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos">2324</span>        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">):</span>
<span class="linenos">2325</span>            <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2326</span>                <span class="n">base_globals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">2327</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">2328</span>                <span class="n">base_globals</span> <span class="o">=</span> <span class="n">globalns</span>
<span class="linenos">2329</span>            <span class="n">ann</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">2330</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GetSetDescriptorType</span><span class="p">):</span>
<span class="linenos">2331</span>                <span class="n">ann</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos">2332</span>            <span class="n">base_locals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">localns</span>
<span class="linenos">2333</span>            <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2334</span>                <span class="c1"># This is surprising, but required.  Before Python 3.10,</span>
<span class="linenos">2335</span>                <span class="c1"># get_type_hints only evaluated the globalns of</span>
<span class="linenos">2336</span>                <span class="c1"># a class.  To maintain backwards compatibility, we reverse</span>
<span class="linenos">2337</span>                <span class="c1"># the globalns and localns order so that eval() looks into</span>
<span class="linenos">2338</span>                <span class="c1"># *base_globals* first rather than *base_locals*.</span>
<span class="linenos">2339</span>                <span class="c1"># This only affects ForwardRefs.</span>
<span class="linenos">2340</span>                <span class="n">base_globals</span><span class="p">,</span> <span class="n">base_locals</span> <span class="o">=</span> <span class="n">base_locals</span><span class="p">,</span> <span class="n">base_globals</span>
<span class="linenos">2341</span>            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ann</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="linenos">2342</span>                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2343</span>                    <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="linenos">2344</span>                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
<span class="linenos">2345</span>                    <span class="n">value</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos">2346</span>                <span class="n">value</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base_globals</span><span class="p">,</span> <span class="n">base_locals</span><span class="p">)</span>
<span class="linenos">2347</span>                <span class="n">hints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="linenos">2348</span>        <span class="k">return</span> <span class="n">hints</span> <span class="k">if</span> <span class="n">include_extras</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="linenos">2349</span>
<span class="linenos">2350</span>    <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2351</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
<span class="linenos">2352</span>            <span class="n">globalns</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="linenos">2353</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">2354</span>            <span class="n">nsobj</span> <span class="o">=</span> <span class="n">obj</span>
<span class="linenos">2355</span>            <span class="c1"># Find globalns for the unwrapped object.</span>
<span class="linenos">2356</span>            <span class="k">while</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nsobj</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">):</span>
<span class="linenos">2357</span>                <span class="n">nsobj</span> <span class="o">=</span> <span class="n">nsobj</span><span class="o">.</span><span class="n">__wrapped__</span>
<span class="linenos">2358</span>            <span class="n">globalns</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nsobj</span><span class="p">,</span> <span class="s1">&#39;__globals__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">2359</span>        <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2360</span>            <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
<span class="linenos">2361</span>    <span class="k">elif</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2362</span>        <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
<span class="linenos">2363</span>    <span class="n">hints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="linenos">2364</span>    <span class="k">if</span> <span class="n">hints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2365</span>        <span class="c1"># Return empty annotations for something that _could_ have them.</span>
<span class="linenos">2366</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_allowed_types</span><span class="p">):</span>
<span class="linenos">2367</span>            <span class="k">return</span> <span class="p">{}</span>
<span class="linenos">2368</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">2369</span>            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a module, class, method, &#39;</span>
<span class="linenos">2370</span>                            <span class="s1">&#39;or function.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="linenos">2371</span>    <span class="n">hints</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span>
<span class="linenos">2372</span>    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="linenos">2373</span>        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2374</span>            <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="linenos">2375</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
<span class="linenos">2376</span>            <span class="c1"># class-level forward refs were handled above, this must be either</span>
<span class="linenos">2377</span>            <span class="c1"># a module-level annotation or a function argument annotation</span>
<span class="linenos">2378</span>            <span class="n">value</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span>
<span class="linenos">2379</span>                <span class="n">value</span><span class="p">,</span>
<span class="linenos">2380</span>                <span class="n">is_argument</span><span class="o">=</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">),</span>
<span class="linenos">2381</span>                <span class="n">is_class</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="linenos">2382</span>            <span class="p">)</span>
<span class="linenos">2383</span>        <span class="n">hints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">)</span>
<span class="linenos">2384</span>    <span class="k">return</span> <span class="n">hints</span> <span class="k">if</span> <span class="n">include_extras</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="linenos">2385</span>
<span class="linenos">2386</span>
<span class="linenos">2387</span><span class="k">def</span> <span class="nf">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="linenos">2388</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Strip the annotations from a given type.&quot;&quot;&quot;</span>
<span class="linenos">2389</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
<span class="linenos">2390</span>        <span class="k">return</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
<span class="linenos">2391</span>    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;__origin__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Required</span><span class="p">,</span> <span class="n">NotRequired</span><span class="p">):</span>
<span class="linenos">2392</span>        <span class="k">return</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="linenos">2393</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
<span class="linenos">2394</span>        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">2395</span>        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
<span class="linenos">2396</span>            <span class="k">return</span> <span class="n">t</span>
<span class="linenos">2397</span>        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">stripped_args</span><span class="p">)</span>
<span class="linenos">2398</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
<span class="linenos">2399</span>        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">2400</span>        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
<span class="linenos">2401</span>            <span class="k">return</span> <span class="n">t</span>
<span class="linenos">2402</span>        <span class="k">return</span> <span class="n">GenericAlias</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">stripped_args</span><span class="p">)</span>
<span class="linenos">2403</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
<span class="linenos">2404</span>        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
<span class="linenos">2405</span>        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
<span class="linenos">2406</span>            <span class="k">return</span> <span class="n">t</span>
<span class="linenos">2407</span>        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">stripped_args</span><span class="p">)</span>
<span class="linenos">2408</span>
<span class="linenos">2409</span>    <span class="k">return</span> <span class="n">t</span>
<span class="linenos">2410</span>
<span class="linenos">2411</span>
<span class="linenos">2412</span><span class="k">def</span> <span class="nf">get_origin</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
<span class="linenos">2413</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the unsubscripted version of a type.</span>
<span class="linenos">2414</span>
<span class="linenos">2415</span><span class="sd">    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,</span>
<span class="linenos">2416</span><span class="sd">    Annotated, and others. Return None for unsupported types.</span>
<span class="linenos">2417</span>
<span class="linenos">2418</span><span class="sd">    Examples::</span>
<span class="linenos">2419</span>
<span class="linenos">2420</span><span class="sd">        assert get_origin(Literal[42]) is Literal</span>
<span class="linenos">2421</span><span class="sd">        assert get_origin(int) is None</span>
<span class="linenos">2422</span><span class="sd">        assert get_origin(ClassVar[int]) is ClassVar</span>
<span class="linenos">2423</span><span class="sd">        assert get_origin(Generic) is Generic</span>
<span class="linenos">2424</span><span class="sd">        assert get_origin(Generic[T]) is Generic</span>
<span class="linenos">2425</span><span class="sd">        assert get_origin(Union[T, int]) is Union</span>
<span class="linenos">2426</span><span class="sd">        assert get_origin(List[Tuple[T, T]][int]) is list</span>
<span class="linenos">2427</span><span class="sd">        assert get_origin(P.args) is P</span>
<span class="linenos">2428</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2429</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
<span class="linenos">2430</span>        <span class="k">return</span> <span class="n">Annotated</span>
<span class="linenos">2431</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="p">(</span><span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">,</span>
<span class="linenos">2432</span>                       <span class="n">ParamSpecArgs</span><span class="p">,</span> <span class="n">ParamSpecKwargs</span><span class="p">)):</span>
<span class="linenos">2433</span>        <span class="k">return</span> <span class="n">tp</span><span class="o">.</span><span class="n">__origin__</span>
<span class="linenos">2434</span>    <span class="k">if</span> <span class="n">tp</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">:</span>
<span class="linenos">2435</span>        <span class="k">return</span> <span class="n">Generic</span>
<span class="linenos">2436</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
<span class="linenos">2437</span>        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span>
<span class="linenos">2438</span>    <span class="k">return</span> <span class="kc">None</span>
<span class="linenos">2439</span>
<span class="linenos">2440</span>
<span class="linenos">2441</span><span class="k">def</span> <span class="nf">get_args</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
<span class="linenos">2442</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Get type arguments with all substitutions performed.</span>
<span class="linenos">2443</span>
<span class="linenos">2444</span><span class="sd">    For unions, basic simplifications used by Union constructor are performed.</span>
<span class="linenos">2445</span>
<span class="linenos">2446</span><span class="sd">    Examples::</span>
<span class="linenos">2447</span>
<span class="linenos">2448</span><span class="sd">        assert get_args(Dict[str, int]) == (str, int)</span>
<span class="linenos">2449</span><span class="sd">        assert get_args(int) == ()</span>
<span class="linenos">2450</span><span class="sd">        assert get_args(Union[int, Union[T, int], str][int]) == (int, str)</span>
<span class="linenos">2451</span><span class="sd">        assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])</span>
<span class="linenos">2452</span><span class="sd">        assert get_args(Callable[[], T][int]) == ([], int)</span>
<span class="linenos">2453</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2454</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
<span class="linenos">2455</span>        <span class="k">return</span> <span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span> <span class="o">+</span> <span class="n">tp</span><span class="o">.</span><span class="n">__metadata__</span>
<span class="linenos">2456</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">)):</span>
<span class="linenos">2457</span>        <span class="n">res</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">2458</span>        <span class="k">if</span> <span class="n">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
<span class="linenos">2459</span>            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="linenos">2460</span>        <span class="k">return</span> <span class="n">res</span>
<span class="linenos">2461</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
<span class="linenos">2462</span>        <span class="k">return</span> <span class="n">tp</span><span class="o">.</span><span class="n">__args__</span>
<span class="linenos">2463</span>    <span class="k">return</span> <span class="p">()</span>
<span class="linenos">2464</span>
<span class="linenos">2465</span>
<span class="linenos">2466</span><span class="k">def</span> <span class="nf">is_typeddict</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
<span class="linenos">2467</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an annotation is a TypedDict class.</span>
<span class="linenos">2468</span>
<span class="linenos">2469</span><span class="sd">    For example::</span>
<span class="linenos">2470</span>
<span class="linenos">2471</span><span class="sd">        class Film(TypedDict):</span>
<span class="linenos">2472</span><span class="sd">            title: str</span>
<span class="linenos">2473</span><span class="sd">            year: int</span>
<span class="linenos">2474</span>
<span class="linenos">2475</span><span class="sd">        is_typeddict(Film)              # =&gt; True</span>
<span class="linenos">2476</span><span class="sd">        is_typeddict(Union[list, str])  # =&gt; False</span>
<span class="linenos">2477</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2478</span>    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_TypedDictMeta</span><span class="p">)</span>
<span class="linenos">2479</span>
<span class="linenos">2480</span>
<span class="linenos">2481</span><span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span> <span class="o">=</span> <span class="mi">100</span>
<span class="linenos">2482</span>
<span class="linenos">2483</span>
<span class="linenos">2484</span><span class="k">def</span> <span class="nf">assert_never</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
<span class="linenos">2485</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Statically assert that a line of code is unreachable.</span>
<span class="linenos">2486</span>
<span class="linenos">2487</span><span class="sd">    Example::</span>
<span class="linenos">2488</span>
<span class="linenos">2489</span><span class="sd">        def int_or_str(arg: int | str) -&gt; None:</span>
<span class="linenos">2490</span><span class="sd">            match arg:</span>
<span class="linenos">2491</span><span class="sd">                case int():</span>
<span class="linenos">2492</span><span class="sd">                    print(&quot;It&#39;s an int&quot;)</span>
<span class="linenos">2493</span><span class="sd">                case str():</span>
<span class="linenos">2494</span><span class="sd">                    print(&quot;It&#39;s a str&quot;)</span>
<span class="linenos">2495</span><span class="sd">                case _:</span>
<span class="linenos">2496</span><span class="sd">                    assert_never(arg)</span>
<span class="linenos">2497</span>
<span class="linenos">2498</span><span class="sd">    If a type checker finds that a call to assert_never() is</span>
<span class="linenos">2499</span><span class="sd">    reachable, it will emit an error.</span>
<span class="linenos">2500</span>
<span class="linenos">2501</span><span class="sd">    At runtime, this throws an exception when called.</span>
<span class="linenos">2502</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2503</span>    <span class="n">value</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="linenos">2504</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="p">:</span>
<span class="linenos">2505</span>        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:</span><span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
<span class="linenos">2506</span>    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected code to be unreachable, but got: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">2507</span>
<span class="linenos">2508</span>
<span class="linenos">2509</span><span class="k">def</span> <span class="nf">no_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="linenos">2510</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to indicate that annotations are not type hints.</span>
<span class="linenos">2511</span>
<span class="linenos">2512</span><span class="sd">    The argument must be a class or function; if it is a class, it</span>
<span class="linenos">2513</span><span class="sd">    applies recursively to all methods and classes defined in that class</span>
<span class="linenos">2514</span><span class="sd">    (but not to methods defined in its superclasses or subclasses).</span>
<span class="linenos">2515</span>
<span class="linenos">2516</span><span class="sd">    This mutates the function(s) or class(es) in place.</span>
<span class="linenos">2517</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2518</span>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos">2519</span>        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="linenos">2520</span>            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="linenos">2521</span>            <span class="k">if</span> <span class="p">(</span>
<span class="linenos">2522</span>                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">)</span>
<span class="linenos">2523</span>                <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">!=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">arg</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="linenos">2524</span>                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">.</span><span class="vm">__module__</span>
<span class="linenos">2525</span>            <span class="p">):</span>
<span class="linenos">2526</span>                <span class="c1"># We only modify objects that are defined in this type directly.</span>
<span class="linenos">2527</span>                <span class="c1"># If classes / methods are nested in multiple layers,</span>
<span class="linenos">2528</span>                <span class="c1"># we will modify them when processing their direct holders.</span>
<span class="linenos">2529</span>                <span class="k">continue</span>
<span class="linenos">2530</span>            <span class="c1"># Instance, class, and static methods:</span>
<span class="linenos">2531</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
<span class="linenos">2532</span>                <span class="n">obj</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos">2533</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
<span class="linenos">2534</span>                <span class="n">obj</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos">2535</span>            <span class="c1"># Nested types:</span>
<span class="linenos">2536</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="linenos">2537</span>                <span class="n">no_type_check</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="linenos">2538</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">2539</span>        <span class="n">arg</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos">2540</span>    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># built-in classes</span>
<span class="linenos">2541</span>        <span class="k">pass</span>
<span class="linenos">2542</span>    <span class="k">return</span> <span class="n">arg</span>
<span class="linenos">2543</span>
<span class="linenos">2544</span>
<span class="linenos">2545</span><span class="k">def</span> <span class="nf">no_type_check_decorator</span><span class="p">(</span><span class="n">decorator</span><span class="p">):</span>
<span class="linenos">2546</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to give another decorator the @no_type_check effect.</span>
<span class="linenos">2547</span>
<span class="linenos">2548</span><span class="sd">    This wraps the decorator with something that wraps the decorated</span>
<span class="linenos">2549</span><span class="sd">    function in @no_type_check.</span>
<span class="linenos">2550</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2551</span>    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">decorator</span><span class="p">)</span>
<span class="linenos">2552</span>    <span class="k">def</span> <span class="nf">wrapped_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="linenos">2553</span>        <span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
<span class="linenos">2554</span>        <span class="n">func</span> <span class="o">=</span> <span class="n">no_type_check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="linenos">2555</span>        <span class="k">return</span> <span class="n">func</span>
<span class="linenos">2556</span>
<span class="linenos">2557</span>    <span class="k">return</span> <span class="n">wrapped_decorator</span>
<span class="linenos">2558</span>
<span class="linenos">2559</span>
<span class="linenos">2560</span><span class="k">def</span> <span class="nf">_overload_dummy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="linenos">2561</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for @overload to raise when called.&quot;&quot;&quot;</span>
<span class="linenos">2562</span>    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="linenos">2563</span>        <span class="s2">&quot;You should not call an overloaded function. &quot;</span>
<span class="linenos">2564</span>        <span class="s2">&quot;A series of @overload-decorated functions &quot;</span>
<span class="linenos">2565</span>        <span class="s2">&quot;outside a stub module should always be followed &quot;</span>
<span class="linenos">2566</span>        <span class="s2">&quot;by an implementation that is not @overload-ed.&quot;</span><span class="p">)</span>
<span class="linenos">2567</span>
<span class="linenos">2568</span>
<span class="linenos">2569</span><span class="c1"># {module: {qualname: {firstlineno: func}}}</span>
<span class="linenos">2570</span><span class="n">_overload_registry</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span>
<span class="linenos">2571</span>
<span class="linenos">2572</span>
<span class="linenos">2573</span><span class="k">def</span> <span class="nf">overload</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="linenos">2574</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator for overloaded functions/methods.</span>
<span class="linenos">2575</span>
<span class="linenos">2576</span><span class="sd">    In a stub file, place two or more stub definitions for the same</span>
<span class="linenos">2577</span><span class="sd">    function in a row, each decorated with @overload.</span>
<span class="linenos">2578</span>
<span class="linenos">2579</span><span class="sd">    For example::</span>
<span class="linenos">2580</span>
<span class="linenos">2581</span><span class="sd">        @overload</span>
<span class="linenos">2582</span><span class="sd">        def utf8(value: None) -&gt; None: ...</span>
<span class="linenos">2583</span><span class="sd">        @overload</span>
<span class="linenos">2584</span><span class="sd">        def utf8(value: bytes) -&gt; bytes: ...</span>
<span class="linenos">2585</span><span class="sd">        @overload</span>
<span class="linenos">2586</span><span class="sd">        def utf8(value: str) -&gt; bytes: ...</span>
<span class="linenos">2587</span>
<span class="linenos">2588</span><span class="sd">    In a non-stub file (i.e. a regular .py file), do the same but</span>
<span class="linenos">2589</span><span class="sd">    follow it with an implementation.  The implementation should *not*</span>
<span class="linenos">2590</span><span class="sd">    be decorated with @overload::</span>
<span class="linenos">2591</span>
<span class="linenos">2592</span><span class="sd">        @overload</span>
<span class="linenos">2593</span><span class="sd">        def utf8(value: None) -&gt; None: ...</span>
<span class="linenos">2594</span><span class="sd">        @overload</span>
<span class="linenos">2595</span><span class="sd">        def utf8(value: bytes) -&gt; bytes: ...</span>
<span class="linenos">2596</span><span class="sd">        @overload</span>
<span class="linenos">2597</span><span class="sd">        def utf8(value: str) -&gt; bytes: ...</span>
<span class="linenos">2598</span><span class="sd">        def utf8(value):</span>
<span class="linenos">2599</span><span class="sd">            ...  # implementation goes here</span>
<span class="linenos">2600</span>
<span class="linenos">2601</span><span class="sd">    The overloads for a function can be retrieved at runtime using the</span>
<span class="linenos">2602</span><span class="sd">    get_overloads() function.</span>
<span class="linenos">2603</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2604</span>    <span class="c1"># classmethod and staticmethod</span>
<span class="linenos">2605</span>    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
<span class="linenos">2606</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">2607</span>        <span class="n">_overload_registry</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">][</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">][</span><span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
<span class="linenos">2608</span>    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
<span class="linenos">2609</span>        <span class="c1"># Not a normal function; ignore.</span>
<span class="linenos">2610</span>        <span class="k">pass</span>
<span class="linenos">2611</span>    <span class="k">return</span> <span class="n">_overload_dummy</span>
<span class="linenos">2612</span>
<span class="linenos">2613</span>
<span class="linenos">2614</span><span class="k">def</span> <span class="nf">get_overloads</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="linenos">2615</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all defined overloads for *func* as a sequence.&quot;&quot;&quot;</span>
<span class="linenos">2616</span>    <span class="c1"># classmethod and staticmethod</span>
<span class="linenos">2617</span>    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
<span class="linenos">2618</span>    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_overload_registry</span><span class="p">:</span>
<span class="linenos">2619</span>        <span class="k">return</span> <span class="p">[]</span>
<span class="linenos">2620</span>    <span class="n">mod_dict</span> <span class="o">=</span> <span class="n">_overload_registry</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span>
<span class="linenos">2621</span>    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mod_dict</span><span class="p">:</span>
<span class="linenos">2622</span>        <span class="k">return</span> <span class="p">[]</span>
<span class="linenos">2623</span>    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">mod_dict</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="linenos">2624</span>
<span class="linenos">2625</span>
<span class="linenos">2626</span><span class="k">def</span> <span class="nf">clear_overloads</span><span class="p">():</span>
<span class="linenos">2627</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Clear all overloads in the registry.&quot;&quot;&quot;</span>
<span class="linenos">2628</span>    <span class="n">_overload_registry</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="linenos">2629</span>
<span class="linenos">2630</span>
<span class="linenos">2631</span><span class="k">def</span> <span class="nf">final</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="linenos">2632</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to indicate final methods and final classes.</span>
<span class="linenos">2633</span>
<span class="linenos">2634</span><span class="sd">    Use this decorator to indicate to type checkers that the decorated</span>
<span class="linenos">2635</span><span class="sd">    method cannot be overridden, and decorated class cannot be subclassed.</span>
<span class="linenos">2636</span>
<span class="linenos">2637</span><span class="sd">    For example::</span>
<span class="linenos">2638</span>
<span class="linenos">2639</span><span class="sd">        class Base:</span>
<span class="linenos">2640</span><span class="sd">            @final</span>
<span class="linenos">2641</span><span class="sd">            def done(self) -&gt; None:</span>
<span class="linenos">2642</span><span class="sd">                ...</span>
<span class="linenos">2643</span><span class="sd">        class Sub(Base):</span>
<span class="linenos">2644</span><span class="sd">            def done(self) -&gt; None:  # Error reported by type checker</span>
<span class="linenos">2645</span><span class="sd">                ...</span>
<span class="linenos">2646</span>
<span class="linenos">2647</span><span class="sd">        @final</span>
<span class="linenos">2648</span><span class="sd">        class Leaf:</span>
<span class="linenos">2649</span><span class="sd">            ...</span>
<span class="linenos">2650</span><span class="sd">        class Other(Leaf):  # Error reported by type checker</span>
<span class="linenos">2651</span><span class="sd">            ...</span>
<span class="linenos">2652</span>
<span class="linenos">2653</span><span class="sd">    There is no runtime checking of these properties. The decorator</span>
<span class="linenos">2654</span><span class="sd">    attempts to set the ``__final__`` attribute to ``True`` on the decorated</span>
<span class="linenos">2655</span><span class="sd">    object to allow runtime introspection.</span>
<span class="linenos">2656</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2657</span>    <span class="k">try</span><span class="p">:</span>
<span class="linenos">2658</span>        <span class="n">f</span><span class="o">.</span><span class="n">__final__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="linenos">2659</span>    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
<span class="linenos">2660</span>        <span class="c1"># Skip the attribute silently if it is not writable.</span>
<span class="linenos">2661</span>        <span class="c1"># AttributeError happens if the object has __slots__ or a</span>
<span class="linenos">2662</span>        <span class="c1"># read-only property, TypeError if it&#39;s a builtin class.</span>
<span class="linenos">2663</span>        <span class="k">pass</span>
<span class="linenos">2664</span>    <span class="k">return</span> <span class="n">f</span>
<span class="linenos">2665</span>
<span class="linenos">2666</span>
<span class="linenos">2667</span><span class="c1"># Some unconstrained type variables.  These are used by the container types.</span>
<span class="linenos">2668</span><span class="c1"># (These are not for export.)</span>
<span class="linenos">2669</span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Any type.</span>
<span class="linenos">2670</span><span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>  <span class="c1"># Key type.</span>
<span class="linenos">2671</span><span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>  <span class="c1"># Value type.</span>
<span class="linenos">2672</span><span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>
<span class="linenos">2673</span><span class="n">V_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>
<span class="linenos">2674</span><span class="n">VT_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Value type covariant containers.</span>
<span class="linenos">2675</span><span class="n">T_contra</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_contra&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Ditto contravariant.</span>
<span class="linenos">2676</span><span class="c1"># Internal type variable used for Type[].</span>
<span class="linenos">2677</span><span class="n">CT_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;CT_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>
<span class="linenos">2678</span>
<span class="linenos">2679</span><span class="c1"># A useful type variable with constraints.  This represents string types.</span>
<span class="linenos">2680</span><span class="c1"># (This one *is* for export!)</span>
<span class="linenos">2681</span><span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="linenos">2682</span>
<span class="linenos">2683</span>
<span class="linenos">2684</span><span class="c1"># Various ABCs mimicking those in collections.abc.</span>
<span class="linenos">2685</span><span class="n">_alias</span> <span class="o">=</span> <span class="n">_SpecialGenericAlias</span>
<span class="linenos">2686</span>
<span class="linenos">2687</span><span class="n">Hashable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
<span class="linenos">2688</span><span class="n">Awaitable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Awaitable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2689</span><span class="n">Coroutine</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Coroutine</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="linenos">2690</span><span class="n">AsyncIterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2691</span><span class="n">AsyncIterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterator</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2692</span><span class="n">Iterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2693</span><span class="n">Iterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2694</span><span class="n">Reversible</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Reversible</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2695</span><span class="n">Sized</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
<span class="linenos">2696</span><span class="n">Container</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2697</span><span class="n">Collection</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Collection</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2698</span><span class="n">Callable</span> <span class="o">=</span> <span class="n">_CallableType</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2699</span><span class="n">Callable</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
<span class="linenos">2700</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to collections.abc.Callable.</span>
<span class="linenos">2701</span>
<span class="linenos">2702</span><span class="sd">    Callable[[int], str] signifies a function that takes a single</span>
<span class="linenos">2703</span><span class="sd">    parameter of type int and returns a str.</span>
<span class="linenos">2704</span>
<span class="linenos">2705</span><span class="sd">    The subscription syntax must always be used with exactly two</span>
<span class="linenos">2706</span><span class="sd">    values: the argument list and the return type.</span>
<span class="linenos">2707</span><span class="sd">    The argument list must be a list of types, a ParamSpec,</span>
<span class="linenos">2708</span><span class="sd">    Concatenate or ellipsis. The return type must be a single type.</span>
<span class="linenos">2709</span>
<span class="linenos">2710</span><span class="sd">    There is no syntax to indicate optional or keyword arguments;</span>
<span class="linenos">2711</span><span class="sd">    such function types are rarely used as callback types.</span>
<span class="linenos">2712</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2713</span><span class="n">AbstractSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AbstractSet&#39;</span><span class="p">)</span>
<span class="linenos">2714</span><span class="n">MutableSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSet</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2715</span><span class="c1"># NOTE: Mapping is only covariant in the value type.</span>
<span class="linenos">2716</span><span class="n">Mapping</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2717</span><span class="n">MutableMapping</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2718</span><span class="n">Sequence</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2719</span><span class="n">MutableSequence</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2720</span><span class="n">ByteString</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ByteString</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic</span>
<span class="linenos">2721</span><span class="c1"># Tuple accepts variable number of parameters.</span>
<span class="linenos">2722</span><span class="n">Tuple</span> <span class="o">=</span> <span class="n">_TupleType</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Tuple&#39;</span><span class="p">)</span>
<span class="linenos">2723</span><span class="n">Tuple</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
<span class="linenos">2724</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to builtins.tuple.</span>
<span class="linenos">2725</span>
<span class="linenos">2726</span><span class="sd">    Tuple[X, Y] is the cross-product type of X and Y.</span>
<span class="linenos">2727</span>
<span class="linenos">2728</span><span class="sd">    Example: Tuple[T1, T2] is a tuple of two elements corresponding</span>
<span class="linenos">2729</span><span class="sd">    to type variables T1 and T2.  Tuple[int, float, str] is a tuple</span>
<span class="linenos">2730</span><span class="sd">    of an int, a float and a string.</span>
<span class="linenos">2731</span>
<span class="linenos">2732</span><span class="sd">    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].</span>
<span class="linenos">2733</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2734</span><span class="n">List</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;List&#39;</span><span class="p">)</span>
<span class="linenos">2735</span><span class="n">Deque</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Deque&#39;</span><span class="p">)</span>
<span class="linenos">2736</span><span class="n">Set</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Set&#39;</span><span class="p">)</span>
<span class="linenos">2737</span><span class="n">FrozenSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FrozenSet&#39;</span><span class="p">)</span>
<span class="linenos">2738</span><span class="n">MappingView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MappingView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2739</span><span class="n">KeysView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">KeysView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2740</span><span class="n">ItemsView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ItemsView</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2741</span><span class="n">ValuesView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ValuesView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2742</span><span class="n">ContextManager</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractContextManager</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ContextManager&#39;</span><span class="p">)</span>
<span class="linenos">2743</span><span class="n">AsyncContextManager</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractAsyncContextManager</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AsyncContextManager&#39;</span><span class="p">)</span>
<span class="linenos">2744</span><span class="n">Dict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Dict&#39;</span><span class="p">)</span>
<span class="linenos">2745</span><span class="n">DefaultDict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;DefaultDict&#39;</span><span class="p">)</span>
<span class="linenos">2746</span><span class="n">OrderedDict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2747</span><span class="n">Counter</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">2748</span><span class="n">ChainMap</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2749</span><span class="n">Generator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Generator</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="linenos">2750</span><span class="n">AsyncGenerator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncGenerator</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="linenos">2751</span><span class="n">Type</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Type&#39;</span><span class="p">)</span>
<span class="linenos">2752</span><span class="n">Type</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
<span class="linenos">2753</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to builtins.type.</span>
<span class="linenos">2754</span>
<span class="linenos">2755</span><span class="sd">    builtins.type or typing.Type can be used to annotate class objects.</span>
<span class="linenos">2756</span><span class="sd">    For example, suppose we have the following classes::</span>
<span class="linenos">2757</span>
<span class="linenos">2758</span><span class="sd">        class User: ...  # Abstract base for User classes</span>
<span class="linenos">2759</span><span class="sd">        class BasicUser(User): ...</span>
<span class="linenos">2760</span><span class="sd">        class ProUser(User): ...</span>
<span class="linenos">2761</span><span class="sd">        class TeamUser(User): ...</span>
<span class="linenos">2762</span>
<span class="linenos">2763</span><span class="sd">    And a function that takes a class argument that&#39;s a subclass of</span>
<span class="linenos">2764</span><span class="sd">    User and returns an instance of the corresponding class::</span>
<span class="linenos">2765</span>
<span class="linenos">2766</span><span class="sd">        U = TypeVar(&#39;U&#39;, bound=User)</span>
<span class="linenos">2767</span><span class="sd">        def new_user(user_class: Type[U]) -&gt; U:</span>
<span class="linenos">2768</span><span class="sd">            user = user_class()</span>
<span class="linenos">2769</span><span class="sd">            # (Here we could write the user object to a database)</span>
<span class="linenos">2770</span><span class="sd">            return user</span>
<span class="linenos">2771</span>
<span class="linenos">2772</span><span class="sd">        joe = new_user(BasicUser)</span>
<span class="linenos">2773</span>
<span class="linenos">2774</span><span class="sd">    At this point the type checker knows that joe has type BasicUser.</span>
<span class="linenos">2775</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2776</span>
<span class="linenos">2777</span>
<span class="linenos">2778</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2779</span><span class="k">class</span> <span class="nc">SupportsInt</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">2780</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __int__.&quot;&quot;&quot;</span>
<span class="linenos">2781</span>
<span class="linenos">2782</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2783</span>
<span class="linenos">2784</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2785</span>    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">2786</span>        <span class="k">pass</span>
<span class="linenos">2787</span>
<span class="linenos">2788</span>
<span class="linenos">2789</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2790</span><span class="k">class</span> <span class="nc">SupportsFloat</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">2791</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __float__.&quot;&quot;&quot;</span>
<span class="linenos">2792</span>
<span class="linenos">2793</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2794</span>
<span class="linenos">2795</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2796</span>    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="linenos">2797</span>        <span class="k">pass</span>
<span class="linenos">2798</span>
<span class="linenos">2799</span>
<span class="linenos">2800</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2801</span><span class="k">class</span> <span class="nc">SupportsComplex</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">2802</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __complex__.&quot;&quot;&quot;</span>
<span class="linenos">2803</span>
<span class="linenos">2804</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2805</span>
<span class="linenos">2806</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2807</span>    <span class="k">def</span> <span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">complex</span><span class="p">:</span>
<span class="linenos">2808</span>        <span class="k">pass</span>
<span class="linenos">2809</span>
<span class="linenos">2810</span>
<span class="linenos">2811</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2812</span><span class="k">class</span> <span class="nc">SupportsBytes</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">2813</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __bytes__.&quot;&quot;&quot;</span>
<span class="linenos">2814</span>
<span class="linenos">2815</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2816</span>
<span class="linenos">2817</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2818</span>    <span class="k">def</span> <span class="fm">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="linenos">2819</span>        <span class="k">pass</span>
<span class="linenos">2820</span>
<span class="linenos">2821</span>
<span class="linenos">2822</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2823</span><span class="k">class</span> <span class="nc">SupportsIndex</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="linenos">2824</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __index__.&quot;&quot;&quot;</span>
<span class="linenos">2825</span>
<span class="linenos">2826</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2827</span>
<span class="linenos">2828</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2829</span>    <span class="k">def</span> <span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">2830</span>        <span class="k">pass</span>
<span class="linenos">2831</span>
<span class="linenos">2832</span>
<span class="linenos">2833</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2834</span><span class="k">class</span> <span class="nc">SupportsAbs</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="linenos">2835</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __abs__ that is covariant in its return type.&quot;&quot;&quot;</span>
<span class="linenos">2836</span>
<span class="linenos">2837</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2838</span>
<span class="linenos">2839</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2840</span>    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span>
<span class="linenos">2841</span>        <span class="k">pass</span>
<span class="linenos">2842</span>
<span class="linenos">2843</span>
<span class="linenos">2844</span><span class="nd">@runtime_checkable</span>
<span class="linenos">2845</span><span class="k">class</span> <span class="nc">SupportsRound</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="linenos">2846</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __round__ that is covariant in its return type.&quot;&quot;&quot;</span>
<span class="linenos">2847</span>
<span class="linenos">2848</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2849</span>
<span class="linenos">2850</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">2851</span>    <span class="k">def</span> <span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndigits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span>
<span class="linenos">2852</span>        <span class="k">pass</span>
<span class="linenos">2853</span>
<span class="linenos">2854</span>
<span class="linenos">2855</span><span class="k">def</span> <span class="nf">_make_nmtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">defaults</span> <span class="o">=</span> <span class="p">()):</span>
<span class="linenos">2856</span>    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
<span class="linenos">2857</span>    <span class="n">types</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;field </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> annotation must be a type&quot;</span><span class="p">)</span>
<span class="linenos">2858</span>             <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">}</span>
<span class="linenos">2859</span>    <span class="n">nm_tpl</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span>
<span class="linenos">2860</span>                                    <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>
<span class="linenos">2861</span>    <span class="n">nm_tpl</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">nm_tpl</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">types</span>
<span class="linenos">2862</span>    <span class="k">return</span> <span class="n">nm_tpl</span>
<span class="linenos">2863</span>
<span class="linenos">2864</span>
<span class="linenos">2865</span><span class="c1"># attributes prohibited to set in NamedTuple class syntax</span>
<span class="linenos">2866</span><span class="n">_prohibited</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span> <span class="s1">&#39;__getnewargs__&#39;</span><span class="p">,</span>
<span class="linenos">2867</span>                         <span class="s1">&#39;_fields&#39;</span><span class="p">,</span> <span class="s1">&#39;_field_defaults&#39;</span><span class="p">,</span>
<span class="linenos">2868</span>                         <span class="s1">&#39;_make&#39;</span><span class="p">,</span> <span class="s1">&#39;_replace&#39;</span><span class="p">,</span> <span class="s1">&#39;_asdict&#39;</span><span class="p">,</span> <span class="s1">&#39;_source&#39;</span><span class="p">})</span>
<span class="linenos">2869</span>
<span class="linenos">2870</span><span class="n">_special</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">})</span>
<span class="linenos">2871</span>
<span class="linenos">2872</span>
<span class="linenos">2873</span><span class="k">class</span> <span class="nc">NamedTupleMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="linenos">2874</span>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
<span class="linenos">2875</span>        <span class="k">assert</span> <span class="n">_NamedTuple</span> <span class="ow">in</span> <span class="n">bases</span>
<span class="linenos">2876</span>        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">2877</span>            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NamedTuple</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Generic</span><span class="p">:</span>
<span class="linenos">2878</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">2879</span>                    <span class="s1">&#39;can only inherit from a NamedTuple type and Generic&#39;</span><span class="p">)</span>
<span class="linenos">2880</span>        <span class="n">bases</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span> <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="n">_NamedTuple</span> <span class="k">else</span> <span class="n">base</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">)</span>
<span class="linenos">2881</span>        <span class="n">types</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">2882</span>        <span class="n">default_names</span> <span class="o">=</span> <span class="p">[]</span>
<span class="linenos">2883</span>        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
<span class="linenos">2884</span>            <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
<span class="linenos">2885</span>                <span class="n">default_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
<span class="linenos">2886</span>            <span class="k">elif</span> <span class="n">default_names</span><span class="p">:</span>
<span class="linenos">2887</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-default namedtuple field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2"> &quot;</span>
<span class="linenos">2888</span>                                <span class="sa">f</span><span class="s2">&quot;cannot follow default field&quot;</span>
<span class="linenos">2889</span>                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;s&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> &quot;</span>
<span class="linenos">2890</span>                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">2891</span>        <span class="n">nm_tpl</span> <span class="o">=</span> <span class="n">_make_nmtuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
<span class="linenos">2892</span>                               <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">default_names</span><span class="p">],</span>
<span class="linenos">2893</span>                               <span class="n">module</span><span class="o">=</span><span class="n">ns</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">])</span>
<span class="linenos">2894</span>        <span class="n">nm_tpl</span><span class="o">.</span><span class="vm">__bases__</span> <span class="o">=</span> <span class="n">bases</span>
<span class="linenos">2895</span>        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">2896</span>            <span class="n">class_getitem</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="o">.</span><span class="vm">__func__</span>
<span class="linenos">2897</span>            <span class="n">nm_tpl</span><span class="o">.</span><span class="n">__class_getitem__</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">class_getitem</span><span class="p">)</span>
<span class="linenos">2898</span>        <span class="c1"># update from user namespace without overriding special namedtuple attributes</span>
<span class="linenos">2899</span>        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
<span class="linenos">2900</span>            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_prohibited</span><span class="p">:</span>
<span class="linenos">2901</span>                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot overwrite NamedTuple attribute &quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
<span class="linenos">2902</span>            <span class="k">elif</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_special</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nm_tpl</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
<span class="linenos">2903</span>                <span class="nb">setattr</span><span class="p">(</span><span class="n">nm_tpl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ns</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
<span class="linenos">2904</span>        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">2905</span>            <span class="n">nm_tpl</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>
<span class="linenos">2906</span>        <span class="k">return</span> <span class="n">nm_tpl</span>
<span class="linenos">2907</span>
<span class="linenos">2908</span>
<span class="linenos">2909</span><span class="k">def</span> <span class="nf">NamedTuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">2910</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of namedtuple.</span>
<span class="linenos">2911</span>
<span class="linenos">2912</span><span class="sd">    Usage::</span>
<span class="linenos">2913</span>
<span class="linenos">2914</span><span class="sd">        class Employee(NamedTuple):</span>
<span class="linenos">2915</span><span class="sd">            name: str</span>
<span class="linenos">2916</span><span class="sd">            id: int</span>
<span class="linenos">2917</span>
<span class="linenos">2918</span><span class="sd">    This is equivalent to::</span>
<span class="linenos">2919</span>
<span class="linenos">2920</span><span class="sd">        Employee = collections.namedtuple(&#39;Employee&#39;, [&#39;name&#39;, &#39;id&#39;])</span>
<span class="linenos">2921</span>
<span class="linenos">2922</span><span class="sd">    The resulting class has an extra __annotations__ attribute, giving a</span>
<span class="linenos">2923</span><span class="sd">    dict that maps field names to types.  (The field names are also in</span>
<span class="linenos">2924</span><span class="sd">    the _fields attribute, which is part of the namedtuple API.)</span>
<span class="linenos">2925</span><span class="sd">    An alternative equivalent functional syntax is also accepted::</span>
<span class="linenos">2926</span>
<span class="linenos">2927</span><span class="sd">        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])</span>
<span class="linenos">2928</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">2929</span>    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">2930</span>        <span class="n">fields</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="linenos">2931</span>    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
<span class="linenos">2932</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Either list of fields or keywords&quot;</span>
<span class="linenos">2933</span>                        <span class="s2">&quot; can be provided to NamedTuple, not both&quot;</span><span class="p">)</span>
<span class="linenos">2934</span>    <span class="k">return</span> <span class="n">_make_nmtuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">_caller</span><span class="p">())</span>
<span class="linenos">2935</span>
<span class="linenos">2936</span><span class="n">_NamedTuple</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">NamedTupleMeta</span><span class="p">,</span> <span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
<span class="linenos">2937</span>
<span class="linenos">2938</span><span class="k">def</span> <span class="nf">_namedtuple_mro_entries</span><span class="p">(</span><span class="n">bases</span><span class="p">):</span>
<span class="linenos">2939</span>    <span class="k">assert</span> <span class="n">NamedTuple</span> <span class="ow">in</span> <span class="n">bases</span>
<span class="linenos">2940</span>    <span class="k">return</span> <span class="p">(</span><span class="n">_NamedTuple</span><span class="p">,)</span>
<span class="linenos">2941</span>
<span class="linenos">2942</span><span class="n">NamedTuple</span><span class="o">.</span><span class="n">__mro_entries__</span> <span class="o">=</span> <span class="n">_namedtuple_mro_entries</span>
<span class="linenos">2943</span>
<span class="linenos">2944</span>
<span class="linenos">2945</span><span class="k">class</span> <span class="nc">_TypedDictMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="linenos">2946</span>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="linenos">2947</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new typed dict class object.</span>
<span class="linenos">2948</span>
<span class="linenos">2949</span><span class="sd">        This method is called when TypedDict is subclassed,</span>
<span class="linenos">2950</span><span class="sd">        or when TypedDict is instantiated. This way</span>
<span class="linenos">2951</span><span class="sd">        TypedDict supports all three syntax forms described in its docstring.</span>
<span class="linenos">2952</span><span class="sd">        Subclasses and instances of TypedDict return actual dictionaries.</span>
<span class="linenos">2953</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">2954</span>        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">2955</span>            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_TypedDictMeta</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Generic</span><span class="p">:</span>
<span class="linenos">2956</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot inherit from both a TypedDict type &#39;</span>
<span class="linenos">2957</span>                                <span class="s1">&#39;and a non-TypedDict base class&#39;</span><span class="p">)</span>
<span class="linenos">2958</span>
<span class="linenos">2959</span>        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">):</span>
<span class="linenos">2960</span>            <span class="n">generic_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,)</span>
<span class="linenos">2961</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">2962</span>            <span class="n">generic_base</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">2963</span>
<span class="linenos">2964</span>        <span class="n">tp_dict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">_TypedDictMeta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">generic_base</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="n">ns</span><span class="p">)</span>
<span class="linenos">2965</span>
<span class="linenos">2966</span>        <span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
<span class="linenos">2967</span>        <span class="n">own_annotations</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
<span class="linenos">2968</span>        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;TypedDict(&#39;Name&#39;, {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
<span class="linenos">2969</span>        <span class="n">own_annotations</span> <span class="o">=</span> <span class="p">{</span>
<span class="linenos">2970</span>            <span class="n">n</span><span class="p">:</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">tp_dict</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
<span class="linenos">2971</span>            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">own_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="linenos">2972</span>        <span class="p">}</span>
<span class="linenos">2973</span>        <span class="n">required_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="linenos">2974</span>        <span class="n">optional_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="linenos">2975</span>
<span class="linenos">2976</span>        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
<span class="linenos">2977</span>            <span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
<span class="linenos">2978</span>            <span class="n">required_keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__required_keys__&#39;</span><span class="p">,</span> <span class="p">()))</span>
<span class="linenos">2979</span>            <span class="n">optional_keys</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__optional_keys__&#39;</span><span class="p">,</span> <span class="p">()))</span>
<span class="linenos">2980</span>
<span class="linenos">2981</span>        <span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">own_annotations</span><span class="p">)</span>
<span class="linenos">2982</span>        <span class="k">for</span> <span class="n">annotation_key</span><span class="p">,</span> <span class="n">annotation_type</span> <span class="ow">in</span> <span class="n">own_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="linenos">2983</span>            <span class="n">annotation_origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
<span class="linenos">2984</span>            <span class="k">if</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">Annotated</span><span class="p">:</span>
<span class="linenos">2985</span>                <span class="n">annotation_args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
<span class="linenos">2986</span>                <span class="k">if</span> <span class="n">annotation_args</span><span class="p">:</span>
<span class="linenos">2987</span>                    <span class="n">annotation_type</span> <span class="o">=</span> <span class="n">annotation_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="linenos">2988</span>                    <span class="n">annotation_origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
<span class="linenos">2989</span>
<span class="linenos">2990</span>            <span class="k">if</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">Required</span><span class="p">:</span>
<span class="linenos">2991</span>                <span class="n">required_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
<span class="linenos">2992</span>            <span class="k">elif</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">NotRequired</span><span class="p">:</span>
<span class="linenos">2993</span>                <span class="n">optional_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
<span class="linenos">2994</span>            <span class="k">elif</span> <span class="n">total</span><span class="p">:</span>
<span class="linenos">2995</span>                <span class="n">required_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
<span class="linenos">2996</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">2997</span>                <span class="n">optional_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
<span class="linenos">2998</span>
<span class="linenos">2999</span>        <span class="n">tp_dict</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">annotations</span>
<span class="linenos">3000</span>        <span class="n">tp_dict</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">required_keys</span><span class="p">)</span>
<span class="linenos">3001</span>        <span class="n">tp_dict</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">optional_keys</span><span class="p">)</span>
<span class="linenos">3002</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp_dict</span><span class="p">,</span> <span class="s1">&#39;__total__&#39;</span><span class="p">):</span>
<span class="linenos">3003</span>            <span class="n">tp_dict</span><span class="o">.</span><span class="n">__total__</span> <span class="o">=</span> <span class="n">total</span>
<span class="linenos">3004</span>        <span class="k">return</span> <span class="n">tp_dict</span>
<span class="linenos">3005</span>
<span class="linenos">3006</span>    <span class="fm">__call__</span> <span class="o">=</span> <span class="nb">dict</span>  <span class="c1"># static method</span>
<span class="linenos">3007</span>
<span class="linenos">3008</span>    <span class="k">def</span> <span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">3009</span>        <span class="c1"># Typed dicts are only for static structural subtyping.</span>
<span class="linenos">3010</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypedDict does not support instance and class checks&#39;</span><span class="p">)</span>
<span class="linenos">3011</span>
<span class="linenos">3012</span>    <span class="fm">__instancecheck__</span> <span class="o">=</span> <span class="fm">__subclasscheck__</span>
<span class="linenos">3013</span>
<span class="linenos">3014</span>
<span class="linenos">3015</span><span class="k">def</span> <span class="nf">TypedDict</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="linenos">3016</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple typed namespace. At runtime it is equivalent to a plain dict.</span>
<span class="linenos">3017</span>
<span class="linenos">3018</span><span class="sd">    TypedDict creates a dictionary type such that a type checker will expect all</span>
<span class="linenos">3019</span><span class="sd">    instances to have a certain set of keys, where each key is</span>
<span class="linenos">3020</span><span class="sd">    associated with a value of a consistent type. This expectation</span>
<span class="linenos">3021</span><span class="sd">    is not checked at runtime.</span>
<span class="linenos">3022</span>
<span class="linenos">3023</span><span class="sd">    Usage::</span>
<span class="linenos">3024</span>
<span class="linenos">3025</span><span class="sd">        class Point2D(TypedDict):</span>
<span class="linenos">3026</span><span class="sd">            x: int</span>
<span class="linenos">3027</span><span class="sd">            y: int</span>
<span class="linenos">3028</span><span class="sd">            label: str</span>
<span class="linenos">3029</span>
<span class="linenos">3030</span><span class="sd">        a: Point2D = {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;label&#39;: &#39;good&#39;}  # OK</span>
<span class="linenos">3031</span><span class="sd">        b: Point2D = {&#39;z&#39;: 3, &#39;label&#39;: &#39;bad&#39;}           # Fails type check</span>
<span class="linenos">3032</span>
<span class="linenos">3033</span><span class="sd">        assert Point2D(x=1, y=2, label=&#39;first&#39;) == dict(x=1, y=2, label=&#39;first&#39;)</span>
<span class="linenos">3034</span>
<span class="linenos">3035</span><span class="sd">    The type info can be accessed via the Point2D.__annotations__ dict, and</span>
<span class="linenos">3036</span><span class="sd">    the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.</span>
<span class="linenos">3037</span><span class="sd">    TypedDict supports an additional equivalent form::</span>
<span class="linenos">3038</span>
<span class="linenos">3039</span><span class="sd">        Point2D = TypedDict(&#39;Point2D&#39;, {&#39;x&#39;: int, &#39;y&#39;: int, &#39;label&#39;: str})</span>
<span class="linenos">3040</span>
<span class="linenos">3041</span><span class="sd">    By default, all keys must be present in a TypedDict. It is possible</span>
<span class="linenos">3042</span><span class="sd">    to override this by specifying totality::</span>
<span class="linenos">3043</span>
<span class="linenos">3044</span><span class="sd">        class Point2D(TypedDict, total=False):</span>
<span class="linenos">3045</span><span class="sd">            x: int</span>
<span class="linenos">3046</span><span class="sd">            y: int</span>
<span class="linenos">3047</span>
<span class="linenos">3048</span><span class="sd">    This means that a Point2D TypedDict can have any of the keys omitted. A type</span>
<span class="linenos">3049</span><span class="sd">    checker is only expected to support a literal False or True as the value of</span>
<span class="linenos">3050</span><span class="sd">    the total argument. True is the default, and makes all items defined in the</span>
<span class="linenos">3051</span><span class="sd">    class body be required.</span>
<span class="linenos">3052</span>
<span class="linenos">3053</span><span class="sd">    The Required and NotRequired special forms can also be used to mark</span>
<span class="linenos">3054</span><span class="sd">    individual keys as being required or not required::</span>
<span class="linenos">3055</span>
<span class="linenos">3056</span><span class="sd">        class Point2D(TypedDict):</span>
<span class="linenos">3057</span><span class="sd">            x: int               # the &quot;x&quot; key must always be present (Required is the default)</span>
<span class="linenos">3058</span><span class="sd">            y: NotRequired[int]  # the &quot;y&quot; key can be omitted</span>
<span class="linenos">3059</span>
<span class="linenos">3060</span><span class="sd">    See PEP 655 for more details on Required and NotRequired.</span>
<span class="linenos">3061</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3062</span>    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">3063</span>        <span class="n">fields</span> <span class="o">=</span> <span class="n">kwargs</span>
<span class="linenos">3064</span>    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
<span class="linenos">3065</span>        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
<span class="linenos">3066</span>                        <span class="s2">&quot; but not both&quot;</span><span class="p">)</span>
<span class="linenos">3067</span>    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
<span class="linenos">3068</span>        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
<span class="linenos">3069</span>            <span class="s2">&quot;The kwargs-based syntax for TypedDict definitions is deprecated &quot;</span>
<span class="linenos">3070</span>            <span class="s2">&quot;in Python 3.11, will be removed in Python 3.13, and may not be &quot;</span>
<span class="linenos">3071</span>            <span class="s2">&quot;understood by third-party type checkers.&quot;</span><span class="p">,</span>
<span class="linenos">3072</span>            <span class="ne">DeprecationWarning</span><span class="p">,</span>
<span class="linenos">3073</span>            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="linenos">3074</span>        <span class="p">)</span>
<span class="linenos">3075</span>
<span class="linenos">3076</span>    <span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fields</span><span class="p">)}</span>
<span class="linenos">3077</span>    <span class="n">module</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
<span class="linenos">3078</span>    <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">3079</span>        <span class="c1"># Setting correct module is necessary to make typed dict classes pickleable.</span>
<span class="linenos">3080</span>        <span class="n">ns</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="linenos">3081</span>
<span class="linenos">3082</span>    <span class="k">return</span> <span class="n">_TypedDictMeta</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="p">(),</span> <span class="n">ns</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">)</span>
<span class="linenos">3083</span>
<span class="linenos">3084</span><span class="n">_TypedDict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">_TypedDictMeta</span><span class="p">,</span> <span class="s1">&#39;TypedDict&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
<span class="linenos">3085</span><span class="n">TypedDict</span><span class="o">.</span><span class="n">__mro_entries__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bases</span><span class="p">:</span> <span class="p">(</span><span class="n">_TypedDict</span><span class="p">,)</span>
<span class="linenos">3086</span>
<span class="linenos">3087</span>
<span class="linenos">3088</span><span class="nd">@_SpecialForm</span>
<span class="linenos">3089</span><span class="k">def</span> <span class="nf">Required</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos">3090</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to mark a TypedDict key as required.</span>
<span class="linenos">3091</span>
<span class="linenos">3092</span><span class="sd">    This is mainly useful for total=False TypedDicts.</span>
<span class="linenos">3093</span>
<span class="linenos">3094</span><span class="sd">    For example::</span>
<span class="linenos">3095</span>
<span class="linenos">3096</span><span class="sd">        class Movie(TypedDict, total=False):</span>
<span class="linenos">3097</span><span class="sd">            title: Required[str]</span>
<span class="linenos">3098</span><span class="sd">            year: int</span>
<span class="linenos">3099</span>
<span class="linenos">3100</span><span class="sd">        m = Movie(</span>
<span class="linenos">3101</span><span class="sd">            title=&#39;The Matrix&#39;,  # typechecker error if key is omitted</span>
<span class="linenos">3102</span><span class="sd">            year=1999,</span>
<span class="linenos">3103</span><span class="sd">        )</span>
<span class="linenos">3104</span>
<span class="linenos">3105</span><span class="sd">    There is no runtime checking that a required key is actually provided</span>
<span class="linenos">3106</span><span class="sd">    when instantiating a related TypedDict.</span>
<span class="linenos">3107</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3108</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1"> accepts only a single type.&#39;</span><span class="p">)</span>
<span class="linenos">3109</span>    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
<span class="linenos">3110</span>
<span class="linenos">3111</span>
<span class="linenos">3112</span><span class="nd">@_SpecialForm</span>
<span class="linenos">3113</span><span class="k">def</span> <span class="nf">NotRequired</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="linenos">3114</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to mark a TypedDict key as potentially missing.</span>
<span class="linenos">3115</span>
<span class="linenos">3116</span><span class="sd">    For example::</span>
<span class="linenos">3117</span>
<span class="linenos">3118</span><span class="sd">        class Movie(TypedDict):</span>
<span class="linenos">3119</span><span class="sd">            title: str</span>
<span class="linenos">3120</span><span class="sd">            year: NotRequired[int]</span>
<span class="linenos">3121</span>
<span class="linenos">3122</span><span class="sd">        m = Movie(</span>
<span class="linenos">3123</span><span class="sd">            title=&#39;The Matrix&#39;,  # typechecker error if key is omitted</span>
<span class="linenos">3124</span><span class="sd">            year=1999,</span>
<span class="linenos">3125</span><span class="sd">        )</span>
<span class="linenos">3126</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3127</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1"> accepts only a single type.&#39;</span><span class="p">)</span>
<span class="linenos">3128</span>    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>
<span class="linenos">3129</span>
<span class="linenos">3130</span>
<span class="linenos">3131</span><span class="k">class</span> <span class="nc">NewType</span><span class="p">:</span>
<span class="linenos">3132</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;NewType creates simple unique types with almost zero runtime overhead.</span>
<span class="linenos">3133</span>
<span class="linenos">3134</span><span class="sd">    NewType(name, tp) is considered a subtype of tp</span>
<span class="linenos">3135</span><span class="sd">    by static type checkers. At runtime, NewType(name, tp) returns</span>
<span class="linenos">3136</span><span class="sd">    a dummy callable that simply returns its argument.</span>
<span class="linenos">3137</span>
<span class="linenos">3138</span><span class="sd">    Usage::</span>
<span class="linenos">3139</span>
<span class="linenos">3140</span><span class="sd">        UserId = NewType(&#39;UserId&#39;, int)</span>
<span class="linenos">3141</span>
<span class="linenos">3142</span><span class="sd">        def name_by_id(user_id: UserId) -&gt; str:</span>
<span class="linenos">3143</span><span class="sd">            ...</span>
<span class="linenos">3144</span>
<span class="linenos">3145</span><span class="sd">        UserId(&#39;user&#39;)          # Fails type check</span>
<span class="linenos">3146</span>
<span class="linenos">3147</span><span class="sd">        name_by_id(42)          # Fails type check</span>
<span class="linenos">3148</span><span class="sd">        name_by_id(UserId(42))  # OK</span>
<span class="linenos">3149</span>
<span class="linenos">3150</span><span class="sd">        num = UserId(5) + 1     # type: int</span>
<span class="linenos">3151</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3152</span>
<span class="linenos">3153</span>    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">_idfunc</span>
<span class="linenos">3154</span>
<span class="linenos">3155</span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tp</span><span class="p">):</span>
<span class="linenos">3156</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">name</span>
<span class="linenos">3157</span>        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
<span class="linenos">3158</span>            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="linenos">3159</span>        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
<span class="linenos">3160</span>        <span class="bp">self</span><span class="o">.</span><span class="n">__supertype__</span> <span class="o">=</span> <span class="n">tp</span>
<span class="linenos">3161</span>        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
<span class="linenos">3162</span>        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
<span class="linenos">3163</span>            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>
<span class="linenos">3164</span>
<span class="linenos">3165</span>    <span class="k">def</span> <span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
<span class="linenos">3166</span>        <span class="c1"># We defined __mro_entries__ to get a better error message</span>
<span class="linenos">3167</span>        <span class="c1"># if a user attempts to subclass a NewType instance. bpo-46170</span>
<span class="linenos">3168</span>        <span class="n">superclass_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos">3169</span>
<span class="linenos">3170</span>        <span class="k">class</span> <span class="nc">Dummy</span><span class="p">:</span>
<span class="linenos">3171</span>            <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="linenos">3172</span>                <span class="n">subclass_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
<span class="linenos">3173</span>                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
<span class="linenos">3174</span>                    <span class="sa">f</span><span class="s2">&quot;Cannot subclass an instance of NewType. Perhaps you were looking for: &quot;</span>
<span class="linenos">3175</span>                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">subclass_name</span><span class="si">}</span><span class="s2"> = NewType(</span><span class="si">{</span><span class="n">subclass_name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="n">superclass_name</span><span class="si">}</span><span class="s2">)`&quot;</span>
<span class="linenos">3176</span>                <span class="p">)</span>
<span class="linenos">3177</span>
<span class="linenos">3178</span>        <span class="k">return</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,)</span>
<span class="linenos">3179</span>
<span class="linenos">3180</span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">3181</span>        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="linenos">3182</span>
<span class="linenos">3183</span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">3184</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="linenos">3185</span>
<span class="linenos">3186</span>    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">3187</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
<span class="linenos">3188</span>
<span class="linenos">3189</span>    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="linenos">3190</span>        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>
<span class="linenos">3191</span>
<span class="linenos">3192</span>
<span class="linenos">3193</span><span class="c1"># Python-version-specific alias (Python 2: unicode; Python 3: str)</span>
<span class="linenos">3194</span><span class="n">Text</span> <span class="o">=</span> <span class="nb">str</span>
<span class="linenos">3195</span>
<span class="linenos">3196</span>
<span class="linenos">3197</span><span class="c1"># Constant that&#39;s True when type checking, but False here.</span>
<span class="linenos">3198</span><span class="n">TYPE_CHECKING</span> <span class="o">=</span> <span class="kc">False</span>
<span class="linenos">3199</span>
<span class="linenos">3200</span>
<span class="linenos">3201</span><span class="k">class</span> <span class="nc">IO</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">]):</span>
<span class="linenos">3202</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic base class for TextIO and BinaryIO.</span>
<span class="linenos">3203</span>
<span class="linenos">3204</span><span class="sd">    This is an abstract, generic version of the return of open().</span>
<span class="linenos">3205</span>
<span class="linenos">3206</span><span class="sd">    NOTE: This does not distinguish between the different possible</span>
<span class="linenos">3207</span><span class="sd">    classes (text vs. binary, read vs. write vs. read/write,</span>
<span class="linenos">3208</span><span class="sd">    append-only, unbuffered).  The TextIO and BinaryIO subclasses</span>
<span class="linenos">3209</span><span class="sd">    below capture the distinctions between text vs. binary, which is</span>
<span class="linenos">3210</span><span class="sd">    pervasive in the interface; however we currently do not offer a</span>
<span class="linenos">3211</span><span class="sd">    way to track the other distinctions in the type system.</span>
<span class="linenos">3212</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3213</span>
<span class="linenos">3214</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">3215</span>
<span class="linenos">3216</span>    <span class="nd">@property</span>
<span class="linenos">3217</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3218</span>    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="linenos">3219</span>        <span class="k">pass</span>
<span class="linenos">3220</span>
<span class="linenos">3221</span>    <span class="nd">@property</span>
<span class="linenos">3222</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3223</span>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="linenos">3224</span>        <span class="k">pass</span>
<span class="linenos">3225</span>
<span class="linenos">3226</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3227</span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">3228</span>        <span class="k">pass</span>
<span class="linenos">3229</span>
<span class="linenos">3230</span>    <span class="nd">@property</span>
<span class="linenos">3231</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3232</span>    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">3233</span>        <span class="k">pass</span>
<span class="linenos">3234</span>
<span class="linenos">3235</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3236</span>    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">3237</span>        <span class="k">pass</span>
<span class="linenos">3238</span>
<span class="linenos">3239</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3240</span>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">3241</span>        <span class="k">pass</span>
<span class="linenos">3242</span>
<span class="linenos">3243</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3244</span>    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">3245</span>        <span class="k">pass</span>
<span class="linenos">3246</span>
<span class="linenos">3247</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3248</span>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
<span class="linenos">3249</span>        <span class="k">pass</span>
<span class="linenos">3250</span>
<span class="linenos">3251</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3252</span>    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">3253</span>        <span class="k">pass</span>
<span class="linenos">3254</span>
<span class="linenos">3255</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3256</span>    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
<span class="linenos">3257</span>        <span class="k">pass</span>
<span class="linenos">3258</span>
<span class="linenos">3259</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3260</span>    <span class="k">def</span> <span class="nf">readlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">]:</span>
<span class="linenos">3261</span>        <span class="k">pass</span>
<span class="linenos">3262</span>
<span class="linenos">3263</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3264</span>    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">whence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">3265</span>        <span class="k">pass</span>
<span class="linenos">3266</span>
<span class="linenos">3267</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3268</span>    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">3269</span>        <span class="k">pass</span>
<span class="linenos">3270</span>
<span class="linenos">3271</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3272</span>    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">3273</span>        <span class="k">pass</span>
<span class="linenos">3274</span>
<span class="linenos">3275</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3276</span>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">3277</span>        <span class="k">pass</span>
<span class="linenos">3278</span>
<span class="linenos">3279</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3280</span>    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">3281</span>        <span class="k">pass</span>
<span class="linenos">3282</span>
<span class="linenos">3283</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3284</span>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">3285</span>        <span class="k">pass</span>
<span class="linenos">3286</span>
<span class="linenos">3287</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3288</span>    <span class="k">def</span> <span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">3289</span>        <span class="k">pass</span>
<span class="linenos">3290</span>
<span class="linenos">3291</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3292</span>    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IO[AnyStr]&#39;</span><span class="p">:</span>
<span class="linenos">3293</span>        <span class="k">pass</span>
<span class="linenos">3294</span>
<span class="linenos">3295</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3296</span>    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">3297</span>        <span class="k">pass</span>
<span class="linenos">3298</span>
<span class="linenos">3299</span>
<span class="linenos">3300</span><span class="k">class</span> <span class="nc">BinaryIO</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]):</span>
<span class="linenos">3301</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of the return of open() in binary mode.&quot;&quot;&quot;</span>
<span class="linenos">3302</span>
<span class="linenos">3303</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">3304</span>
<span class="linenos">3305</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3306</span>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="linenos">3307</span>        <span class="k">pass</span>
<span class="linenos">3308</span>
<span class="linenos">3309</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3310</span>    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;BinaryIO&#39;</span><span class="p">:</span>
<span class="linenos">3311</span>        <span class="k">pass</span>
<span class="linenos">3312</span>
<span class="linenos">3313</span>
<span class="linenos">3314</span><span class="k">class</span> <span class="nc">TextIO</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="linenos">3315</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of the return of open() in text mode.&quot;&quot;&quot;</span>
<span class="linenos">3316</span>
<span class="linenos">3317</span>    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
<span class="linenos">3318</span>
<span class="linenos">3319</span>    <span class="nd">@property</span>
<span class="linenos">3320</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3321</span>    <span class="k">def</span> <span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryIO</span><span class="p">:</span>
<span class="linenos">3322</span>        <span class="k">pass</span>
<span class="linenos">3323</span>
<span class="linenos">3324</span>    <span class="nd">@property</span>
<span class="linenos">3325</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3326</span>    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="linenos">3327</span>        <span class="k">pass</span>
<span class="linenos">3328</span>
<span class="linenos">3329</span>    <span class="nd">@property</span>
<span class="linenos">3330</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3331</span>    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="linenos">3332</span>        <span class="k">pass</span>
<span class="linenos">3333</span>
<span class="linenos">3334</span>    <span class="nd">@property</span>
<span class="linenos">3335</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3336</span>    <span class="k">def</span> <span class="nf">line_buffering</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="linenos">3337</span>        <span class="k">pass</span>
<span class="linenos">3338</span>
<span class="linenos">3339</span>    <span class="nd">@property</span>
<span class="linenos">3340</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3341</span>    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="linenos">3342</span>        <span class="k">pass</span>
<span class="linenos">3343</span>
<span class="linenos">3344</span>    <span class="nd">@abstractmethod</span>
<span class="linenos">3345</span>    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TextIO&#39;</span><span class="p">:</span>
<span class="linenos">3346</span>        <span class="k">pass</span>
<span class="linenos">3347</span>
<span class="linenos">3348</span>
<span class="linenos">3349</span><span class="k">class</span> <span class="nc">_DeprecatedType</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="linenos">3350</span>    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="linenos">3351</span>        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
<span class="linenos">3352</span>            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
<span class="linenos">3353</span>                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is deprecated, import directly &quot;</span>
<span class="linenos">3354</span>                <span class="sa">f</span><span class="s2">&quot;from typing instead. </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> will be removed &quot;</span>
<span class="linenos">3355</span>                <span class="s2">&quot;in Python 3.12.&quot;</span><span class="p">,</span>
<span class="linenos">3356</span>                <span class="ne">DeprecationWarning</span><span class="p">,</span>
<span class="linenos">3357</span>                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="linenos">3358</span>            <span class="p">)</span>
<span class="linenos">3359</span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="linenos">3360</span>
<span class="linenos">3361</span>
<span class="linenos">3362</span><span class="k">class</span> <span class="nc">io</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_DeprecatedType</span><span class="p">):</span>
<span class="linenos">3363</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper namespace for IO generic classes.&quot;&quot;&quot;</span>
<span class="linenos">3364</span>
<span class="linenos">3365</span>    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;IO&#39;</span><span class="p">,</span> <span class="s1">&#39;TextIO&#39;</span><span class="p">,</span> <span class="s1">&#39;BinaryIO&#39;</span><span class="p">]</span>
<span class="linenos">3366</span>    <span class="n">IO</span> <span class="o">=</span> <span class="n">IO</span>
<span class="linenos">3367</span>    <span class="n">TextIO</span> <span class="o">=</span> <span class="n">TextIO</span>
<span class="linenos">3368</span>    <span class="n">BinaryIO</span> <span class="o">=</span> <span class="n">BinaryIO</span>
<span class="linenos">3369</span>
<span class="linenos">3370</span>
<span class="linenos">3371</span><span class="n">io</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.io&#39;</span>
<span class="linenos">3372</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">io</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
<span class="linenos">3373</span>
<span class="linenos">3374</span><span class="n">Pattern</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">stdlib_re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">3375</span><span class="n">Match</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">stdlib_re</span><span class="o">.</span><span class="n">Match</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="linenos">3376</span>
<span class="linenos">3377</span><span class="k">class</span> <span class="nc">re</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_DeprecatedType</span><span class="p">):</span>
<span class="linenos">3378</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper namespace for re type aliases.&quot;&quot;&quot;</span>
<span class="linenos">3379</span>
<span class="linenos">3380</span>    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Pattern&#39;</span><span class="p">,</span> <span class="s1">&#39;Match&#39;</span><span class="p">]</span>
<span class="linenos">3381</span>    <span class="n">Pattern</span> <span class="o">=</span> <span class="n">Pattern</span>
<span class="linenos">3382</span>    <span class="n">Match</span> <span class="o">=</span> <span class="n">Match</span>
<span class="linenos">3383</span>
<span class="linenos">3384</span>
<span class="linenos">3385</span><span class="n">re</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.re&#39;</span>
<span class="linenos">3386</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span>
<span class="linenos">3387</span>
<span class="linenos">3388</span>
<span class="linenos">3389</span><span class="k">def</span> <span class="nf">reveal_type</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="linenos">3390</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Reveal the inferred type of a variable.</span>
<span class="linenos">3391</span>
<span class="linenos">3392</span><span class="sd">    When a static type checker encounters a call to ``reveal_type()``,</span>
<span class="linenos">3393</span><span class="sd">    it will emit the inferred type of the argument::</span>
<span class="linenos">3394</span>
<span class="linenos">3395</span><span class="sd">        x: int = 1</span>
<span class="linenos">3396</span><span class="sd">        reveal_type(x)</span>
<span class="linenos">3397</span>
<span class="linenos">3398</span><span class="sd">    Running a static type checker (e.g., mypy) on this example</span>
<span class="linenos">3399</span><span class="sd">    will produce output similar to &#39;Revealed type is &quot;builtins.int&quot;&#39;.</span>
<span class="linenos">3400</span>
<span class="linenos">3401</span><span class="sd">    At runtime, the function prints the runtime type of the</span>
<span class="linenos">3402</span><span class="sd">    argument and returns it unchanged.</span>
<span class="linenos">3403</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3404</span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Runtime type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
<span class="linenos">3405</span>    <span class="k">return</span> <span class="n">obj</span>
<span class="linenos">3406</span>
<span class="linenos">3407</span>
<span class="linenos">3408</span><span class="k">def</span> <span class="nf">dataclass_transform</span><span class="p">(</span>
<span class="linenos">3409</span>    <span class="o">*</span><span class="p">,</span>
<span class="linenos">3410</span>    <span class="n">eq_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="linenos">3411</span>    <span class="n">order_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="linenos">3412</span>    <span class="n">kw_only_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="linenos">3413</span>    <span class="n">field_specifiers</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
<span class="linenos">3414</span>    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="linenos">3415</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">T</span><span class="p">]:</span>
<span class="linenos">3416</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to mark an object as providing dataclass-like behaviour.</span>
<span class="linenos">3417</span>
<span class="linenos">3418</span><span class="sd">    The decorator can be applied to a function, class, or metaclass.</span>
<span class="linenos">3419</span>
<span class="linenos">3420</span><span class="sd">    Example usage with a decorator function::</span>
<span class="linenos">3421</span>
<span class="linenos">3422</span><span class="sd">        T = TypeVar(&quot;T&quot;)</span>
<span class="linenos">3423</span>
<span class="linenos">3424</span><span class="sd">        @dataclass_transform()</span>
<span class="linenos">3425</span><span class="sd">        def create_model(cls: type[T]) -&gt; type[T]:</span>
<span class="linenos">3426</span><span class="sd">            ...</span>
<span class="linenos">3427</span><span class="sd">            return cls</span>
<span class="linenos">3428</span>
<span class="linenos">3429</span><span class="sd">        @create_model</span>
<span class="linenos">3430</span><span class="sd">        class CustomerModel:</span>
<span class="linenos">3431</span><span class="sd">            id: int</span>
<span class="linenos">3432</span><span class="sd">            name: str</span>
<span class="linenos">3433</span>
<span class="linenos">3434</span><span class="sd">    On a base class::</span>
<span class="linenos">3435</span>
<span class="linenos">3436</span><span class="sd">        @dataclass_transform()</span>
<span class="linenos">3437</span><span class="sd">        class ModelBase: ...</span>
<span class="linenos">3438</span>
<span class="linenos">3439</span><span class="sd">        class CustomerModel(ModelBase):</span>
<span class="linenos">3440</span><span class="sd">            id: int</span>
<span class="linenos">3441</span><span class="sd">            name: str</span>
<span class="linenos">3442</span>
<span class="linenos">3443</span><span class="sd">    On a metaclass::</span>
<span class="linenos">3444</span>
<span class="linenos">3445</span><span class="sd">        @dataclass_transform()</span>
<span class="linenos">3446</span><span class="sd">        class ModelMeta(type): ...</span>
<span class="linenos">3447</span>
<span class="linenos">3448</span><span class="sd">        class ModelBase(metaclass=ModelMeta): ...</span>
<span class="linenos">3449</span>
<span class="linenos">3450</span><span class="sd">        class CustomerModel(ModelBase):</span>
<span class="linenos">3451</span><span class="sd">            id: int</span>
<span class="linenos">3452</span><span class="sd">            name: str</span>
<span class="linenos">3453</span>
<span class="linenos">3454</span><span class="sd">    The ``CustomerModel`` classes defined above will</span>
<span class="linenos">3455</span><span class="sd">    be treated by type checkers similarly to classes created with</span>
<span class="linenos">3456</span><span class="sd">    ``@dataclasses.dataclass``.</span>
<span class="linenos">3457</span><span class="sd">    For example, type checkers will assume these classes have</span>
<span class="linenos">3458</span><span class="sd">    ``__init__`` methods that accept ``id`` and ``name``.</span>
<span class="linenos">3459</span>
<span class="linenos">3460</span><span class="sd">    The arguments to this decorator can be used to customize this behavior:</span>
<span class="linenos">3461</span><span class="sd">    - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be</span>
<span class="linenos">3462</span><span class="sd">        ``True`` or ``False`` if it is omitted by the caller.</span>
<span class="linenos">3463</span><span class="sd">    - ``order_default`` indicates whether the ``order`` parameter is</span>
<span class="linenos">3464</span><span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
<span class="linenos">3465</span><span class="sd">    - ``kw_only_default`` indicates whether the ``kw_only`` parameter is</span>
<span class="linenos">3466</span><span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
<span class="linenos">3467</span><span class="sd">    - ``field_specifiers`` specifies a static list of supported classes</span>
<span class="linenos">3468</span><span class="sd">        or functions that describe fields, similar to ``dataclasses.field()``.</span>
<span class="linenos">3469</span><span class="sd">    - Arbitrary other keyword arguments are accepted in order to allow for</span>
<span class="linenos">3470</span><span class="sd">        possible future extensions.</span>
<span class="linenos">3471</span>
<span class="linenos">3472</span><span class="sd">    At runtime, this decorator records its arguments in the</span>
<span class="linenos">3473</span><span class="sd">    ``__dataclass_transform__`` attribute on the decorated object.</span>
<span class="linenos">3474</span><span class="sd">    It has no other runtime effect.</span>
<span class="linenos">3475</span>
<span class="linenos">3476</span><span class="sd">    See PEP 681 for more details.</span>
<span class="linenos">3477</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">3478</span>    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">cls_or_fn</span><span class="p">):</span>
<span class="linenos">3479</span>        <span class="n">cls_or_fn</span><span class="o">.</span><span class="n">__dataclass_transform__</span> <span class="o">=</span> <span class="p">{</span>
<span class="linenos">3480</span>            <span class="s2">&quot;eq_default&quot;</span><span class="p">:</span> <span class="n">eq_default</span><span class="p">,</span>
<span class="linenos">3481</span>            <span class="s2">&quot;order_default&quot;</span><span class="p">:</span> <span class="n">order_default</span><span class="p">,</span>
<span class="linenos">3482</span>            <span class="s2">&quot;kw_only_default&quot;</span><span class="p">:</span> <span class="n">kw_only_default</span><span class="p">,</span>
<span class="linenos">3483</span>            <span class="s2">&quot;field_specifiers&quot;</span><span class="p">:</span> <span class="n">field_specifiers</span><span class="p">,</span>
<span class="linenos">3484</span>            <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">,</span>
<span class="linenos">3485</span>        <span class="p">}</span>
<span class="linenos">3486</span>        <span class="k">return</span> <span class="n">cls_or_fn</span>
<span class="linenos">3487</span>    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
<div id="searchbox"></div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2023, M. Simeoni, S. Kashani, J. Rué-Queralt &amp; Pyxu Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.5.
    <br/>
  </p>
</div>
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.13.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>