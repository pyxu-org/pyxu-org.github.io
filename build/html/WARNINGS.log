/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/fair/plugins_preview/index.rst:1118: WARNING: toctree contains reference to nonexisting document 'fair/plugins_preview/TokemakRec'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/fair/score.rst:29: WARNING: Bullet list ends without a blank line; unexpected unindent.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/xray.ipynb:11: WARNING: File not found: 'intro/tomo.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/fair/howto.rst:2: WARNING: Duplicate explicit target name: "catalogue website".
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/fair/howto.rst:33: WARNING: invalid syntax (<unknown>, line 2) in document 'fair/howto'
Parsed source in `python` block:
concatenations: from pyxu.opt.solver import GradientDescent
block source:   ModuleNotFoundError: No module named 'pyxu.opt.solver.GradientDescent'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/fair/plugins/index.rst:232: ERROR: Content block expected for the "grid" directive; none found.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:292: WARNING: File not found: 'api/abc.html#pyxu.abc.Operator.expr'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:459: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.pinv'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:459: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:689: WARNING: File not found: 'api/operator/linop.html#pyxu.operator.Gradient'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:691: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxFunc.moreau_envelope'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:700: WARNING: File not found: 'api/operator/func.html#pyxu.operator.PositiveL1Norm'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:709: WARNING: File not found: 'api/operator/func.html#pyxu.operator.SquaredL2Norm'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:710: WARNING: File not found: 'api/abc.html#pyxu.abc.Operator.argshift'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:722: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap.estimate_diff_lipschitz'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb:946: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxDiffFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:32: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:32: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap.jacobian'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:32: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffFunc.grad'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:32: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxFunc.prox'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:32: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.adjoint'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:38: WARNING: File not found: 'api/abc.html#pyxu-abc-arithmetic'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:40: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.Rule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:41: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.ScaleRule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:42: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.ArgScaleRule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:43: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.ArgShiftRule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:44: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.AddRule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:45: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.ChainRule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:46: WARNING: File not found: 'api/abc.html#pyxu.abc.arithmetic.TransposeRule'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:48: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:48: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:57: WARNING: File not found: 'api/operator/blocks.html#pyxu.operator.block_diag'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algebra.ipynb:57: WARNING: File not found: 'api/operator/blocks.html#pyxu.operator.stack'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:17: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.CG'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:29: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.PGD'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:58: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.CondatVu'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:58: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.PD3O'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:58: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.ADMM'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:58: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.ChambollePock'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:97: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.DouglasRachford'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:99: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.Adam'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:151: WARNING: File not found: 'api/opt.stop.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:168: WARNING: File not found: 'api/abc.html#pyxu.abc.Solver'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:168: WARNING: File not found: 'api/abc.html#pyxu.abc.Solver.m_init'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:168: WARNING: File not found: 'api/abc.html#pyxu.abc.Solver.m_step'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/algorithms.ipynb:172: WARNING: File not found: 'api/abc.html#pyxu.abc.Solver.fit'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/bayes.ipynb:47: WARNING: File not found: 'guide/fwdops.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/bayes.ipynb:62: WARNING: File not found: 'guide/funcs.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/bayes.ipynb:92: WARNING: File not found: 'guide/funcs.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb:11: WARNING: File not found: 'api/operator/linop.html#derivatives'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb:18: WARNING: File not found: 'api/operator/linop.html#pyxu.operator.PartialDerivative'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb:501: WARNING: File not found: 'api/operator/linop.html#pyxu.operator.Gradient'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb:511: WARNING: File not found: 'api/operator/linop.html#pyxu.operator.Hessian'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:142: WARNING: Title underline too short.

Implicit Functionals: The Undercover Agents üïµÔ∏è‚Äç‚ôÄÔ∏è
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:142: WARNING: Title underline too short.

Implicit Functionals: The Undercover Agents üïµÔ∏è‚Äç‚ôÄÔ∏è
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:27: WARNING: File not found: 'api/operator.interop.html#pyxu.operator.interop.from_source'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:27: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:27: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffFunc.grad'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:27: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxFunc.prox'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:29: WARNING: File not found: 'api/index.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:34: WARNING: File not found: 'api/abc.html#pyxu.abc.Func'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:34: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:53: WARNING: File not found: 'api/abc.html#pyxu.abc.Operator.argshift'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:66: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:66: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffFunc.grad'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:85: WARNING: File not found: 'api/operator.interop.html#pyxu.operator.interop.from_torch'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:85: WARNING: File not found: 'api/operator.interop.html#pyxu.operator.interop.from_jax'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:90: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:90: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxFunc.prox'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:110: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxFunc.moreau_envelope'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:137: WARNING: File not found: 'api/abc.html#pyxu.abc.ProxDiffFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:137: WARNING: File not found: 'api/abc.html#pyxu.abc.LinFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb:137: WARNING: File not found: 'api/abc.html#pyxu.abc.QuadraticFunc'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:11: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:17: WARNING: File not found: 'api/operator.interop.html#general'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:17: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:17: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.adjoint'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:17: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap.jacobian'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:19: WARNING: File not found: 'api/index.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:46: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:46: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:46: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.adjoint'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:55: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:66: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.adjoint'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:100: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:102: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.lipschitz'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:102: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.estimate_lipschitz'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:108: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.svdvals'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:110: WARNING: File not found: 'api/abc.html#pyxu.abc.SquareOp.trace'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:112: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.pinv'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:118: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:118: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp.from_array'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:124: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:129: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:134: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.apply'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:134: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:136: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap.jacobian'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:146: WARNING: File not found: 'api/operator.interop.html#pyxu.operator.interop.from_torch'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:146: WARNING: File not found: 'api/operator.interop.html#pyxu.operator.interop.from_jax'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:148: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:153: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/fwdops.ipynb:153: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/hpc.ipynb:214: WARNING: File not found: 'api/runtime.html#pyxu.runtime.Precision'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb:30: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.lipschitz'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb:30: WARNING: File not found: 'api/abc.html#pyxu.abc.DiffMap.diff_lipschitz'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb:40: WARNING: File not found: 'api/abc.html#pyxu.abc.Map.estimate_lipschitz'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb:51: WARNING: File not found: 'api/abc.html#pyxu.abc.LinOp'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb:285: WARNING: File not found: 'api/index.html'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb:285: WARNING: File not found: 'api/abc/arithmetic.html'
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/opt/solver/pds.py:docstring of pyxu.opt.solver.pds.ADMM:152: WARNING: Exception occurred in plotting opt-solver-3
 from /home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst:
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/matplotlib/sphinxext/plot_directive.py", line 552, in _run_code
    exec(code, ns)
  File "<string>", line 29, in <module>
TypeError: SquaredL2Norm.__init__() got an unexpected keyword argument 'dim'
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/contributing.ipynb:42: WARNING: invalid syntax (<unknown>, line 5) in document 'examples/contributing'
Parsed source in `python` block:
concatenations: try:
    from pyxu.opt.solver import GradientDescent
except ImportError as e:
    print(e)
block source:   !pip install pyxu-gradient-descent
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/deblur.ipynb:278: WARNING: File not found: 'api/opt.solver.html#pyxu.opt.solver.PD3O'
WARNING: missing attribute to_sciop in object pyxu.abc.LinOp
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/abc/operator.py:docstring of pyxu.abc.operator.LinOp.asarray:8: WARNING: Inline emphasis start-string without end-string.
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/abc/operator.py:docstring of pyxu.abc.operator.LinOp.asarray:8: WARNING: Inline emphasis start-string without end-string.
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/abc/operator.py:docstring of pyxu.abc.operator.LinOp.from_array:3: WARNING: Inline emphasis start-string without end-string.
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/abc/operator.py:docstring of pyxu.abc.operator.LinOp.from_array:3: WARNING: Inline emphasis start-string without end-string.
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:29: WARNING: Inline interpreted text or phrase reference start-string without end-string.
WARNING: missing attribute relative_indices in object pyxu.operator.Stencil
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Divergence:77: WARNING: Exception occurred in plotting linop-12
 from /home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst:
Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/matplotlib/sphinxext/plot_directive.py", line 552, in _run_code
    exec(code, ns)
  File "<string>", line 14, in <module>
  File "/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/abc/operator.py", line 337, in __mul__
    return arithmetic.ChainRule(lhs=self, rhs=other).op()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/abc/arithmetic.py", line 991, in __init__
    assert lhs.dim_shape == rhs.codim_shape, "Operator dimensions are not compatible."
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError: Operator dimensions are not compatible.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/GALLERY_HEADER.rst: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/contributing.ipynb: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/deblur.ipynb: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/images/GALLERY_HEADER.rst: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/stencils.ipynb: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/xray.ipynb: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/fair/plugins_preview/TokamakRec.rst: WARNING: document isn't included in any toctree
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:5: WARNING: Citation [ProxAlg] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:6: WARNING: Citation [FirstOrd] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:7: WARNING: Citation [OnKerLearn] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:8: WARNING: Citation [ProxSplit] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:19: WARNING: Citation [P2] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:20: WARNING: Citation [GaussProcesses] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:21: WARNING: Citation [SubGauss] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:22: WARNING: Citation [FINUFFT] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:23: WARNING: Citation [cuFINUFFT] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:25: WARNING: Citation [PoCS_Dykstra] is not referenced.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/references.rst:29: WARNING: Citation [UQ_MCMC] is not referenced.
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/jax.py:docstring of pyxu.operator.interop.jax._from_jax:: WARNING: py:class reference target not found: pyxu.operator.interop.jax.JaxArray
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/jax.py:docstring of pyxu.operator.interop.jax._to_jax:: WARNING: py:class reference target not found: pyxu.operator.interop.jax.JaxArray
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:33: WARNING: py:class reference target not found: -----
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:34: WARNING: py:class reference target not found: * If provided
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:34: WARNING: py:class reference target not found: arithmetic methods must abide exactly
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:34: WARNING: py:class reference target not found: the interface below
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:46: WARNING: py:class reference target not found: * Auto-vectorization consists in decorating `kwargs
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:48: WARNING: py:class reference target not found: * Arithmetic methods are **not currently JIT-ed** even if `jit
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:48: WARNING: py:class reference target not found: the
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:50: WARNING: py:class reference target not found: * For :py:class:`~pyxu.abc.DiffMap
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:50: WARNING: py:class reference target not found: the methods :py:meth:`~pyxu.abc.DiffMap.jacobian
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/interop/torch.py:docstring of pyxu.operator.interop.torch.from_torch:57: WARNING: py:class reference target not found: . Warning::
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/pad.py:docstring of pyxu.operator.linop.pad.Pad.__init__:10: WARNING: py:class reference target not found: pyxu.operator.linop.pad.Pad.WidthSpec
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/fft/czt.py:docstring of pyxu.operator.linop.fft.czt.CZT.__init__:6: WARNING: py:class reference target not found: list(int)
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/fft/czt.py:docstring of pyxu.operator.linop.fft.czt.CZT.__init__:8: WARNING: py:class reference target not found: list(complex)
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/fft/czt.py:docstring of pyxu.operator.linop.fft.czt.CZT.__init__:10: WARNING: py:class reference target not found: list(complex)
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/filter.py:docstring of pyxu.operator.linop.filter.MovingAverage:30: WARNING: py:class reference target not found: pyxu.operator.linop.filter.IndexSpec
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/filter.py:docstring of pyxu.operator.linop.filter.MovingAverage:76: WARNING: py:class reference target not found: pyxu.operator.GaussianFilter
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:62: WARNING: py:class reference target not found: (Integer
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:62: WARNING: py:class reference target not found: Integer)
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:62: WARNING: py:class reference target not found: ((Integer
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:62: WARNING: py:class reference target not found: Integer)
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:62: WARNING: py:class reference target not found: (Integer
/opt/hostedtoolcache/Python/3.12.8/x64/lib/python3.12/site-packages/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:62: WARNING: py:class reference target not found: Integer))
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/contributing.ipynb:42: WARNING: Lexing literal_block '!pip install pyxu-gradient-descent' as "python" resulted in an error at token: '!'. Retrying in relaxed mode.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/index.rst:46: WARNING: toctree contains reference to document 'examples/images/index' that doesn't have a title: no link will be generated
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/index.rst:46: WARNING: toctree contains reference to document 'examples/images/index' that doesn't have a title: no link will be generated
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/stencils.ipynb: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/stencils.ipynb: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/stencils.ipynb: WARNING: Could not match transformation of `scipy.signal` on source lines 1-1, source:
from scipy.signal import convolve as conv_scipy

# Direct 2D convolution
y = conv_scipy(data, kernel_2d, mode="same", method="direct")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/stencils.ipynb: WARNING: Could not match transformation of `jax.numpy` on source lines 3-3, source:
from scico.linop import Convolve as Conv_scico
from jax import config
import jax.numpy as jnp

# Convert data and kernel from Numpy to Jax
data_jax = jnp.asarray(data)
k2d_jax = jnp.asarray(kernel_2d)
config.update("jax_enable_x64", True)

# 2d convolution
conv_scico = Conv_scico(
    k2d_jax,
    input_shape=data_jax.shape,
    input_dtype=data_jax.dtype,
    mode="same",
    jit=True,
)
y_scico = conv_scico(data_jax)
assert np.allclose(y, y_scico)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/stencils.ipynb: WARNING: Could not match transformation of `time` on source lines 1-1, source:
import time
import tqdm

npixs = [2**i for i in range(6, 10)]
nwidths = [2**i + 1 for i in range(3, 8)]

t_pyxu = np.full((2, len(npixs), len(nwidths)), np.nan)
t_scipy = np.full((2, len(npixs), len(nwidths)), np.nan)
t_pylops = np.full((2, len(npixs), len(nwidths)), np.nan)
t_scico = np.full((2, len(npixs), len(nwidths)), np.nan)

sigma = 2
gauss = lambda x: (1 / (2 * np.pi * sigma**2)) * np.exp(
    -0.5 * ((x - (width - 1) / 2) ** 2) / (sigma**2)
)

nreps = 5

with tqdm.tqdm(total=len(npixs) * len(nwidths)) as pbar:
    for i, npix in enumerate(npixs):
        x = skimage.data.binary_blobs(
            length=npix, blob_size_fraction=0.5, n_dim=2, volume_fraction=0.2
        ).astype(float)
        for j, width in enumerate(nwidths):
            if npix > (width * 2):
                kernel = np.fromfunction(gauss, (width,))
                data_jax = jnp.asarray(data)
                k1d_jax = jnp.asarray(kernel_1d)

                ## PYXU

                # Instantation + first run time
                tic = time.perf_counter()
                conv_pyxu = Convolve(
                    dim_shape=data.shape,
                    kernel=[kernel, kernel],
                    center=[width // 2, width // 2],
                    mode="constant",
                    enable_warnings=True,
                )
                y = conv_pyxu(data)
                t_pyxu[0, i, j] = time.perf_counter() - tic

                # Run time
                times = 0
                for _ in range(nreps):
                    tic = time.perf_counter()
                    y = conv_pyxu(data)
                    times += time.perf_counter() - tic

                t_pyxu[1, i, j] = times / nreps

                ## SCIPY

                # Instantation + first run time
                tic = time.perf_counter()
                convolved_rows = conv_scipy(
                    data, kernel_1d[:, np.newaxis], mode="same", method="direct"
                )  # Along rows
                y_scipy = conv_scipy(
                    convolved_rows,
                    kernel_1d[np.newaxis, :],
                    mode="same",
                    method="direct",
                )  # Along columns

                t_scipy[0, i, j] = time.perf_counter() - tic

                # Run time
                times = 0
                for _ in range(nreps):
                    tic = time.perf_counter()
                    convolved_rows = conv_scipy(
                        data, kernel_1d[:, np.newaxis], mode="same", method="direct"
                    )  # Along rows
                    y_scipy = conv_scipy(
                        convolved_rows,
                        kernel_1d[np.newaxis, :],
                        mode="same",
                        method="direct",
                    )  # Along columns
                    times += time.perf_counter() - tic

                t_scipy[1, i, j] = times / nreps

                ## PYLOPS

                # Instantation + first run time
                tic = time.perf_counter()
                conv_pylops_rows = from_sciop(
                    cls=pxa.LinOp,
                    sp_op=Convolve2D(
                        dims=data.shape,
                        h=kernel_1d[np.newaxis, :],
                        offset=np.r_[0, width // 2],
                        axes=(0, 1),
                        method="direct",
                    ),
                )
                conv_pylops_cols = from_sciop(
                    cls=pxa.LinOp,
                    sp_op=Convolve2D(
                        dims=data.shape,
                        h=kernel_1d[:, np.newaxis],
                        offset=np.r_[width // 2, 0],
                        axes=(0, 1),
                        method="direct",
                    ),
                )

                y_pylops = conv_pylops_cols(conv_pylops_rows(data.ravel())).reshape(
                    data.shape
                )
                t_pylops[0, i, j] = time.perf_counter() - tic

                # Run time
                times = 0
                for _ in range(nreps):
                    tic = time.perf_counter()
                    y_pylops = conv_pylops_cols(conv_pylops_rows(data.ravel())).reshape(
                        data.shape
                    )
                    times += time.perf_counter() - tic
                t_pylops[1, i, j] = times / nreps

                ## SCICO

                # Instantation + first run time

                tic = time.perf_counter()
                config.update("jax_enable_x64", True)

                conv_scico_rows = Conv_scico(
                    k1d_jax[np.newaxis, :],
                    input_shape=data_jax.shape,
                    input_dtype=data_jax.dtype,
                    mode="same",
                    jit=True,
                )
                conv_scico_cols = Conv_scico(
                    k1d_jax[:, np.newaxis],
                    input_shape=data_jax.shape,
                    input_dtype=data_jax.dtype,
                    mode="same",
                    jit=True,
                )
                y_scico = conv_scico_cols(conv_scico_rows(data_jax))
                t_scico[0, i, j] = time.perf_counter() - tic

                # Run time
                times = 0
                for _ in range(nreps):
                    tic = time.perf_counter()
                    y_scico = conv_scico_cols(conv_scico_rows(data_jax))
                    times += time.perf_counter() - tic
                t_scico[1, i, j] = times / nreps
            pbar.update(1)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/xray.ipynb: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import skimage as ski
import warnings as warn
import pyxu.operator as pxo

warn.filterwarnings("ignore")
plt.style.use("seaborn-v0_8-darkgrid")
plt.rcParams["figure.figsize"] = [4, 4]
plt.rcParams["figure.dpi"] = 300
plt.rcParams["axes.grid"] = True
plt.rcParams["image.cmap"] = "Greys"
plt.rcParams['axes.labelsize'] = 6
plt.rcParams['axes.titlesize'] = 8
plt.rcParams["xtick.labelsize"] = 6
plt.rcParams["ytick.labelsize"] = 6
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/xray.ipynb: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import skimage as ski
import warnings as warn
import pyxu.operator as pxo

warn.filterwarnings("ignore")
plt.style.use("seaborn-v0_8-darkgrid")
plt.rcParams["figure.figsize"] = [4, 4]
plt.rcParams["figure.dpi"] = 300
plt.rcParams["axes.grid"] = True
plt.rcParams["image.cmap"] = "Greys"
plt.rcParams['axes.labelsize'] = 6
plt.rcParams['axes.titlesize'] = 8
plt.rcParams["xtick.labelsize"] = 6
plt.rcParams["ytick.labelsize"] = 6
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/xray.ipynb: WARNING: Could not match transformation of `scipy` on source lines 3-3, source:
import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import skimage as ski
import warnings as warn
import pyxu.operator as pxo

warn.filterwarnings("ignore")
plt.style.use("seaborn-v0_8-darkgrid")
plt.rcParams["figure.figsize"] = [4, 4]
plt.rcParams["figure.dpi"] = 300
plt.rcParams["axes.grid"] = True
plt.rcParams["image.cmap"] = "Greys"
plt.rcParams['axes.labelsize'] = 6
plt.rcParams['axes.titlesize'] = 8
plt.rcParams["xtick.labelsize"] = 6
plt.rcParams["ytick.labelsize"] = 6
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/xray.ipynb: WARNING: Could not match transformation of `warnings` on source lines 5-5, source:
import matplotlib.pyplot as plt
import numpy as np
import scipy as sp
import skimage as ski
import warnings as warn
import pyxu.operator as pxo

warn.filterwarnings("ignore")
plt.style.use("seaborn-v0_8-darkgrid")
plt.rcParams["figure.figsize"] = [4, 4]
plt.rcParams["figure.dpi"] = 300
plt.rcParams["axes.grid"] = True
plt.rcParams["image.cmap"] = "Greys"
plt.rcParams['axes.labelsize'] = 6
plt.rcParams['axes.titlesize'] = 8
plt.rcParams["xtick.labelsize"] = 6
plt.rcParams["ytick.labelsize"] = 6
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/intro/tomo.ipynb: WARNING: Could not match transformation of `scipy.ndimage` on source lines 1-1, source:
from scipy.ndimage import median_filter

def denoiser(arr, wsize):
    return median_filter(arr, size=wsize)

class MedianFilterPnP(pxa.ProxDiffFunc):
    def __init__(self, dim_shape, wsize):
        super().__init__(
            dim_shape=dim_shape,
            codim_shape=1,
        )
        self.wsize= wsize
        self.diff_lipschitz = 1

    def apply(self, arr):
        return NotImplemented  # PnP priors are implicit: they do not have an apply method!

    def grad(self, arr):
        return arr - denoiser(arr, self.wsize)  # Differential form

    def prox(self, arr, tau=None):  # `tau`` is not used since this is not a proper proximal operator.
        return denoiser(arr, self.wsize)  # Proximal form
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/migration_guide.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve, L21Norm, Gradient, SquaredL2Norm, PositiveOrthant
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError

# Load and preprocess the data
data = skimage.data.cat()  # shape (300, 451, 3)
data = np.asarray(data.astype("float32") / 255.0).transpose(2, 0, 1)  # shape (3, 300, 451)

# Create the Gaussian blurring kernel
sigma = 7
width = 13
mu = (width - 1) / 2
gauss = lambda x: (1 / (2 * np.pi * sigma**2)) * np.exp(-0.5 * ((x - mu) ** 2) / (sigma**2))
kernel_1d = np.fromfunction(gauss, (width,)).reshape(1, -1)

# The shape of the input array will be used to define operators
dim_shape = data.shape
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/migration_guide.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve, L21Norm, Gradient, SquaredL2Norm, PositiveOrthant
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError

# Load and preprocess the data
data = skimage.data.cat()  # shape (300, 451, 3)
data = np.asarray(data.astype("float32") / 255.0).transpose(2, 0, 1)  # shape (3, 300, 451)

# Create the Gaussian blurring kernel
sigma = 7
width = 13
mu = (width - 1) / 2
gauss = lambda x: (1 / (2 * np.pi * sigma**2)) * np.exp(-0.5 * ((x - mu) ** 2) / (sigma**2))
kernel_1d = np.fromfunction(gauss, (width,)).reshape(1, -1)

# The shape of the input array will be used to define operators
dim_shape = data.shape
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/bayes.ipynb: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
# Importing necessary libraries and modules
import matplotlib.pyplot as plt
import numpy as np

from pyxu.operator import L21Norm, Gradient, SquaredL2Norm, PositiveOrthant, IdentityOp
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError
from PIL import Image
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/bayes.ipynb: WARNING: Could not match transformation of `numpy` on source lines 3-3, source:
# Importing necessary libraries and modules
import matplotlib.pyplot as plt
import numpy as np

from pyxu.operator import L21Norm, Gradient, SquaredL2Norm, PositiveOrthant, IdentityOp
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError
from PIL import Image
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np

def D(f):
    """
    Computes the partial derivative via forward finite differences.

    Input
    -----
    f: vector
        Input signal

    Output
    ------
    y: vector
        Derivative
    """

    y = np.zeros_like(f)
    for n in range(len(f) - 1):
        y[n] = f[n + 1] - f[n]
    return y
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np

rng = np.random.default_rng(0)

from pyxu.operator import PartialDerivative
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/diff_ops.ipynb: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np

rng = np.random.default_rng(0)

from pyxu.operator import PartialDerivative
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
from pyxu.abc import Func

class SquaredL2(Func):
    def __init__(self, dim_shape):
        super().__init__(dim_shape=dim_shape, codim_shape=1)

    def apply(self, arr):
        # Calculate over the last dimensions to support batching dimensions.
        # This ensures the squared L2 norm is applied in parallel across batches.
        axis = tuple(range(-len(self.dim_shape), 0))
        return (arr**2).sum(axis=axis)[..., np.newaxis]
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/funcs.ipynb: WARNING: Could not match transformation of `scipy.ndimage` on source lines 2-2, source:
from pyxu.abc import ProxFunc
from scipy.ndimage import median_filter

class MedianFilterPrior(ProxFunc):
    def __init__(self, dim_shape):
        super().__init__(dim_shape=dim_shape, codim_shape=1)

    def apply(self, arr):
        return NotImplementedError  # apply method not provided

    def prox(self, arr, tau):
        return median_filter(arr, size=5)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/hpc.ipynb: WARNING: Could not match transformation of `pyxu.runtime` on source lines 3-3, source:
import pyxu.abc as pxa
import pyxu.util as pxu
import pyxu.runtime as pxrt

class Median(pxa.Func):
    def __init__(self, dim_shape):
        super(Median, self).__init__(dim_shape=dim_shape, codim_shape=1)

    # Enforce input/output precision.
    @pxrt.enforce_precision(i="arr")
    def apply(self, arr):
        xp = pxu.get_array_module(arr)   # Find the array module.
        # Calculate over the last dimensions to support batching dimensions.
        axis = tuple(range(-len(self.dim_shape), 0))
        return xp.median(arr,            # Dispatch the median call to the right backend.
                         axis=axis,        # Allow for batch dimensions.
                         keepdims=True)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/hpc.ipynb: WARNING: Could not match transformation of `time` on source lines 1-1, source:
import time as t
import numpy as np
import pyxu.info.deps as pxd

timings = dict()
dim_shape = (5, )
m = Median(dim_shape)
for xp in pxd.supported_array_modules():  # Loops over supported array backends
    # Apply the operator in turn on a various array types.
    rng = xp.random.default_rng()
    arr = rng.standard_normal(size=dim_shape)
    out = m.apply(arr)
    print(type(out), out.dtype, pxu.compute(out))  # we use compute() to evaluate Dask arrays.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/hpc.ipynb: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import time as t
import numpy as np
import pyxu.info.deps as pxd

timings = dict()
dim_shape = (5, )
m = Median(dim_shape)
for xp in pxd.supported_array_modules():  # Loops over supported array backends
    # Apply the operator in turn on a various array types.
    rng = xp.random.default_rng()
    arr = rng.standard_normal(size=dim_shape)
    out = m.apply(arr)
    print(type(out), out.dtype, pxu.compute(out))  # we use compute() to evaluate Dask arrays.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/hpc.ipynb: WARNING: Could not match transformation of `pyxu.info.deps` on source lines 3-3, source:
import time as t
import numpy as np
import pyxu.info.deps as pxd

timings = dict()
dim_shape = (5, )
m = Median(dim_shape)
for xp in pxd.supported_array_modules():  # Loops over supported array backends
    # Apply the operator in turn on a various array types.
    rng = xp.random.default_rng()
    arr = rng.standard_normal(size=dim_shape)
    out = m.apply(arr)
    print(type(out), out.dtype, pxu.compute(out))  # we use compute() to evaluate Dask arrays.
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/guide/lipschitz.ipynb: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
from pyxu.abc import LinOp
import numpy as np

rand_op = LinOp.from_array(np.random.random((10000, 10000)))
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.operator as pxo
from pyxu.operator import SubSample, PartialDerivative
from pyxu.opt.solver import CV

x = np.repeat(np.asarray([0, 2, 1, 3, 0, 2, 0]), 10)
N = x.size

D = PartialDerivative.finite_difference(dim_shape=(N,), order=(1,))

downsample = SubSample(N, slice(None, None, 3))
y = downsample(x)
loss = (1 / 2) * pxo.SquaredL2Norm(y.size).argshift(-y)
F = loss * downsample

cv = CV(f=F, g=0.01 * pxo.L1Norm(N), h=0.1 * pxo.L1Norm((N)), K=D)
x0, z0 = np.zeros((2, N))
cv.fit(x0=x0, z0=z0)
x_recons = cv.solution()

plt.figure()
plt.stem(x, linefmt="C0-", markerfmt="C0o")
mask_ids = np.where(downsample.adjoint(np.ones_like(y)))[0]
markerline, stemlines, baseline = plt.stem(mask_ids, y, linefmt="C3-", markerfmt="C3o")
markerline.set_markerfacecolor("none")
plt.stem(x_recons, linefmt="C1--", markerfmt="C1s")
plt.legend(["Ground truth", "Observation", "CV Estimate"])
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.operator as pxo
from pyxu.operator import SubSample, PartialDerivative
from pyxu.opt.solver import CV

x = np.repeat(np.asarray([0, 2, 1, 3, 0, 2, 0]), 10)
N = x.size

D = PartialDerivative.finite_difference(dim_shape=(N,), order=(1,))

downsample = SubSample(N, slice(None, None, 3))
y = downsample(x)
loss = (1 / 2) * pxo.SquaredL2Norm(y.size).argshift(-y)
F = loss * downsample

cv = CV(f=F, g=0.01 * pxo.L1Norm(N), h=0.1 * pxo.L1Norm((N)), K=D)
x0, z0 = np.zeros((2, N))
cv.fit(x0=x0, z0=z0)
x_recons = cv.solution()

plt.figure()
plt.stem(x, linefmt="C0-", markerfmt="C0o")
mask_ids = np.where(downsample.adjoint(np.ones_like(y)))[0]
markerline, stemlines, baseline = plt.stem(mask_ids, y, linefmt="C3-", markerfmt="C3o")
markerline.set_markerfacecolor("none")
plt.stem(x_recons, linefmt="C1--", markerfmt="C1s")
plt.legend(["Ground truth", "Observation", "CV Estimate"])
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.operator as pxo
from pyxu.operator import SubSample, PartialDerivative
from pyxu.opt.solver import PD3O

x = np.repeat(np.asarray([0, 2, 1, 3, 0, 2, 0]), 10)
N = x.size

D = PartialDerivative.finite_difference(dim_shape=(N,), order=(1,))

downsample = SubSample(N, slice(None, None, 3))
y = downsample(x)
loss = (1 / 2) * pxo.SquaredL2Norm(y.size).argshift(-y)
F = loss * downsample

pd3o = PD3O(f=F, g=0.01 * pxo.L1Norm(N), h=0.1 * pxo.L1Norm((N)), K=D)
x0, z0 = np.zeros((2, N))
pd3o.fit(x0=x0, z0=z0)
x_recons = pd3o.solution()

plt.figure()
plt.stem(x, linefmt="C0-", markerfmt="C0o")
mask_ids = np.where(downsample.adjoint(np.ones_like(y)))[0]
markerline, stemlines, baseline = plt.stem(mask_ids, y, linefmt="C3-", markerfmt="C3o")
markerline.set_markerfacecolor("none")
plt.stem(x_recons, linefmt="C1--", markerfmt="C1s")
plt.legend(["Ground truth", "Observation", "PD3O Estimate"])
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.operator as pxo
from pyxu.operator import SubSample, PartialDerivative
from pyxu.opt.solver import PD3O

x = np.repeat(np.asarray([0, 2, 1, 3, 0, 2, 0]), 10)
N = x.size

D = PartialDerivative.finite_difference(dim_shape=(N,), order=(1,))

downsample = SubSample(N, slice(None, None, 3))
y = downsample(x)
loss = (1 / 2) * pxo.SquaredL2Norm(y.size).argshift(-y)
F = loss * downsample

pd3o = PD3O(f=F, g=0.01 * pxo.L1Norm(N), h=0.1 * pxo.L1Norm((N)), K=D)
x0, z0 = np.zeros((2, N))
pd3o.fit(x0=x0, z0=z0)
x_recons = pd3o.solution()

plt.figure()
plt.stem(x, linefmt="C0-", markerfmt="C0o")
mask_ids = np.where(downsample.adjoint(np.ones_like(y)))[0]
markerline, stemlines, baseline = plt.stem(mask_ids, y, linefmt="C3-", markerfmt="C3o")
markerline.set_markerfacecolor("none")
plt.stem(x_recons, linefmt="C1--", markerfmt="C1s")
plt.legend(["Ground truth", "Observation", "PD3O Estimate"])
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.abc as pxa
import pyxu.operator as pxo
import scipy as sp
from pyxu.opt.solver import ADMM

N = 100  # Dimension of the problem

# Generate piecewise-linear ground truth
x_gt = np.array([10, 25, 60, 90])  # Knot locations
a_gt = np.array([2, -4, 3, -2])  # Amplitudes of the knots
gt = np.zeros(N)  # Ground-truth signal
for n in range(len(x_gt)):
    gt[x_gt[n] :] += a_gt[n] * np.arange(N - x_gt[n]) / N

# Generate data (noisy samples at random locations)
M = 20  # Number of data points
rng = np.random.default_rng(seed=0)
x_samp = rng.choice(np.arange(N // M), size=M) + np.arange(N, step=N // M)  # sampling locations
sigma = 2 * 1e-2  # noise variance
y = gt[x_samp] + sigma * rng.standard_normal(size=M)  # noisy data points

# Data-fidelity term
subsamp_mat = sp.sparse.lil_matrix((M, N))
for i in range(M):
    subsamp_mat[i, x_samp[i]] = 1
G = pxa.LinOp.from_array(subsamp_mat.tocsr())
F = 1 / 2 * pxo.SquaredL2Norm(dim=y.size).argshift(-y) * G
F.diff_lipschitz = F.estimate_diff_lipschitz(method="svd")

# Regularization term (promotes sparse second derivatives)
deriv_mat = sp.sparse.diags(diagonals=[1, -2, 1], offsets=[0, 1, 2], shape=(N - 2, N))
D = pxa.LinOp.from_array(deriv_mat)
_lambda = 1e-1  # regularization parameter
H = _lambda * pxo.L1Norm(dim=D.codim)

# Solver for ADMM
tau = 1 / _lambda  # internal ADMM parameter
# Inverse operator to solve the linear system
A_inv = sp.linalg.inv(G.gram().asarray() + (1 / tau) * D.gram().asarray())

def solver_ADMM(arr, tau):
    b = (1 / tau) * D.adjoint(arr) + G.adjoint(y)
    return A_inv @ b.squeeze()


# Solve optimization problem
admm = ADMM(f=F, h=H, K=D, solver=solver_ADMM,show_progress=False)  # with solver
admm.fit(x0=np.zeros(N), tau=tau)
x_opt = admm.solution()  # reconstructed signal

# Plots
plt.figure()
plt.plot(np.arange(N), gt, label="Ground truth")
plt.plot(x_samp, y, "kx", label="Noisy data points")
plt.plot(np.arange(N), x_opt, label="Reconstructed signal")
plt.legend()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.abc as pxa
import pyxu.operator as pxo
import scipy as sp
from pyxu.opt.solver import ADMM

N = 100  # Dimension of the problem

# Generate piecewise-linear ground truth
x_gt = np.array([10, 25, 60, 90])  # Knot locations
a_gt = np.array([2, -4, 3, -2])  # Amplitudes of the knots
gt = np.zeros(N)  # Ground-truth signal
for n in range(len(x_gt)):
    gt[x_gt[n] :] += a_gt[n] * np.arange(N - x_gt[n]) / N

# Generate data (noisy samples at random locations)
M = 20  # Number of data points
rng = np.random.default_rng(seed=0)
x_samp = rng.choice(np.arange(N // M), size=M) + np.arange(N, step=N // M)  # sampling locations
sigma = 2 * 1e-2  # noise variance
y = gt[x_samp] + sigma * rng.standard_normal(size=M)  # noisy data points

# Data-fidelity term
subsamp_mat = sp.sparse.lil_matrix((M, N))
for i in range(M):
    subsamp_mat[i, x_samp[i]] = 1
G = pxa.LinOp.from_array(subsamp_mat.tocsr())
F = 1 / 2 * pxo.SquaredL2Norm(dim=y.size).argshift(-y) * G
F.diff_lipschitz = F.estimate_diff_lipschitz(method="svd")

# Regularization term (promotes sparse second derivatives)
deriv_mat = sp.sparse.diags(diagonals=[1, -2, 1], offsets=[0, 1, 2], shape=(N - 2, N))
D = pxa.LinOp.from_array(deriv_mat)
_lambda = 1e-1  # regularization parameter
H = _lambda * pxo.L1Norm(dim=D.codim)

# Solver for ADMM
tau = 1 / _lambda  # internal ADMM parameter
# Inverse operator to solve the linear system
A_inv = sp.linalg.inv(G.gram().asarray() + (1 / tau) * D.gram().asarray())

def solver_ADMM(arr, tau):
    b = (1 / tau) * D.adjoint(arr) + G.adjoint(y)
    return A_inv @ b.squeeze()


# Solve optimization problem
admm = ADMM(f=F, h=H, K=D, solver=solver_ADMM,show_progress=False)  # with solver
admm.fit(x0=np.zeros(N), tau=tau)
x_opt = admm.solution()  # reconstructed signal

# Plots
plt.figure()
plt.plot(np.arange(N), gt, label="Ground truth")
plt.plot(x_samp, y, "kx", label="Noisy data points")
plt.plot(np.arange(N), x_opt, label="Reconstructed signal")
plt.legend()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/opt.solver.rst: WARNING: Could not match transformation of `scipy` on source lines 5-5, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.abc as pxa
import pyxu.operator as pxo
import scipy as sp
from pyxu.opt.solver import ADMM

N = 100  # Dimension of the problem

# Generate piecewise-linear ground truth
x_gt = np.array([10, 25, 60, 90])  # Knot locations
a_gt = np.array([2, -4, 3, -2])  # Amplitudes of the knots
gt = np.zeros(N)  # Ground-truth signal
for n in range(len(x_gt)):
    gt[x_gt[n] :] += a_gt[n] * np.arange(N - x_gt[n]) / N

# Generate data (noisy samples at random locations)
M = 20  # Number of data points
rng = np.random.default_rng(seed=0)
x_samp = rng.choice(np.arange(N // M), size=M) + np.arange(N, step=N // M)  # sampling locations
sigma = 2 * 1e-2  # noise variance
y = gt[x_samp] + sigma * rng.standard_normal(size=M)  # noisy data points

# Data-fidelity term
subsamp_mat = sp.sparse.lil_matrix((M, N))
for i in range(M):
    subsamp_mat[i, x_samp[i]] = 1
G = pxa.LinOp.from_array(subsamp_mat.tocsr())
F = 1 / 2 * pxo.SquaredL2Norm(dim=y.size).argshift(-y) * G
F.diff_lipschitz = F.estimate_diff_lipschitz(method="svd")

# Regularization term (promotes sparse second derivatives)
deriv_mat = sp.sparse.diags(diagonals=[1, -2, 1], offsets=[0, 1, 2], shape=(N - 2, N))
D = pxa.LinOp.from_array(deriv_mat)
_lambda = 1e-1  # regularization parameter
H = _lambda * pxo.L1Norm(dim=D.codim)

# Solver for ADMM
tau = 1 / _lambda  # internal ADMM parameter
# Inverse operator to solve the linear system
A_inv = sp.linalg.inv(G.gram().asarray() + (1 / tau) * D.gram().asarray())

def solver_ADMM(arr, tau):
    b = (1 / tau) * D.adjoint(arr) + G.adjoint(y)
    return A_inv @ b.squeeze()


# Solve optimization problem
admm = ADMM(f=F, h=H, K=D, solver=solver_ADMM,show_progress=False)  # with solver
admm.fit(x0=np.zeros(N), tau=tau)
x_opt = admm.solution()  # reconstructed signal

# Plots
plt.figure()
plt.plot(np.arange(N), gt, label="Ground truth")
plt.plot(x_samp, y, "kx", label="Noisy data points")
plt.plot(np.arange(N), x_opt, label="Reconstructed signal")
plt.legend()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/util.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.util.misc import peaks

x = np.linspace(-3, 3, 1000)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
plt.figure()
plt.imshow(z)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/util.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.util.misc import peaks

x = np.linspace(-3, 3, 1000)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
plt.figure()
plt.imshow(z)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/util.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.util.misc import star_like_sample

star = star_like_sample(N=256, w=8, s=20, po=3, x0=0.7)
plt.figure()
plt.imshow(star)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/util.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.util.misc import star_like_sample

star = star_like_sample(N=256, w=8, s=20, po=3, x0=0.7)
plt.figure()
plt.imshow(star)
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/contributing.ipynb: WARNING: Could not match transformation of `numpy` on source lines 3-3, source:
from pyxu.operator import SquaredL2Norm
from pyxu.opt.solver import GradientDescent
import numpy as np
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/deblur.ipynb: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
# Importing necessary libraries and modules
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve, L21Norm, Gradient, SquaredL2Norm, PositiveOrthant
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError, MaxIter

# Setting up GPU support
GPU = False
if GPU:
    import cupy as xp
else:
    import numpy as xp
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/deblur.ipynb: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 3-3, source:
# Importing necessary libraries and modules
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve, L21Norm, Gradient, SquaredL2Norm, PositiveOrthant
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError, MaxIter

# Setting up GPU support
GPU = False
if GPU:
    import cupy as xp
else:
    import numpy as xp
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/deblur.ipynb: WARNING: Could not match transformation of `cupy` on source lines 12-12, source:
# Importing necessary libraries and modules
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve, L21Norm, Gradient, SquaredL2Norm, PositiveOrthant
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError, MaxIter

# Setting up GPU support
GPU = False
if GPU:
    import cupy as xp
else:
    import numpy as xp
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/examples/deblur.ipynb: WARNING: Could not match transformation of `numpy` on source lines 14-14, source:
# Importing necessary libraries and modules
import numpy as np
import matplotlib.pyplot as plt
import skimage
from pyxu.operator import Convolve, L21Norm, Gradient, SquaredL2Norm, PositiveOrthant
from pyxu.opt.solver import PD3O
from pyxu.opt.stop import RelError, MaxIter

# Setting up GPU support
GPU = False
if GPU:
    import cupy as xp
else:
    import numpy as xp
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/abc.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.abc import ProxFunc

class L1Norm(ProxFunc):
    def __init__(self, dim: int):
        super().__init__(dim_shape=dim, codim_shape=1)
    def apply(self, arr):
        return np.linalg.norm(arr, axis=-1, keepdims=True, ord=1)
    def prox(self, arr, tau):
        return np.clip(np.abs(arr)-tau, a_min=0, a_max=None) * np.sign(arr)

mu = [0.1, 0.5, 1]
f = [L1Norm(dim=1).moreau_envelope(_mu) for _mu in mu]
x = np.linspace(-1, 1, 512).reshape(-1, 1)  # evaluation points

fig, ax = plt.subplots(ncols=2)
for _mu, _f in zip(mu, f):
    ax[0].plot(x, _f(x), label=f"mu={_mu}")
    ax[1].plot(x, _f.grad(x), label=f"mu={_mu}")
ax[0].set_title('Moreau Envelope')
ax[1].set_title("Derivative of Moreau Envelope")
for _ax in ax:
    _ax.legend()
    _ax.set_aspect("equal")
fig.tight_layout()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/abc.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.abc import ProxFunc

class L1Norm(ProxFunc):
    def __init__(self, dim: int):
        super().__init__(dim_shape=dim, codim_shape=1)
    def apply(self, arr):
        return np.linalg.norm(arr, axis=-1, keepdims=True, ord=1)
    def prox(self, arr, tau):
        return np.clip(np.abs(arr)-tau, a_min=0, a_max=None) * np.sign(arr)

mu = [0.1, 0.5, 1]
f = [L1Norm(dim=1).moreau_envelope(_mu) for _mu in mu]
x = np.linspace(-1, 1, 512).reshape(-1, 1)  # evaluation points

fig, ax = plt.subplots(ncols=2)
for _mu, _f in zip(mu, f):
    ax[0].plot(x, _f(x), label=f"mu={_mu}")
    ax[1].plot(x, _f.grad(x), label=f"mu={_mu}")
ax[0].set_title('Moreau Envelope')
ax[1].set_title("Derivative of Moreau Envelope")
for _ax in ax:
    _ax.legend()
    _ax.set_aspect("equal")
fig.tight_layout()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/experimental/sampler.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.experimental.sampler as pxe_sampler
import pyxu.operator as pxo
import scipy as sp

f = pxo.SquaredL2Norm(dim_shape=1) / 2  # To sample 1D normal distribution (mean 0, variance 1)
ula = pxe_sampler.ULA(f=f)  # Sampler with maximum step size
ula_lb = pxe_sampler.ULA(f=f, gamma=1e-1)  # Sampler with small step size

gen_ula = ula.samples(x0=np.zeros(1))
gen_ula_lb = ula_lb.samples(x0=np.zeros(1))
n_burn_in = int(1e3)  # Number of burn-in iterations
for i in range(n_burn_in):
    next(gen_ula)
    next(gen_ula_lb)

# Online statistics objects
mean_ula = pxe_sampler.OnlineMoment(order=1)
mean_ula_lb = pxe_sampler.OnlineMoment(order=1)
var_ula = pxe_sampler.OnlineVariance()
var_ula_lb = pxe_sampler.OnlineVariance()

n = int(1e4)  # Number of samples
samples_ula = np.zeros(n)
samples_ula_lb = np.zeros(n)
for i in range(n):
    sample = next(gen_ula)
    sample_lb = next(gen_ula_lb)
    samples_ula[i] = sample
    samples_ula_lb[i] = sample_lb
    mean = float(mean_ula.update(sample))
    var = float(var_ula.update(sample))
    mean_lb = float(mean_ula_lb.update(sample_lb))
    var_lb = float(var_ula_lb.update(sample_lb))

# Theoretical variances of biased stationary distributions of ULA
biased_var = 1 / (1 - ula._gamma / 2)
biased_var_lb = 1 / (1 - ula_lb._gamma / 2)

# Quantify goodness of fit of empirical distribution with theoretical distribution (Cram√©r-von Mises test)
cvm = sp.stats.cramervonmises(samples_ula, "norm", args=(0, np.sqrt(biased_var)))
cvm_lb = sp.stats.cramervonmises(samples_ula_lb, "norm", args=(0, np.sqrt(biased_var_lb)))

# Plots
grid = np.linspace(-4, 4, 1000)

plt.figure()
plt.title(
    f"ULA samples (large step size) \n Empirical mean: {mean:.3f} (theoretical: 0) \n "
    f"Empirical variance: {var:.3f} (theoretical: {biased_var:.3f}) \n"
    f"Cram√©r-von Mises goodness of fit: {cvm.statistic:.3f}"
)
plt.hist(samples_ula, range=(min(grid), max(grid)), bins=100, density=True)
plt.plot(grid, sp.stats.norm.pdf(grid), label=r"$p(x)$")
plt.plot(grid, sp.stats.norm.pdf(grid, scale=np.sqrt(biased_var)), label=r"$p_{\gamma_1}(x)$")
plt.legend()
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/experimental/sampler.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.experimental.sampler as pxe_sampler
import pyxu.operator as pxo
import scipy as sp

f = pxo.SquaredL2Norm(dim_shape=1) / 2  # To sample 1D normal distribution (mean 0, variance 1)
ula = pxe_sampler.ULA(f=f)  # Sampler with maximum step size
ula_lb = pxe_sampler.ULA(f=f, gamma=1e-1)  # Sampler with small step size

gen_ula = ula.samples(x0=np.zeros(1))
gen_ula_lb = ula_lb.samples(x0=np.zeros(1))
n_burn_in = int(1e3)  # Number of burn-in iterations
for i in range(n_burn_in):
    next(gen_ula)
    next(gen_ula_lb)

# Online statistics objects
mean_ula = pxe_sampler.OnlineMoment(order=1)
mean_ula_lb = pxe_sampler.OnlineMoment(order=1)
var_ula = pxe_sampler.OnlineVariance()
var_ula_lb = pxe_sampler.OnlineVariance()

n = int(1e4)  # Number of samples
samples_ula = np.zeros(n)
samples_ula_lb = np.zeros(n)
for i in range(n):
    sample = next(gen_ula)
    sample_lb = next(gen_ula_lb)
    samples_ula[i] = sample
    samples_ula_lb[i] = sample_lb
    mean = float(mean_ula.update(sample))
    var = float(var_ula.update(sample))
    mean_lb = float(mean_ula_lb.update(sample_lb))
    var_lb = float(var_ula_lb.update(sample_lb))

# Theoretical variances of biased stationary distributions of ULA
biased_var = 1 / (1 - ula._gamma / 2)
biased_var_lb = 1 / (1 - ula_lb._gamma / 2)

# Quantify goodness of fit of empirical distribution with theoretical distribution (Cram√©r-von Mises test)
cvm = sp.stats.cramervonmises(samples_ula, "norm", args=(0, np.sqrt(biased_var)))
cvm_lb = sp.stats.cramervonmises(samples_ula_lb, "norm", args=(0, np.sqrt(biased_var_lb)))

# Plots
grid = np.linspace(-4, 4, 1000)

plt.figure()
plt.title(
    f"ULA samples (large step size) \n Empirical mean: {mean:.3f} (theoretical: 0) \n "
    f"Empirical variance: {var:.3f} (theoretical: {biased_var:.3f}) \n"
    f"Cram√©r-von Mises goodness of fit: {cvm.statistic:.3f}"
)
plt.hist(samples_ula, range=(min(grid), max(grid)), bins=100, density=True)
plt.plot(grid, sp.stats.norm.pdf(grid), label=r"$p(x)$")
plt.plot(grid, sp.stats.norm.pdf(grid, scale=np.sqrt(biased_var)), label=r"$p_{\gamma_1}(x)$")
plt.legend()
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/experimental/sampler.rst: WARNING: Could not match transformation of `pyxu.experimental.sampler` on source lines 3-3, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.experimental.sampler as pxe_sampler
import pyxu.operator as pxo
import scipy as sp

f = pxo.SquaredL2Norm(dim_shape=1) / 2  # To sample 1D normal distribution (mean 0, variance 1)
ula = pxe_sampler.ULA(f=f)  # Sampler with maximum step size
ula_lb = pxe_sampler.ULA(f=f, gamma=1e-1)  # Sampler with small step size

gen_ula = ula.samples(x0=np.zeros(1))
gen_ula_lb = ula_lb.samples(x0=np.zeros(1))
n_burn_in = int(1e3)  # Number of burn-in iterations
for i in range(n_burn_in):
    next(gen_ula)
    next(gen_ula_lb)

# Online statistics objects
mean_ula = pxe_sampler.OnlineMoment(order=1)
mean_ula_lb = pxe_sampler.OnlineMoment(order=1)
var_ula = pxe_sampler.OnlineVariance()
var_ula_lb = pxe_sampler.OnlineVariance()

n = int(1e4)  # Number of samples
samples_ula = np.zeros(n)
samples_ula_lb = np.zeros(n)
for i in range(n):
    sample = next(gen_ula)
    sample_lb = next(gen_ula_lb)
    samples_ula[i] = sample
    samples_ula_lb[i] = sample_lb
    mean = float(mean_ula.update(sample))
    var = float(var_ula.update(sample))
    mean_lb = float(mean_ula_lb.update(sample_lb))
    var_lb = float(var_ula_lb.update(sample_lb))

# Theoretical variances of biased stationary distributions of ULA
biased_var = 1 / (1 - ula._gamma / 2)
biased_var_lb = 1 / (1 - ula_lb._gamma / 2)

# Quantify goodness of fit of empirical distribution with theoretical distribution (Cram√©r-von Mises test)
cvm = sp.stats.cramervonmises(samples_ula, "norm", args=(0, np.sqrt(biased_var)))
cvm_lb = sp.stats.cramervonmises(samples_ula_lb, "norm", args=(0, np.sqrt(biased_var_lb)))

# Plots
grid = np.linspace(-4, 4, 1000)

plt.figure()
plt.title(
    f"ULA samples (large step size) \n Empirical mean: {mean:.3f} (theoretical: 0) \n "
    f"Empirical variance: {var:.3f} (theoretical: {biased_var:.3f}) \n"
    f"Cram√©r-von Mises goodness of fit: {cvm.statistic:.3f}"
)
plt.hist(samples_ula, range=(min(grid), max(grid)), bins=100, density=True)
plt.plot(grid, sp.stats.norm.pdf(grid), label=r"$p(x)$")
plt.plot(grid, sp.stats.norm.pdf(grid, scale=np.sqrt(biased_var)), label=r"$p_{\gamma_1}(x)$")
plt.legend()
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/experimental/sampler.rst: WARNING: Could not match transformation of `scipy` on source lines 5-5, source:
import matplotlib.pyplot as plt
import numpy as np
import pyxu.experimental.sampler as pxe_sampler
import pyxu.operator as pxo
import scipy as sp

f = pxo.SquaredL2Norm(dim_shape=1) / 2  # To sample 1D normal distribution (mean 0, variance 1)
ula = pxe_sampler.ULA(f=f)  # Sampler with maximum step size
ula_lb = pxe_sampler.ULA(f=f, gamma=1e-1)  # Sampler with small step size

gen_ula = ula.samples(x0=np.zeros(1))
gen_ula_lb = ula_lb.samples(x0=np.zeros(1))
n_burn_in = int(1e3)  # Number of burn-in iterations
for i in range(n_burn_in):
    next(gen_ula)
    next(gen_ula_lb)

# Online statistics objects
mean_ula = pxe_sampler.OnlineMoment(order=1)
mean_ula_lb = pxe_sampler.OnlineMoment(order=1)
var_ula = pxe_sampler.OnlineVariance()
var_ula_lb = pxe_sampler.OnlineVariance()

n = int(1e4)  # Number of samples
samples_ula = np.zeros(n)
samples_ula_lb = np.zeros(n)
for i in range(n):
    sample = next(gen_ula)
    sample_lb = next(gen_ula_lb)
    samples_ula[i] = sample
    samples_ula_lb[i] = sample_lb
    mean = float(mean_ula.update(sample))
    var = float(var_ula.update(sample))
    mean_lb = float(mean_ula_lb.update(sample_lb))
    var_lb = float(var_ula_lb.update(sample_lb))

# Theoretical variances of biased stationary distributions of ULA
biased_var = 1 / (1 - ula._gamma / 2)
biased_var_lb = 1 / (1 - ula_lb._gamma / 2)

# Quantify goodness of fit of empirical distribution with theoretical distribution (Cram√©r-von Mises test)
cvm = sp.stats.cramervonmises(samples_ula, "norm", args=(0, np.sqrt(biased_var)))
cvm_lb = sp.stats.cramervonmises(samples_ula_lb, "norm", args=(0, np.sqrt(biased_var_lb)))

# Plots
grid = np.linspace(-4, 4, 1000)

plt.figure()
plt.title(
    f"ULA samples (large step size) \n Empirical mean: {mean:.3f} (theoretical: 0) \n "
    f"Empirical variance: {var:.3f} (theoretical: {biased_var:.3f}) \n"
    f"Cram√©r-von Mises goodness of fit: {cvm.statistic:.3f}"
)
plt.hist(samples_ula, range=(min(grid), max(grid)), bins=100, density=True)
plt.plot(grid, sp.stats.norm.pdf(grid), label=r"$p(x)$")
plt.plot(grid, sp.stats.norm.pdf(grid, scale=np.sqrt(biased_var)), label=r"$p_{\gamma_1}(x)$")
plt.legend()
plt.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import MovingAverage

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

ma = MovingAverage(dim_shape, size=5)
out = ma(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import MovingAverage

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

ma = MovingAverage(dim_shape, size=5)
out = ma(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import DoG

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

dog = DoG(dim_shape, low_sigma=3)
out = dog(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import DoG

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

dog = DoG(dim_shape, low_sigma=3)
out = dog(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Laplace

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

laplace = Laplace(dim_shape)
out = laplace(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Laplace

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

laplace = Laplace(dim_shape)
out = laplace(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Sobel

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

sobel = Sobel(dim_shape)
out = sobel(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Sobel

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

sobel = Sobel(dim_shape)
out = sobel(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Prewitt

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

prewitt = Prewitt(dim_shape)
out = prewitt(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Prewitt

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

prewitt = Prewitt(dim_shape)
out = prewitt(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 1-1, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Scharr

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

scharr = Scharr(dim_shape)
out = scharr(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 2-2, source:
import matplotlib.pyplot as plt
import numpy as np
from pyxu.operator import Scharr

dim_shape = (11, 11)
image = np.zeros(dim_shape)
image[5, 5] = 1.

scharr = Scharr(dim_shape)
out = scharr(image)
plt.figure(figsize=(10, 5))
plt.subplot(121)
plt.imshow(image)
plt.colorbar()
plt.subplot(122)
plt.imshow(out)
plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import StructureTensor
from pyxu.util.misc import peaks

# Define input image
n = 1000
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
nsamples = 2
dim_shape = image.shape  # (1000, 1000)
images = np.tile(image, (nsamples, 1, 1))
# Instantiate structure tensor operator
structure_tensor = StructureTensor(dim_shape=dim_shape)

outputs = structure_tensor(images)
print(outputs.shape)  # (2, 3, 1000, 1000)
# Plot
plt.figure()
plt.imshow(images[0])
plt.colorbar()
plt.title("Image")
plt.axis("off")

plt.figure()
plt.imshow(outputs[0][0])
plt.colorbar()
plt.title(r"$\hat{S}_{xx}$")
plt.axis("off")

plt.figure()
plt.imshow(outputs[0][1])
plt.colorbar()
plt.title(r"$\hat{S}_{xy}$")
plt.axis("off")

plt.figure()
plt.imshow(outputs[0][2])
plt.colorbar()
plt.title(r"$\hat{S}_{yy}$")
plt.axis("off")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import StructureTensor
from pyxu.util.misc import peaks

# Define input image
n = 1000
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
nsamples = 2
dim_shape = image.shape  # (1000, 1000)
images = np.tile(image, (nsamples, 1, 1))
# Instantiate structure tensor operator
structure_tensor = StructureTensor(dim_shape=dim_shape)

outputs = structure_tensor(images)
print(outputs.shape)  # (2, 3, 1000, 1000)
# Plot
plt.figure()
plt.imshow(images[0])
plt.colorbar()
plt.title("Image")
plt.axis("off")

plt.figure()
plt.imshow(outputs[0][0])
plt.colorbar()
plt.title(r"$\hat{S}_{xx}$")
plt.axis("off")

plt.figure()
plt.imshow(outputs[0][1])
plt.colorbar()
plt.title(r"$\hat{S}_{xy}$")
plt.axis("off")

plt.figure()
plt.imshow(outputs[0][2])
plt.colorbar()
plt.title(r"$\hat{S}_{yy}$")
plt.axis("off")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import PartialDerivative
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # Shape of our image
# Specify derivative order at each direction
df_dx = (1, 0)  # Compute derivative of order 1 in first dimension
d2f_dy2 = (0, 2)  # Compute derivative of order 2 in second dimension
d3f_dxdy2 = (1, 2)  # Compute derivative of order 1 in first dimension and der. of order 2 in second dimension
# Instantiate derivative operators
sigma = 2.0
diff1 = PartialDerivative.gaussian_derivative(order=df_dx, dim_shape=dim_shape, sigma=sigma / np.sqrt(2))
diff2 = PartialDerivative.gaussian_derivative(order=d2f_dy2, dim_shape=dim_shape, sigma=sigma / np.sqrt(2))
diff = PartialDerivative.gaussian_derivative(order=d3f_dxdy2, dim_shape=dim_shape, sigma=sigma)
# Compute derivatives
out1 = (diff1 * diff2)(image)
out2 = diff(image)
# Plot derivatives
fig, axs = plt.subplots(1, 3, figsize=(15, 4))
im = axs[0].imshow(image)
axs[0].axis("off")
axs[0].set_title("f(x,y)")
plt.colorbar(im, ax=axs[0])
axs[1].imshow(out1)
axs[1].axis("off")
axs[1].set_title(r"$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$")
plt.colorbar(im, ax=axs[1])

axs[2].imshow(out2)
axs[2].axis("off")
axs[2].set_title(r"$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$")
plt.colorbar(im, ax=axs[2])

# Check approximation error
plt.figure()
plt.imshow(abs(out1 - out2)), plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import PartialDerivative
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # Shape of our image
# Specify derivative order at each direction
df_dx = (1, 0)  # Compute derivative of order 1 in first dimension
d2f_dy2 = (0, 2)  # Compute derivative of order 2 in second dimension
d3f_dxdy2 = (1, 2)  # Compute derivative of order 1 in first dimension and der. of order 2 in second dimension
# Instantiate derivative operators
sigma = 2.0
diff1 = PartialDerivative.gaussian_derivative(order=df_dx, dim_shape=dim_shape, sigma=sigma / np.sqrt(2))
diff2 = PartialDerivative.gaussian_derivative(order=d2f_dy2, dim_shape=dim_shape, sigma=sigma / np.sqrt(2))
diff = PartialDerivative.gaussian_derivative(order=d3f_dxdy2, dim_shape=dim_shape, sigma=sigma)
# Compute derivatives
out1 = (diff1 * diff2)(image)
out2 = diff(image)
# Plot derivatives
fig, axs = plt.subplots(1, 3, figsize=(15, 4))
im = axs[0].imshow(image)
axs[0].axis("off")
axs[0].set_title("f(x,y)")
plt.colorbar(im, ax=axs[0])
axs[1].imshow(out1)
axs[1].axis("off")
axs[1].set_title(r"$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$")
plt.colorbar(im, ax=axs[1])

axs[2].imshow(out2)
axs[2].axis("off")
axs[2].set_title(r"$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$")
plt.colorbar(im, ax=axs[2])

# Check approximation error
plt.figure()
plt.imshow(abs(out1 - out2)), plt.colorbar()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import PartialDerivative
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # Shape of our image
# Specify derivative order at each direction
df_dx = (1, 0) # Compute derivative of order 1 in first dimension
d2f_dy2 = (0, 2) # Compute derivative of order 2 in second dimension
d3f_dxdy2 = (1, 2) # Compute derivative of order 1 in first dimension and der. of order 2 in second dimension
# Instantiate derivative operators
diff1 = PartialDerivative.gaussian_derivative(order=df_dx, dim_shape=dim_shape, sigma=2.0)
diff2 = PartialDerivative.gaussian_derivative(order=d2f_dy2, dim_shape=dim_shape, sigma=2.0)
diff = PartialDerivative.gaussian_derivative(order=d3f_dxdy2, dim_shape=dim_shape, sigma=2.0)
# Compute derivatives
out1 = (diff1 * diff2)(image)
out2 = diff(image)
plt.figure()
plt.imshow(image),
plt.axis('off')
plt.colorbar()
plt.title('f(x,y)')
plt.figure()
plt.imshow(out1.T)
plt.axis('off')
plt.title(r'$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$')
plt.figure()
plt.imshow(out2.T)
plt.axis('off')
plt.title(r'$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import PartialDerivative
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # Shape of our image
# Specify derivative order at each direction
df_dx = (1, 0) # Compute derivative of order 1 in first dimension
d2f_dy2 = (0, 2) # Compute derivative of order 2 in second dimension
d3f_dxdy2 = (1, 2) # Compute derivative of order 1 in first dimension and der. of order 2 in second dimension
# Instantiate derivative operators
diff1 = PartialDerivative.gaussian_derivative(order=df_dx, dim_shape=dim_shape, sigma=2.0)
diff2 = PartialDerivative.gaussian_derivative(order=d2f_dy2, dim_shape=dim_shape, sigma=2.0)
diff = PartialDerivative.gaussian_derivative(order=d3f_dxdy2, dim_shape=dim_shape, sigma=2.0)
# Compute derivatives
out1 = (diff1 * diff2)(image)
out2 = diff(image)
plt.figure()
plt.imshow(image),
plt.axis('off')
plt.colorbar()
plt.title('f(x,y)')
plt.figure()
plt.imshow(out1.T)
plt.axis('off')
plt.title(r'$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$')
plt.figure()
plt.imshow(out2.T)
plt.axis('off')
plt.title(r'$\frac{\partial^{3} f(x,y)}{\partial x\partial y^{2}}$')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Gradient
from pyxu.util.misc import peaks

# Define input image
n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # (1000, 1000)
# Instantiate gradient operator
grad = Gradient(dim_shape=dim_shape)

# Compute gradients
df_dx, df_dy = grad(image) # shape = (2, 1000, 1000)

# Plot image
fig, axs = plt.subplots(1, 3, figsize=(15, 4))
im = axs[0].imshow(image)
axs[0].set_title("Image")
axs[0].axis("off")
plt.colorbar(im, ax=axs[0])

# Plot gradient
im = axs[1].imshow(df_dx)
axs[1].set_title(r"$\partial f/ \partial x$")
axs[1].axis("off")
plt.colorbar(im, ax=axs[1])
im = axs[2].imshow(df_dy)
axs[2].set_title(r"$\partial f/ \partial y$")
axs[2].axis("off")
plt.colorbar(im, ax=axs[2])
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Gradient
from pyxu.util.misc import peaks

# Define input image
n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # (1000, 1000)
# Instantiate gradient operator
grad = Gradient(dim_shape=dim_shape)

# Compute gradients
df_dx, df_dy = grad(image) # shape = (2, 1000, 1000)

# Plot image
fig, axs = plt.subplots(1, 3, figsize=(15, 4))
im = axs[0].imshow(image)
axs[0].set_title("Image")
axs[0].axis("off")
plt.colorbar(im, ax=axs[0])

# Plot gradient
im = axs[1].imshow(df_dx)
axs[1].set_title(r"$\partial f/ \partial x$")
axs[1].axis("off")
plt.colorbar(im, ax=axs[1])
im = axs[2].imshow(df_dy)
axs[2].set_title(r"$\partial f/ \partial y$")
axs[2].axis("off")
plt.colorbar(im, ax=axs[2])
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Jacobian
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
image = np.tile(peaks(xx, yy), (3, 1, 1))
jac = Jacobian(dim_shape=image.shape)
out = jac(image)
fig, axes = plt.subplots(3, 2, figsize=(10, 15))
for i in range(3):
   for j in range(2):
       axes[i, j].imshow(out[i, j].T, cmap=["Reds", "Greens", "Blues"][i])
       axes[i, j].set_title(f"$\partial I_{{{['R', 'G', 'B'][j]}}}/\partial{{{['x', 'y'][j]}}}$")
plt.suptitle("Jacobian")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Jacobian
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
image = np.tile(peaks(xx, yy), (3, 1, 1))
jac = Jacobian(dim_shape=image.shape)
out = jac(image)
fig, axes = plt.subplots(3, 2, figsize=(10, 15))
for i in range(3):
   for j in range(2):
       axes[i, j].imshow(out[i, j].T, cmap=["Reds", "Greens", "Blues"][i])
       axes[i, j].set_title(f"$\partial I_{{{['R', 'G', 'B'][j]}}}/\partial{{{['x', 'y'][j]}}}$")
plt.suptitle("Jacobian")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Gradient, Divergence, Laplacian
from pyxu.util.misc import peaks

n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # (1000, 1000)
grad = Gradient(dim_shape=dim_shape)
div = Divergence(dim_shape=dim_shape)
# Construct Laplacian via composition
laplacian1 = div * grad
# Compare to default Laplacian
laplacian2 = Laplacian(dim_shape=dim_shape)
output1 = laplacian1(image)
output2 = laplacian2(image)
fig, axes = plt.subplots(1, 2, figsize=(10, 5))
im = axes[0].imshow(np.log(abs(output1)).reshape(*dim_shape))
axes[0].set_title("Laplacian via composition")
plt.colorbar(im, ax=axes[0])
im = axes[1].imshow(np.log(abs(output1)).reshape(*dim_shape))
axes[1].set_title("Default Laplacian")
plt.colorbar(im, ax=axes[1])
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Gradient, Divergence, Laplacian
from pyxu.util.misc import peaks

n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # (1000, 1000)
grad = Gradient(dim_shape=dim_shape)
div = Divergence(dim_shape=dim_shape)
# Construct Laplacian via composition
laplacian1 = div * grad
# Compare to default Laplacian
laplacian2 = Laplacian(dim_shape=dim_shape)
output1 = laplacian1(image)
output2 = laplacian2(image)
fig, axes = plt.subplots(1, 2, figsize=(10, 5))
im = axes[0].imshow(np.log(abs(output1)).reshape(*dim_shape))
axes[0].set_title("Laplacian via composition")
plt.colorbar(im, ax=axes[0])
im = axes[1].imshow(np.log(abs(output1)).reshape(*dim_shape))
axes[1].set_title("Default Laplacian")
plt.colorbar(im, ax=axes[1])
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Hessian, PartialDerivative
from pyxu.util.misc import peaks

n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # (1000, 1000)

# Instantiate Hessian operator
hessian = Hessian(dim_shape=dim_shape, directions="all")
# Compute Hessian
d2f_dx2, d2f_dxdy, d2f_dy2 = hessian(image)

# Plot
fig, axs = plt.subplots(1, 4, figsize=(20, 4))
im = axs[0].imshow(image)
plt.colorbar(im, ax=axs[0])
axs[0].set_title("Image")
axs[0].axis("off")

im = axs[1].imshow(d2f_dx2)
plt.colorbar(im, ax=axs[1])
axs[1].set_title(r"$\partial^{2} f/ \partial x^{2}$")
axs[1].axis("off")

im = axs[2].imshow(d2f_dxdy)
plt.colorbar(im, ax=axs[2])
axs[2].set_title(r"$\partial^{2} f/ \partial x\partial y$")
axs[2].axis("off")

im = axs[3].imshow(d2f_dy2)
plt.colorbar(im, ax=axs[3])
axs[3].set_title(r"$\partial^{2} f/ \partial y^{2}$")
axs[3].axis("off")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Hessian, PartialDerivative
from pyxu.util.misc import peaks

n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)
dim_shape = image.shape  # (1000, 1000)

# Instantiate Hessian operator
hessian = Hessian(dim_shape=dim_shape, directions="all")
# Compute Hessian
d2f_dx2, d2f_dxdy, d2f_dy2 = hessian(image)

# Plot
fig, axs = plt.subplots(1, 4, figsize=(20, 4))
im = axs[0].imshow(image)
plt.colorbar(im, ax=axs[0])
axs[0].set_title("Image")
axs[0].axis("off")

im = axs[1].imshow(d2f_dx2)
plt.colorbar(im, ax=axs[1])
axs[1].set_title(r"$\partial^{2} f/ \partial x^{2}$")
axs[1].axis("off")

im = axs[2].imshow(d2f_dxdy)
plt.colorbar(im, ax=axs[2])
axs[2].set_title(r"$\partial^{2} f/ \partial x\partial y$")
axs[2].axis("off")

im = axs[3].imshow(d2f_dy2)
plt.colorbar(im, ax=axs[3])
axs[3].set_title(r"$\partial^{2} f/ \partial y^{2}$")
axs[3].axis("off")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Laplacian
from pyxu.util.misc import peaks

# Define input image
n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)

dim_shape = image.shape  # (1000, 1000)
# Compute Laplacian
laplacian = Laplacian(dim_shape=dim_shape)
output = laplacian(image) # shape = (1, 1000, 1000)

# Plot
fig, axs = plt.subplots(1, 2, figsize=(10, 4))
im = axs[0].imshow(image)
plt.colorbar(im, ax=axs[0])
axs[0].set_title("Image")
axs[0].axis("off")

im = axs[1].imshow(output.squeeze())
plt.colorbar(im, ax=axs[1])
axs[1].set_title(r"$\partial^{2} f/ \partial x^{2}+\partial^{2} f/ \partial y^{2}$")
axs[1].axis("off")

fig.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import Laplacian
from pyxu.util.misc import peaks

# Define input image
n = 100
x = np.linspace(-3, 3, n)
xx, yy = np.meshgrid(x, x)
image = peaks(xx, yy)

dim_shape = image.shape  # (1000, 1000)
# Compute Laplacian
laplacian = Laplacian(dim_shape=dim_shape)
output = laplacian(image) # shape = (1, 1000, 1000)

# Plot
fig, axs = plt.subplots(1, 2, figsize=(10, 4))
im = axs[0].imshow(image)
plt.colorbar(im, ax=axs[0])
axs[0].set_title("Image")
axs[0].axis("off")

im = axs[1].imshow(output.squeeze())
plt.colorbar(im, ax=axs[1])
axs[1].set_title(r"$\partial^{2} f/ \partial x^{2}+\partial^{2} f/ \partial y^{2}$")
axs[1].axis("off")

fig.show()
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalDerivative
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions = np.zeros(shape=(2, z.size))
directions[0, : z.size // 2] = 1
directions[1, z.size // 2:] = 1
dop = DirectionalDerivative(dim_shape=z.shape, order=1, directions=directions)
out = dop(z)
dop2 = DirectionalDerivative(dim_shape=z.shape, order=2, directions=directions)
out2 = dop2(z)
fig, axs = plt.subplots(1, 3, figsize=(15, 5))
axs = np.ravel(axs)
h = axs[0].pcolormesh(xx, yy, z, shading="auto")
axs[0].quiver(x, x, directions[1].reshape(xx.shape), directions[0].reshape(xx.shape))
plt.colorbar(h, ax=axs[0])
axs[0].set_title("Signal and directions of first derivatives")

h = axs[1].pcolormesh(xx, yy, out.squeeze(), shading="auto")
plt.colorbar(h, ax=axs[1])
axs[1].set_title("First-order directional derivatives")

h = axs[2].pcolormesh(xx, yy, out2.squeeze(), shading="auto")
plt.colorbar(h, ax=axs[2])
axs[2].set_title("Second-order directional derivative")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalDerivative
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions = np.zeros(shape=(2, z.size))
directions[0, : z.size // 2] = 1
directions[1, z.size // 2:] = 1
dop = DirectionalDerivative(dim_shape=z.shape, order=1, directions=directions)
out = dop(z)
dop2 = DirectionalDerivative(dim_shape=z.shape, order=2, directions=directions)
out2 = dop2(z)
fig, axs = plt.subplots(1, 3, figsize=(15, 5))
axs = np.ravel(axs)
h = axs[0].pcolormesh(xx, yy, z, shading="auto")
axs[0].quiver(x, x, directions[1].reshape(xx.shape), directions[0].reshape(xx.shape))
plt.colorbar(h, ax=axs[0])
axs[0].set_title("Signal and directions of first derivatives")

h = axs[1].pcolormesh(xx, yy, out.squeeze(), shading="auto")
plt.colorbar(h, ax=axs[1])
axs[1].set_title("First-order directional derivatives")

h = axs[2].pcolormesh(xx, yy, out2.squeeze(), shading="auto")
plt.colorbar(h, ax=axs[2])
axs[2].set_title("Second-order directional derivative")
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalGradient
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions1 = np.zeros(shape=(2, z.size))
directions1[0, :z.size // 2] = 1
directions1[1, z.size // 2:] = 1
directions2 = np.zeros(shape=(2, z.size))
directions2[1, :z.size // 2] = -1
directions2[0, z.size // 2:] = -1
dim_shape = z.shape
dop = DirectionalGradient(dim_shape=dim_shape, directions=[directions1, directions2])
out = dop(z)
plt.figure()
h = plt.pcolormesh(xx, yy, z, shading='auto')
plt.quiver(x, x, directions1[1].reshape(dim_shape), directions1[0].reshape(xx.shape))
plt.quiver(x, x, directions2[1].reshape(dim_shape), directions2[0].reshape(xx.shape), color='red')
plt.colorbar(h)
plt.title(r'Signal $\mathbf{f}$ and directions of derivatives')
plt.figure()
h = plt.pcolormesh(xx, yy, out[0], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla_{\mathbf{v}_0} \mathbf{f}$')
plt.figure()
h = plt.pcolormesh(xx, yy, out[1], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla_{\mathbf{v}_1} \mathbf{f}$')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalGradient
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions1 = np.zeros(shape=(2, z.size))
directions1[0, :z.size // 2] = 1
directions1[1, z.size // 2:] = 1
directions2 = np.zeros(shape=(2, z.size))
directions2[1, :z.size // 2] = -1
directions2[0, z.size // 2:] = -1
dim_shape = z.shape
dop = DirectionalGradient(dim_shape=dim_shape, directions=[directions1, directions2])
out = dop(z)
plt.figure()
h = plt.pcolormesh(xx, yy, z, shading='auto')
plt.quiver(x, x, directions1[1].reshape(dim_shape), directions1[0].reshape(xx.shape))
plt.quiver(x, x, directions2[1].reshape(dim_shape), directions2[0].reshape(xx.shape), color='red')
plt.colorbar(h)
plt.title(r'Signal $\mathbf{f}$ and directions of derivatives')
plt.figure()
h = plt.pcolormesh(xx, yy, out[0], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla_{\mathbf{v}_0} \mathbf{f}$')
plt.figure()
h = plt.pcolormesh(xx, yy, out[1], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla_{\mathbf{v}_1} \mathbf{f}$')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalLaplacian
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions1 = np.zeros(shape=(2, z.size))
directions1[0, :z.size // 2] = 1
directions1[1, z.size // 2:] = 1
directions2 = np.zeros(shape=(2, z.size))
directions2[1, :z.size // 2] = -1
directions2[0, z.size // 2:] = -1
dim_shape = z.shape
dop = DirectionalLaplacian(dim_shape=dim_shape, directions=[directions1, directions2])
out = dop(z)
plt.figure()
h = plt.pcolormesh(xx, yy, z, shading='auto')
plt.quiver(x, x, directions1[1].reshape(dim_shape), directions1[0].reshape(xx.shape))
plt.quiver(x, x, directions2[1].reshape(dim_shape), directions2[0].reshape(xx.shape), color='red')
plt.colorbar(h)
plt.title('Signal and directions of derivatives')
plt.figure()
h = plt.pcolormesh(xx, yy, out.squeeze(), shading='auto')
plt.colorbar(h)
plt.title('Directional Laplacian')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalLaplacian
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions1 = np.zeros(shape=(2, z.size))
directions1[0, :z.size // 2] = 1
directions1[1, z.size // 2:] = 1
directions2 = np.zeros(shape=(2, z.size))
directions2[1, :z.size // 2] = -1
directions2[0, z.size // 2:] = -1
dim_shape = z.shape
dop = DirectionalLaplacian(dim_shape=dim_shape, directions=[directions1, directions2])
out = dop(z)
plt.figure()
h = plt.pcolormesh(xx, yy, z, shading='auto')
plt.quiver(x, x, directions1[1].reshape(dim_shape), directions1[0].reshape(xx.shape))
plt.quiver(x, x, directions2[1].reshape(dim_shape), directions2[0].reshape(xx.shape), color='red')
plt.colorbar(h)
plt.title('Signal and directions of derivatives')
plt.figure()
h = plt.pcolormesh(xx, yy, out.squeeze(), shading='auto')
plt.colorbar(h)
plt.title('Directional Laplacian')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `numpy` on source lines 1-1, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalHessian
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions1 = np.zeros(shape=(2, z.size))
directions1[0, :z.size // 2] = 1
directions1[1, z.size // 2:] = 1
directions2 = np.zeros(shape=(2, z.size))
directions2[1, :z.size // 2] = -1
directions2[0, z.size // 2:] = -1
dim_shape = z.shape
d_hess = DirectionalHessian(dim_shape=dim_shape, directions=[directions1, directions2])
out = d_hess(z)
plt.figure()
h = plt.pcolormesh(xx, yy, z, shading='auto')
plt.quiver(x, x, directions1[1].reshape(dim_shape), directions1[0].reshape(xx.shape))
plt.quiver(x, x, directions2[1].reshape(dim_shape), directions2[0].reshape(xx.shape), color='red')
plt.colorbar(h)
plt.title(r'Signal $\mathbf{f}$ and directions of derivatives')
plt.figure()
h = plt.pcolormesh(xx, yy, out[0], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla^2_{\mathbf{v}_0} \mathbf{f}$')
plt.figure()
h = plt.pcolormesh(xx, yy, out[1], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla_{\mathbf{v}_0} \nabla_{\mathbf{v}_{1}} \mathbf{f}$')
plt.figure()
h = plt.pcolormesh(xx, yy, out[2], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla^2_{\mathbf{v}_1} \mathbf{f}$')
/home/runner/work/pyxu-org.github.io/pyxu-org.github.io/pyxu/doc/api/operator/linop.rst: WARNING: Could not match transformation of `matplotlib.pyplot` on source lines 2-2, source:
import numpy as np
import matplotlib.pyplot as plt
from pyxu.operator import DirectionalHessian
from pyxu.util.misc import peaks

x = np.linspace(-2.5, 2.5, 25)
xx, yy = np.meshgrid(x, x)
z = peaks(xx, yy)
directions1 = np.zeros(shape=(2, z.size))
directions1[0, :z.size // 2] = 1
directions1[1, z.size // 2:] = 1
directions2 = np.zeros(shape=(2, z.size))
directions2[1, :z.size // 2] = -1
directions2[0, z.size // 2:] = -1
dim_shape = z.shape
d_hess = DirectionalHessian(dim_shape=dim_shape, directions=[directions1, directions2])
out = d_hess(z)
plt.figure()
h = plt.pcolormesh(xx, yy, z, shading='auto')
plt.quiver(x, x, directions1[1].reshape(dim_shape), directions1[0].reshape(xx.shape))
plt.quiver(x, x, directions2[1].reshape(dim_shape), directions2[0].reshape(xx.shape), color='red')
plt.colorbar(h)
plt.title(r'Signal $\mathbf{f}$ and directions of derivatives')
plt.figure()
h = plt.pcolormesh(xx, yy, out[0], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla^2_{\mathbf{v}_0} \mathbf{f}$')
plt.figure()
h = plt.pcolormesh(xx, yy, out[1], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla_{\mathbf{v}_0} \nabla_{\mathbf{v}_{1}} \mathbf{f}$')
plt.figure()
h = plt.pcolormesh(xx, yy, out[2], shading='auto')
plt.colorbar(h)
plt.title(r'$\nabla^2_{\mathbf{v}_1} \mathbf{f}$')
