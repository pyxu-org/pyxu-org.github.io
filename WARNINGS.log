[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/lipschitz.ipynb:286: WARNING: invalid syntax (<unknown>, line 24) in document 'guide/lipschitz'
Parsed source in `python` block:
concatenations: # Access Lipschitz constant of an operator 'op'
lip_const = op.lipschitz
                # Estimate Lipschitz constant and update the attribute
op.lipschitz = op.estimate_lipschitz()
                # Using trace method
op.lipschitz = op.estimate_lipschitz(method="trace")
                # Using SVD method with reduced accuracy
op.lipschitz = op.estimate_lipschitz(method="svd", tol=1e-3)
                from pyxu.abc import LinOp
import numpy as np

rand_op = LinOp.from_array(np.random.random((10000, 10000)))

                rand_op.lipschitz # Unknown as this stage

                get_ipython().run_cell_magic('timeit', '', 'rand_op.lipschitz = rand_op.estimate_lipschitz(method="trace")\n')

                rand_op.lipschitz # Rough estimate

                get_ipython().run_cell_magic('timeit', '', 'rand_op.lipschitz = rand_op.estimate_lipschitz(method="svd", tol=1e-2)\n')

                rand_op.lipschitz # Tighter estimate

block source:   >> op1 = difffunc * linop;
                >> op1.lipschitz == difffunc.lipschitz * linop.lipschitz
                True
                >> op1.diff_lipschitz == difffunc.diff_lipschitz * (linop.lipschitz ** 2)
                True
                >> op2 = linop * diffmap;
                >> op2.diff_lipschitz == linop.lipschitz * diffmap.diff_lipschitz
                True
                ...[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/fair/howto.rst:2: WARNING: Duplicate explicit target name: "catalogue website".[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/fair/howto.rst:33: WARNING: invalid syntax (<unknown>, line 2) in document 'fair/howto'
Parsed source in `python` block:
concatenations: import pyxu.opt.solver.GradientDescent
block source:   ModuleNotFoundError: No module named 'pyxu.opt.solver.GradientDescent'[39;49;00m
[31m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:640: ERROR: Unexpected indentation.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:638: WARNING: Inline interpreted text or phrase reference start-string without end-string.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:644: WARNING: Block quote ends without a blank line; unexpected unindent.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:653: WARNING: Inline interpreted text or phrase reference start-string without end-string.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:655: WARNING: Definition list ends without a blank line; unexpected unindent.[39;49;00m
[31m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:765: ERROR: Unexpected indentation.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:763: WARNING: Inline interpreted text or phrase reference start-string without end-string.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:768: WARNING: Block quote ends without a blank line; unexpected unindent.[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:109: WARNING: File not found: 'examples/TODO'[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:156: WARNING: expected ':' (<unknown>, line 29) in document 'examples/DifferentialOperators'
Parsed source in `python` block:
concatenations: def D(f):
    """
    Computes the partial derivative via forward finite differences.

    Input
    -----
    f: vector
        Input signal

    Output
    ------
    y: vector
        Derivative
    """

    y = np.zeros_like(f)
    for n in range(len(f) - 1):
        y[n] = f[n + 1] - f[n]
    return y
block source:   def finite_difference(
                        arg_shape: pyct.NDArrayShape,
                        order: cabc.Sequence[pyct.Integer, ...],
                        scheme: typ.Union[str, cabc.Sequence[str, ...]] = "forward",
                        accuracy: typ.Union[pyct.Integer, cabc.Sequence[pyct.Integer, ...]] = 1,
                        mode: ModeSpec = "constant",
                        gpu: bool = False,
                        dtype: typ.Optional[pyct.DType] = None,
                        sampling: typ.Union[pyct.Real, cabc.Sequence[pyct.Real, ...]] = 1,
                    ) -> pyct.OpT[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:171: WARNING: expected ':' (<unknown>, line 29) in document 'examples/DifferentialOperators'
Parsed source in `python` block:
concatenations: def D(f):
    """
    Computes the partial derivative via forward finite differences.

    Input
    -----
    f: vector
        Input signal

    Output
    ------
    y: vector
        Derivative
    """

    y = np.zeros_like(f)
    for n in range(len(f) - 1):
        y[n] = f[n + 1] - f[n]
    return y
block source:   def gaussian_derivative(
                        arg_shape: pyct.NDArrayShape,
                        order: cabc.Sequence[pyct.Integer, ...],
                        sigma: typ.Union[pyct.Real, cabc.Sequence[pyct.Real, ...]] = 1.0,
                        truncate: typ.Union[pyct.Real, cabc.Sequence[pyct.Real, ...]] = 3.0,
                        mode: ModeSpec = "constant",
                        gpu: bool = False,
                        dtype: typ.Optional[pyct.DType] = None,
                        sampling: typ.Union[pyct.Real, cabc.Sequence[pyct.Real, ...]] = 1,
                    ) -> pyct.OpT[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:680: WARNING: expected an indented block after function definition on line 139 (<unknown>, line 148) in document 'examples/DifferentialOperators'
Parsed source in `python` block:
concatenations: def D(f):
    """
    Computes the partial derivative via forward finite differences.

    Input
    -----
    f: vector
        Input signal

    Output
    ------
    y: vector
        Derivative
    """

    y = np.zeros_like(f)
    for n in range(len(f) - 1):
        y[n] = f[n + 1] - f[n]
    return y
                import matplotlib.pyplot as plt
import numpy as np

rng = np.random.default_rng(0)

from pyxu.operator import PartialDerivative

                # 1) Define ground truth signal

N = 500  # number of points
x_ax = np.linspace(0, 2 * np.pi, N)  # coordinates
dx = x_ax[1] - x_ax[0]  # sampling or pixel size

arr = np.sin(x_ax)  # ground truth signal
derivative = np.cos(x_ax)  # ground truth derivative


# 2) Define noisy measurements
noise = rng.normal(scale=0.01, size=N)
arr_noisy = arr + noise


# 3) Instantiate partial derivative operator via finite differences
finite_difference = PartialDerivative.finite_difference(
    arg_shape=(N,),
    order=(1,),
    scheme="forward",
    accuracy=1,
    sampling=dx,  # we should include the pixel size for accurate approximation
)

# 4) Estimate derivative
derivative_fd = finite_difference(arr)
derivative_fd_noisy = finite_difference(arr_noisy)

# 5) Plot results

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].plot(x_ax, arr, label="Signal", c="k")
axs[0].plot(x_ax, arr_noisy, label="Noisy signal", zorder=0, c="C1")

axs[1].plot(x_ax, derivative, label="Derivative of non-noisy signal", c="k")
axs[1].plot(
    x_ax, derivative_fd, ls="--", label="Finite difference (non-noisy signal)", c="C2"
)
axs[1].plot(
    x_ax,
    derivative_fd_noisy,
    label="Finite difference (noisy signal)",
    zorder=0,
    c="C3",
)

for ax in axs.ravel():
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Amplitude")
    ax.legend();

                gaussian_derivative = PartialDerivative.gaussian_derivative(
    arg_shape=(N,), order=(1,), sigma=dx, truncate=1, sampling=(dx,)
)
gaussian_derivative.visualize()

                derviative_gd = gaussian_derivative(arr_noisy)
derviative_fd = finite_difference(arr_noisy)


fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].plot(x_ax, arr, label="Signal", c="k")
axs[0].plot(x_ax, arr_noisy, label="Noisy signal", zorder=0, c="C1")

axs[1].plot(x_ax, derivative, label="Derivative of non-noisy signal", c="k")
axs[1].plot(
    x_ax,
    derivative_fd_noisy,
    label="Finite difference (noisy signal)",
    zorder=0,
    c="C3",
)
axs[1].plot(
    x_ax, derviative_gd, label="Gaussian derivative (noisy signal)", c="C4", zorder=1
)

for ax in axs.ravel():
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Amplitude")
    ax.legend();

                gaussian_derivative_accurate = PartialDerivative.gaussian_derivative(
    arg_shape=(N,), order=(1,), sigma=dx, truncate=4, sampling=(dx,)
)


derviative_gd_accurate = gaussian_derivative_accurate(arr_noisy)

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].plot(x_ax, arr, label="Signal", c="k")
axs[0].plot(x_ax, arr_noisy, label="Noisy signal", zorder=0, c="C1")

axs[1].plot(x_ax, derivative, label="Derivative of non-noisy signal", c="k")
axs[1].plot(
    x_ax, derviative_gd, label="Gaussian derivative (1x$\sigma$)", c="C4", zorder=0
)
axs[1].plot(
    x_ax,
    derviative_gd_accurate,
    label="Gaussian derivative (4x$\sigma$)",
    c="C6",
    zorder=1,
)

for ax in axs.ravel():
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Amplitude")
    ax.legend();

block source:   def Gradient(
                    arg_shape: pyct.NDArrayShape,
                    directions: typ.Optional[pyct.NDArrayAxis] = None,
                    diff_method: str = "fd",
                    mode: ModeSpec = "constant",
                    gpu: bool = False,
                    dtype: typ.Optional[pyct.DType] = None,
                    parallel: bool = False,
                    **diff_kwargs,
                ) -> pyct.OpT:[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/examples/DifferentialOperators.ipynb:694: WARNING: expected an indented block after function definition on line 139 (<unknown>, line 152) in document 'examples/DifferentialOperators'
Parsed source in `python` block:
concatenations: def D(f):
    """
    Computes the partial derivative via forward finite differences.

    Input
    -----
    f: vector
        Input signal

    Output
    ------
    y: vector
        Derivative
    """

    y = np.zeros_like(f)
    for n in range(len(f) - 1):
        y[n] = f[n + 1] - f[n]
    return y
                import matplotlib.pyplot as plt
import numpy as np

rng = np.random.default_rng(0)

from pyxu.operator import PartialDerivative

                # 1) Define ground truth signal

N = 500  # number of points
x_ax = np.linspace(0, 2 * np.pi, N)  # coordinates
dx = x_ax[1] - x_ax[0]  # sampling or pixel size

arr = np.sin(x_ax)  # ground truth signal
derivative = np.cos(x_ax)  # ground truth derivative


# 2) Define noisy measurements
noise = rng.normal(scale=0.01, size=N)
arr_noisy = arr + noise


# 3) Instantiate partial derivative operator via finite differences
finite_difference = PartialDerivative.finite_difference(
    arg_shape=(N,),
    order=(1,),
    scheme="forward",
    accuracy=1,
    sampling=dx,  # we should include the pixel size for accurate approximation
)

# 4) Estimate derivative
derivative_fd = finite_difference(arr)
derivative_fd_noisy = finite_difference(arr_noisy)

# 5) Plot results

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].plot(x_ax, arr, label="Signal", c="k")
axs[0].plot(x_ax, arr_noisy, label="Noisy signal", zorder=0, c="C1")

axs[1].plot(x_ax, derivative, label="Derivative of non-noisy signal", c="k")
axs[1].plot(
    x_ax, derivative_fd, ls="--", label="Finite difference (non-noisy signal)", c="C2"
)
axs[1].plot(
    x_ax,
    derivative_fd_noisy,
    label="Finite difference (noisy signal)",
    zorder=0,
    c="C3",
)

for ax in axs.ravel():
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Amplitude")
    ax.legend();

                gaussian_derivative = PartialDerivative.gaussian_derivative(
    arg_shape=(N,), order=(1,), sigma=dx, truncate=1, sampling=(dx,)
)
gaussian_derivative.visualize()

                derviative_gd = gaussian_derivative(arr_noisy)
derviative_fd = finite_difference(arr_noisy)


fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].plot(x_ax, arr, label="Signal", c="k")
axs[0].plot(x_ax, arr_noisy, label="Noisy signal", zorder=0, c="C1")

axs[1].plot(x_ax, derivative, label="Derivative of non-noisy signal", c="k")
axs[1].plot(
    x_ax,
    derivative_fd_noisy,
    label="Finite difference (noisy signal)",
    zorder=0,
    c="C3",
)
axs[1].plot(
    x_ax, derviative_gd, label="Gaussian derivative (noisy signal)", c="C4", zorder=1
)

for ax in axs.ravel():
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Amplitude")
    ax.legend();

                gaussian_derivative_accurate = PartialDerivative.gaussian_derivative(
    arg_shape=(N,), order=(1,), sigma=dx, truncate=4, sampling=(dx,)
)


derviative_gd_accurate = gaussian_derivative_accurate(arr_noisy)

fig, axs = plt.subplots(1, 2, figsize=(10, 5))

axs[0].plot(x_ax, arr, label="Signal", c="k")
axs[0].plot(x_ax, arr_noisy, label="Noisy signal", zorder=0, c="C1")

axs[1].plot(x_ax, derivative, label="Derivative of non-noisy signal", c="k")
axs[1].plot(
    x_ax, derviative_gd, label="Gaussian derivative (1x$\sigma$)", c="C4", zorder=0
)
axs[1].plot(
    x_ax,
    derviative_gd_accurate,
    label="Gaussian derivative (4x$\sigma$)",
    c="C6",
    zorder=1,
)

for ax in axs.ravel():
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("Amplitude")
    ax.legend();

block source:   def Hessian(
                    arg_shape: pyct.NDArrayShape,
                    directions: typ.Union[
                        str,
                        cabc.Sequence[pyct.Integer, pyct.Integer],
                        cabc.Sequence[cabc.Sequence[pyct.Integer, pyct.Integer], ...],
                    ] = "all",
                    diff_method: str = "fd",
                    mode: ModeSpec = "constant",
                    gpu: bool = False,
                    dtype: typ.Optional[pyct.DType] = None,
                    parallel: bool = False,
                    **diff_kwargs,
                ) -> pyct.OpT:[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:18: WARNING: invalid syntax (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: >> op1 + op2  # Addition of two operators
              >> op1 * op2  # Composition of two operators
              >> op ** 3    # Exponentiation of an operator
              >> op.argscale(c)  # Dilation by a scalar 'c'
              >> op.argshift(x)  # Shifting by a vector 'x'
              >> 4 * op  # Scaling by a scalar
              >> op.T  # Transposing[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:54: WARNING: invalid syntax (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: >> h = f * L
              >> h.grad(x) = L.jacobian(x).adjoint(f.grad(L(x)))[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:63: WARNING: cannot assign to function call here. Maybe you meant '==' instead of '='? (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: op.apply(arr) = lhs.apply(rhs.apply(arr))
              op.lipschitz = lhs.lipschitz * rhs.lipschitz[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:70: WARNING: cannot assign to function call here. Maybe you meant '==' instead of '='? (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: op.prox(arr, tau) = rhs.adjoint(lhs.prox(rhs.apply(arr), tau))[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:76: WARNING: cannot assign to function call here. Maybe you meant '==' instead of '='? (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: op.jacobian(arr) = lhs.jacobian(rhs.apply(arr)) * rhs.jacobian(arr)
              op.diff_lipschitz =
                  linear * linear  => 0
                  linear * diff    => lhs.lipschitz * rhs.diff_lipschitz
                  diff   * linear  => lhs.diff_lipschitz * (rhs.lipschitz ** 2)
                  diff   * diff    => infty[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:87: WARNING: cannot assign to function call here. Maybe you meant '==' instead of '='? (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: op.grad(arr) = lhs.grad(rhs.apply(arr)) @ rhs.jacobian(arr).asarray()[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algebra.ipynb:98: WARNING: invalid syntax (<unknown>, line 1) in document 'guide/algebra'
Parsed source in `python` block:
block source: >> coo_block(([A(500,1000), B(1,1000), C(500,500), D(1,3)],  # data
                 ...      [[0, 1, 0, 2],  # i
                 ...       [0, 0, 2, 1],  # j
                          ]),grid_shape=(3, 3))[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/algorithms.ipynb:66: WARNING: invalid syntax (<unknown>, line 1) in document 'guide/algorithms'
Parsed source in `python` block:
block source: >> K = vstack([K_1, ..., K_J])
              >> H = hstack([h_1, ..., h_J])[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/funcs.ipynb:129: WARNING: Title underline too short.

Implicit Functionals: The Undercover Agents 🕵️‍♀️
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/doc/guide/funcs.ipynb:129: WARNING: Title underline too short.

Implicit Functionals: The Undercover Agents 🕵️‍♀️
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/interop/jax.py:docstring of pyxu.operator.interop.jax._from_jax:: WARNING: py:class reference target not found: pyxu.operator.interop.jax.JaxArray[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/interop/jax.py:docstring of pyxu.operator.interop.jax._to_jax:: WARNING: py:class reference target not found: pyxu.operator.interop.jax.JaxArray[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/blocks.py:docstring of pyxu.operator.blocks.coo_block:33: WARNING: py:mod reference target not found: pyxu.operator.blocks[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/pad.py:docstring of pyxu.operator.linop.pad.Pad.__init__:10: WARNING: py:class reference target not found: pyxu.operator.linop.pad.Pad.WidthSpec[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/filter.py:docstring of pyxu.operator.linop.filter.MovingAverage:30: WARNING: py:class reference target not found: pyxu.operator.linop.filter.IndexSpec[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:65: WARNING: py:class reference target not found: (Integer[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:65: WARNING: py:class reference target not found: Integer)[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:65: WARNING: py:class reference target not found: ((Integer[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:65: WARNING: py:class reference target not found: Integer)[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:65: WARNING: py:class reference target not found: (Integer[39;49;00m
[91m/Users/mmjasime/Documents/Github/pyxu/src/pyxu/operator/linop/diff.py:docstring of pyxu.operator.linop.diff.Hessian:65: WARNING: py:class reference target not found: Integer))[39;49;00m
